import {
  require_fs,
  require_os,
  require_path,
  require_typescript
} from "./chunk-XOSPLZ4J.js";
import {
  require_assert
} from "./chunk-EUUNMJCH.js";
import {
  require_crypto
} from "./chunk-H56A3ANH.js";
import {
  __commonJS,
  __esm,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __require,
  __toCommonJS
} from "./chunk-Y7S7B2N7.js";

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/homedir.js"(exports, module) {
    "use strict";
    var os = require_os();
    module.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/caller.js"(exports, module) {
    module.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js"(exports, module) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module.exports = win32.parse;
    else
      module.exports = posix.parse;
    module.exports.posix = posix.parse;
    module.exports.win32 = win32.parse;
  }
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/node-modules-paths.js"(exports, module) {
    var path3 = require_path();
    var parse3 = path3.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths3 = [absoluteStart];
      var parsed = parse3(absoluteStart);
      while (parsed.dir !== paths3[paths3.length - 1]) {
        paths3.push(parsed.dir);
        parsed = parse3(parsed.dir);
      }
      return paths3.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path3.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/normalize-options.js"(exports, module) {
    module.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max3 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind3(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max3(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/.pnpm/hasown@2.0.0/node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/.pnpm/hasown@2.0.0/node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call3 = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind3 = require_function_bind();
    module.exports = bind3.call(call3, $hasOwn);
  }
});

// node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/index.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range3) {
      var specifiers = range3.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module.exports = function isCore(x, nodeVersion) {
      return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/async.js"(exports, module) {
    var fs = require_fs();
    var getHomedir = require_homedir();
    var path3 = require_path();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path3.join(homedir, ".node_modules"),
        path3.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
      readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path3.join(dirs[i], x);
      }
      return dirs;
    };
    module.exports = function resolve27(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path3.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path3.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2)
            cb(err2);
          else
            init2(realStart);
        }
      );
      var res;
      function init2(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path3.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n, pkg) {
            if (err2)
              cb(err2);
            else if (n) {
              return maybeRealpath(realpath, n, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path3.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path3.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load(
                  [""].concat(extensions.slice()),
                  path3.resolve(dir, r),
                  pkg
                );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path3.dirname(dir), cb2);
          var pkgfile = path3.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path3.dirname(dir), cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path3.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path3.join(x2, "index"), fpkg, cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package “" + pkg.name + "” `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path3.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path3.join(x2, "index"), pkg2, cb2);
                  var dir = path3.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n)
                      return cb2(null, n, pkg3);
                    loadAsFile(path3.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path3.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path3.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2)
            return cb2(err2);
          if (n)
            return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/core.js"(exports, module) {
    "use strict";
    var isCoreModule = require_is_core_module();
    var data = require_core2();
    var core2 = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core2[mod] = isCoreModule(mod);
      }
    }
    var mod;
    module.exports = core2;
  }
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/is-core.js"(exports, module) {
    var isCoreModule = require_is_core_module();
    module.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/sync.js"(exports, module) {
    var isCore = require_is_core_module();
    var fs = require_fs();
    var path3 = require_path();
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path3.join(homedir, ".node_modules"),
        path3.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path3.join(dirs[i], x);
      }
      return dirs;
    };
    module.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path3.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path3.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path3.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n)
          return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path3.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path3.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path3.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path3.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path3.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir
          );
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path3.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x2
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package “" + pkg.name + "” `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path3.resolve(x2, pkg.main));
              if (m2)
                return m2;
              var n2 = loadAsDirectorySync(path3.resolve(x2, pkg.main));
              if (n2)
                return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path3.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path3.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2)
              return n2;
          }
        }
      }
    };
  }
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/index.js"(exports, module) {
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module.exports = async;
  }
});

// browser-external:module
var require_module = __commonJS({
  "browser-external:module"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "module" has been externalized for browser compatibility. Cannot access "module.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/resolve-from@4.0.0/node_modules/resolve-from/index.js
var require_resolve_from = __commonJS({
  "node_modules/.pnpm/resolve-from@4.0.0/node_modules/resolve-from/index.js"(exports, module) {
    "use strict";
    var path3 = require_path();
    var Module = require_module();
    var fs = require_fs();
    var resolveFrom = (fromDir, moduleId, silent) => {
      if (typeof fromDir !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDir}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDir = fs.realpathSync(fromDir);
      } catch (err) {
        if (err.code === "ENOENT") {
          fromDir = path3.resolve(fromDir);
        } else if (silent) {
          return null;
        } else {
          throw err;
        }
      }
      const fromFile = path3.join(fromDir, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDir)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (err) {
          return null;
        }
      }
      return resolveFileName();
    };
    module.exports = (fromDir, moduleId) => resolveFrom(fromDir, moduleId);
    module.exports.silent = (fromDir, moduleId) => resolveFrom(fromDir, moduleId, true);
  }
});

// node_modules/.pnpm/callsites@3.1.0/node_modules/callsites/index.js
var require_callsites = __commonJS({
  "node_modules/.pnpm/callsites@3.1.0/node_modules/callsites/index.js"(exports, module) {
    "use strict";
    var callsites = () => {
      const _prepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = (_, stack2) => stack2;
      const stack = new Error().stack.slice(1);
      Error.prepareStackTrace = _prepareStackTrace;
      return stack;
    };
    module.exports = callsites;
    module.exports.default = callsites;
  }
});

// node_modules/.pnpm/parent-module@1.0.1/node_modules/parent-module/index.js
var require_parent_module = __commonJS({
  "node_modules/.pnpm/parent-module@1.0.1/node_modules/parent-module/index.js"(exports, module) {
    "use strict";
    var callsites = require_callsites();
    module.exports = (filepath) => {
      const stacks = callsites();
      if (!filepath) {
        return stacks[2].getFileName();
      }
      let seenVal = false;
      stacks.shift();
      for (const stack of stacks) {
        const parentFilepath = stack.getFileName();
        if (typeof parentFilepath !== "string") {
          continue;
        }
        if (parentFilepath === filepath) {
          seenVal = true;
          continue;
        }
        if (parentFilepath === "module.js") {
          continue;
        }
        if (seenVal && parentFilepath !== filepath) {
          return parentFilepath;
        }
      }
    };
  }
});

// node_modules/.pnpm/import-fresh@3.3.0/node_modules/import-fresh/index.js
var require_import_fresh = __commonJS({
  "node_modules/.pnpm/import-fresh@3.3.0/node_modules/import-fresh/index.js"(exports, module) {
    "use strict";
    var path3 = require_path();
    var resolveFrom = require_resolve_from();
    var parentModule = require_parent_module();
    module.exports = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError("Expected a string");
      }
      const parentPath = parentModule(__filename);
      const cwd = parentPath ? path3.dirname(parentPath) : __dirname;
      const filePath = resolveFrom(cwd, moduleId);
      const oldModule = __require.cache[filePath];
      if (oldModule && oldModule.parent) {
        let i = oldModule.parent.children.length;
        while (i--) {
          if (oldModule.parent.children[i].id === filePath) {
            oldModule.parent.children.splice(i, 1);
          }
        }
      }
      delete __require.cache[filePath];
      const parent = __require.cache[parentPath];
      return parent === void 0 ? __require(filePath) : parent.require(filePath);
    };
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/is-arrayish@0.2.1/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/.pnpm/is-arrayish@0.2.1/node_modules/is-arrayish/index.js"(exports, module) {
    "use strict";
    module.exports = function isArrayish(obj) {
      if (!obj) {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
    };
  }
});

// node_modules/.pnpm/error-ex@1.3.2/node_modules/error-ex/index.js
var require_error_ex = __commonJS({
  "node_modules/.pnpm/error-ex@1.3.2/node_modules/error-ex/index.js"(exports, module) {
    "use strict";
    var util = require_util();
    var isArrayish = require_is_arrayish();
    var errorEx = function errorEx2(name, properties) {
      if (!name || name.constructor !== String) {
        properties = name || {};
        name = Error.name;
      }
      var errorExError = function ErrorEXError(message) {
        if (!this) {
          return new ErrorEXError(message);
        }
        message = message instanceof Error ? message.message : message || this.message;
        Error.call(this, message);
        Error.captureStackTrace(this, errorExError);
        this.name = name;
        Object.defineProperty(this, "message", {
          configurable: true,
          enumerable: false,
          get: function() {
            var newMessage = message.split(/\r?\n/g);
            for (var key in properties) {
              if (!properties.hasOwnProperty(key)) {
                continue;
              }
              var modifier = properties[key];
              if ("message" in modifier) {
                newMessage = modifier.message(this[key], newMessage) || newMessage;
                if (!isArrayish(newMessage)) {
                  newMessage = [newMessage];
                }
              }
            }
            return newMessage.join("\n");
          },
          set: function(v) {
            message = v;
          }
        });
        var overwrittenStack = null;
        var stackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
        var stackGetter = stackDescriptor.get;
        var stackValue = stackDescriptor.value;
        delete stackDescriptor.value;
        delete stackDescriptor.writable;
        stackDescriptor.set = function(newstack) {
          overwrittenStack = newstack;
        };
        stackDescriptor.get = function() {
          var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g);
          if (!overwrittenStack) {
            stack[0] = this.name + ": " + this.message;
          }
          var lineCount = 1;
          for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
              continue;
            }
            var modifier = properties[key];
            if ("line" in modifier) {
              var line = modifier.line(this[key]);
              if (line) {
                stack.splice(lineCount++, 0, "    " + line);
              }
            }
            if ("stack" in modifier) {
              modifier.stack(this[key], stack);
            }
          }
          return stack.join("\n");
        };
        Object.defineProperty(this, "stack", stackDescriptor);
      };
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(errorExError.prototype, Error.prototype);
        Object.setPrototypeOf(errorExError, Error);
      } else {
        util.inherits(errorExError, Error);
      }
      return errorExError;
    };
    errorEx.append = function(str, def) {
      return {
        message: function(v, message) {
          v = v || def;
          if (v) {
            message[0] += " " + str.replace("%s", v.toString());
          }
          return message;
        }
      };
    };
    errorEx.line = function(str, def) {
      return {
        line: function(v) {
          v = v || def;
          if (v) {
            return str.replace("%s", v.toString());
          }
          return null;
        }
      };
    };
    module.exports = errorEx;
  }
});

// node_modules/.pnpm/json-parse-even-better-errors@2.3.1/node_modules/json-parse-even-better-errors/index.js
var require_json_parse_even_better_errors = __commonJS({
  "node_modules/.pnpm/json-parse-even-better-errors@2.3.1/node_modules/json-parse-even-better-errors/index.js"(exports, module) {
    "use strict";
    var hexify = (char) => {
      const h = char.charCodeAt(0).toString(16).toUpperCase();
      return "0x" + (h.length % 2 ? "0" : "") + h;
    };
    var parseError = (e, txt, context) => {
      if (!txt) {
        return {
          message: e.message + " while parsing empty string",
          position: 0
        };
      }
      const badToken = e.message.match(/^Unexpected token (.) .*position\s+(\d+)/i);
      const errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
      const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${hexify(badToken[1])})`) : e.message;
      if (errIdx !== null && errIdx !== void 0) {
        const start = errIdx <= context ? 0 : errIdx - context;
        const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
        const slice3 = (start === 0 ? "" : "...") + txt.slice(start, end) + (end === txt.length ? "" : "...");
        const near = txt === slice3 ? "" : "near ";
        return {
          message: msg + ` while parsing ${near}${JSON.stringify(slice3)}`,
          position: errIdx
        };
      } else {
        return {
          message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,
          position: 0
        };
      }
    };
    var JSONParseError = class extends SyntaxError {
      constructor(er, txt, context, caller) {
        context = context || 20;
        const metadata = parseError(er, txt, context);
        super(metadata.message);
        Object.assign(this, metadata);
        this.code = "EJSONPARSE";
        this.systemError = er;
        Error.captureStackTrace(this, caller || this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
      set name(n) {
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    var kIndent = Symbol.for("indent");
    var kNewline = Symbol.for("newline");
    var formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/;
    var emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;
    var parseJson = (txt, reviver, context) => {
      const parseText = stripBOM(txt);
      context = context || 20;
      try {
        const [, newline = "\n", indent = "  "] = parseText.match(emptyRE) || parseText.match(formatRE) || [, "", ""];
        const result = JSON.parse(parseText, reviver);
        if (result && typeof result === "object") {
          result[kNewline] = newline;
          result[kIndent] = indent;
        }
        return result;
      } catch (e) {
        if (typeof txt !== "string" && !Buffer.isBuffer(txt)) {
          const isEmptyArray = Array.isArray(txt) && txt.length === 0;
          throw Object.assign(new TypeError(
            `Cannot parse ${isEmptyArray ? "an empty array" : String(txt)}`
          ), {
            code: "EJSONPARSE",
            systemError: e
          });
        }
        throw new JSONParseError(e, parseText, context, parseJson);
      }
    };
    var stripBOM = (txt) => String(txt).replace(/^\uFEFF/, "");
    module.exports = parseJson;
    parseJson.JSONParseError = JSONParseError;
    parseJson.noExceptions = (txt, reviver) => {
      try {
        return JSON.parse(stripBOM(txt), reviver);
      } catch (e) {
      }
    };
  }
});

// node_modules/.pnpm/lines-and-columns@1.2.4/node_modules/lines-and-columns/build/index.js
var require_build = __commonJS({
  "node_modules/.pnpm/lines-and-columns@1.2.4/node_modules/lines-and-columns/build/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.LinesAndColumns = void 0;
    var LF = "\n";
    var CR = "\r";
    var LinesAndColumns = (
      /** @class */
      function() {
        function LinesAndColumns2(string2) {
          this.string = string2;
          var offsets = [0];
          for (var offset = 0; offset < string2.length; ) {
            switch (string2[offset]) {
              case LF:
                offset += LF.length;
                offsets.push(offset);
                break;
              case CR:
                offset += CR.length;
                if (string2[offset] === LF) {
                  offset += LF.length;
                }
                offsets.push(offset);
                break;
              default:
                offset++;
                break;
            }
          }
          this.offsets = offsets;
        }
        LinesAndColumns2.prototype.locationForIndex = function(index) {
          if (index < 0 || index > this.string.length) {
            return null;
          }
          var line = 0;
          var offsets = this.offsets;
          while (offsets[line + 1] <= index) {
            line++;
          }
          var column = index - offsets[line];
          return { line, column };
        };
        LinesAndColumns2.prototype.indexForLocation = function(location) {
          var line = location.line, column = location.column;
          if (line < 0 || line >= this.offsets.length) {
            return null;
          }
          if (column < 0 || column > this.lengthOfLine(line)) {
            return null;
          }
          return this.offsets[line] + column;
        };
        LinesAndColumns2.prototype.lengthOfLine = function(line) {
          var offset = this.offsets[line];
          var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
          return nextOffset - offset;
        };
        return LinesAndColumns2;
      }()
    );
    exports.LinesAndColumns = LinesAndColumns;
    exports["default"] = LinesAndColumns;
  }
});

// node_modules/.pnpm/js-tokens@4.0.0/node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/.pnpm/js-tokens@4.0.0/node_modules/js-tokens/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports.matchToToken = function(match3) {
      var token = { type: "invalid", value: match3[0], closed: void 0 };
      if (match3[1])
        token.type = "string", token.closed = !!(match3[3] || match3[4]);
      else if (match3[5])
        token.type = "comment";
      else if (match3[6])
        token.type = "comment", token.closed = !!match3[7];
      else if (match3[8])
        token.type = "regex";
      else if (match3[9])
        token.type = "number";
      else if (match3[10])
        token.type = "name";
      else if (match3[11])
        token.type = "punctuator";
      else if (match3[12])
        token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/.pnpm/@babel+helper-validator-identifier@7.22.20/node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/.pnpm/@babel+helper-validator-identifier@7.22.20/node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIdentifierChar = isIdentifierChar;
    exports.isIdentifierName = isIdentifierName;
    exports.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
    var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set4) {
      let pos = 65536;
      for (let i = 0, length4 = set4.length; i < length4; i += 2) {
        pos += set4[i];
        if (pos > code)
          return false;
        pos += set4[i + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/.pnpm/@babel+helper-validator-identifier@7.22.20/node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/.pnpm/@babel+helper-validator-identifier@7.22.20/node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isKeyword = isKeyword;
    exports.isReservedWord = isReservedWord;
    exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports.isStrictBindReservedWord = isStrictBindReservedWord;
    exports.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// node_modules/.pnpm/@babel+helper-validator-identifier@7.22.20/node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/@babel+helper-validator-identifier@7.22.20/node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/.pnpm/escape-string-regexp@1.0.5/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/.pnpm/escape-string-regexp@1.0.5/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/.pnpm/color-name@1.1.3/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/.pnpm/color-name@1.1.3/node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min3 = Math.min(r, g, b);
      var max3 = Math.max(r, g, b);
      var delta = max3 - min3;
      var h;
      var s;
      var l;
      if (max3 === min3) {
        h = 0;
      } else if (r === max3) {
        h = (g - b) / delta;
      } else if (g === max3) {
        h = 2 + (b - r) / delta;
      } else if (b === max3) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min3 + max3) / 2;
      if (max3 === min3) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max3 + min3);
      } else {
        s = delta / (2 - max3 - min3);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value2 = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value2);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value2 = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value2 = Math.round(value2 / 50);
      if (value2 === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value2 === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert.hex.rgb = function(args) {
      var match3 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match3) {
        return [0, 0, 0];
      }
      var colorString = match3[0];
      if (match3[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max3 = Math.max(Math.max(r, g), b);
      var min3 = Math.min(Math.min(r, g), b);
      var chroma = max3 - min3;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min3 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max3 === r) {
        hue = (g - b) / chroma % 6;
      } else if (max3 === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path3 = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path3.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path3;
      return fn;
    }
    module.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/.pnpm/ansi-styles@3.2.1/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/.pnpm/ansi-styles@3.2.1/node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    module.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/.pnpm/chalk@2.4.2/node_modules/chalk/templates.js
var require_templates = __commonJS({
  "node_modules/.pnpm/chalk@2.4.2/node_modules/chalk/templates.js"(exports, module) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/.pnpm/chalk@2.4.2/node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/.pnpm/chalk@2.4.2/node_modules/chalk/index.js"(exports, module) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_browser().stdout;
    var template = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self2 = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self2.level;
        },
        set(level) {
          self2.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self2.enabled;
        },
        set(enabled) {
          self2.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module.exports = Chalk();
    module.exports.supportsColor = stdoutColor;
    module.exports.default = module.exports;
  }
});

// node_modules/.pnpm/@babel+highlight@7.22.20/node_modules/@babel/highlight/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.pnpm/@babel+highlight@7.22.20/node_modules/@babel/highlight/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = highlight;
    exports.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens();
    var _helperValidatorIdentifier = require_lib();
    var _chalk = _interopRequireWildcard(require_chalk(), true);
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsxIdentifier: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text) {
        let match3;
        while (match3 = _jsTokens.default.exec(text)) {
          const token = _jsTokens.matchToToken(match3);
          yield {
            type: getTokenType(token, match3.index, text),
            value: token.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (const {
        type: type3,
        value: value2
      } of tokenize(text)) {
        const colorize = defs[type3];
        if (colorize) {
          highlighted += value2.split(NEWLINE).map((str) => colorize(str)).join("\n");
        } else {
          highlighted += value2;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return _chalk.default.level > 0 || options.forceColor;
    }
    var chalkWithForcedColor = void 0;
    function getChalk(forceColor) {
      if (forceColor) {
        var _chalkWithForcedColor;
        (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new _chalk.default.constructor({
          enabled: true,
          level: 1
        });
        return chalkWithForcedColor;
      }
      return _chalk.default;
    }
    {
      exports.getChalk = (options) => getChalk(options.forceColor);
    }
    function highlight(code, options = {}) {
      if (code !== "" && shouldHighlight(options)) {
        const defs = getDefs(getChalk(options.forceColor));
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
  }
});

// node_modules/.pnpm/@babel+code-frame@7.22.13/node_modules/@babel/code-frame/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/.pnpm/@babel+code-frame@7.22.13/node_modules/@babel/code-frame/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codeFrameColumns = codeFrameColumns;
    exports.default = _default;
    var _highlight = require_lib2();
    var _chalk = _interopRequireWildcard(require_chalk(), true);
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var chalkWithForcedColor = void 0;
    function getChalk(forceColor) {
      if (forceColor) {
        var _chalkWithForcedColor;
        (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new _chalk.default.constructor({
          enabled: true,
          level: 1
        });
        return chalkWithForcedColor;
      }
      return _chalk.default;
    }
    var deprecationWarningShown = false;
    function getDefs(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
      const chalk = getChalk(opts.forceColor);
      const defs = getDefs(chalk);
      const maybeHighlight = (chalkFn, string2) => {
        return highlighted ? chalkFn(string2) : string2;
      };
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }
    function _default(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  }
});

// node_modules/.pnpm/parse-json@5.2.0/node_modules/parse-json/index.js
var require_parse_json = __commonJS({
  "node_modules/.pnpm/parse-json@5.2.0/node_modules/parse-json/index.js"(exports, module) {
    "use strict";
    var errorEx = require_error_ex();
    var fallback = require_json_parse_even_better_errors();
    var { default: LinesAndColumns } = require_build();
    var { codeFrameColumns } = require_lib3();
    var JSONError = errorEx("JSONError", {
      fileName: errorEx.append("in %s"),
      codeFrame: errorEx.append("\n\n%s\n")
    });
    var parseJson = (string2, reviver, filename) => {
      if (typeof reviver === "string") {
        filename = reviver;
        reviver = null;
      }
      try {
        try {
          return JSON.parse(string2, reviver);
        } catch (error) {
          fallback(string2, reviver);
          throw error;
        }
      } catch (error) {
        error.message = error.message.replace(/\n/g, "");
        const indexMatch = error.message.match(/in JSON at position (\d+) while parsing/);
        const jsonError = new JSONError(error);
        if (filename) {
          jsonError.fileName = filename;
        }
        if (indexMatch && indexMatch.length > 0) {
          const lines = new LinesAndColumns(string2);
          const index = Number(indexMatch[1]);
          const location = lines.locationForIndex(index);
          const codeFrame = codeFrameColumns(
            string2,
            { start: { line: location.line + 1, column: location.column + 1 } },
            { highlightCode: true }
          );
          jsonError.codeFrame = codeFrame;
        }
        throw jsonError;
      }
    };
    parseJson.JSONError = JSONError;
    module.exports = parseJson;
  }
});

// node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/PlainValue-b8036b75.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o3) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf(o3);
}
function _setPrototypeOf(o3, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o4, p2) {
    o4.__proto__ = p2;
    return o4;
  };
  return _setPrototypeOf(o3, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call3) {
  if (call3 && (typeof call3 === "object" || typeof call3 === "function")) {
    return call3;
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target2, property2, receiver2) {
      var base = _superPropBase(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get(target, property, receiver || target);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray(o3, minLen);
  var n = Object.prototype.toString.call(o3).slice(8, -1);
  if (n === "Object" && o3.constructor)
    n = o3.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o3);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o3, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper(o3, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o3[Symbol.iterator] == null) {
    if (Array.isArray(o3) || (it = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
      if (it)
        o3 = it;
      var i = 0;
      var F2 = function() {
      };
      return {
        s: F2,
        n: function() {
          if (i >= o3.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o3[i++]
          };
        },
        e: function(e) {
          throw e;
        },
        f: F2
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = o3[Symbol.iterator]();
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e) {
      didErr = true;
      err = e;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function findLineStarts(src) {
  var ls = [0];
  var offset = src.indexOf("\n");
  while (offset !== -1) {
    offset += 1;
    ls.push(offset);
    offset = src.indexOf("\n", offset);
  }
  return ls;
}
function getSrcInfo(cst) {
  var lineStarts, src;
  if (typeof cst === "string") {
    lineStarts = findLineStarts(cst);
    src = cst;
  } else {
    if (Array.isArray(cst))
      cst = cst[0];
    if (cst && cst.context) {
      if (!cst.lineStarts)
        cst.lineStarts = findLineStarts(cst.context.src);
      lineStarts = cst.lineStarts;
      src = cst.context.src;
    }
  }
  return {
    lineStarts,
    src
  };
}
function getLinePos(offset, cst) {
  if (typeof offset !== "number" || offset < 0)
    return null;
  var _getSrcInfo = getSrcInfo(cst), lineStarts = _getSrcInfo.lineStarts, src = _getSrcInfo.src;
  if (!lineStarts || !src || offset > src.length)
    return null;
  for (var i = 0; i < lineStarts.length; ++i) {
    var start = lineStarts[i];
    if (offset < start) {
      return {
        line: i,
        col: offset - lineStarts[i - 1] + 1
      };
    }
    if (offset === start)
      return {
        line: i + 1,
        col: 1
      };
  }
  var line = lineStarts.length;
  return {
    line,
    col: offset - lineStarts[line - 1] + 1
  };
}
function getLine(line, cst) {
  var _getSrcInfo2 = getSrcInfo(cst), lineStarts = _getSrcInfo2.lineStarts, src = _getSrcInfo2.src;
  if (!lineStarts || !(line >= 1) || line > lineStarts.length)
    return null;
  var start = lineStarts[line - 1];
  var end = lineStarts[line];
  while (end && end > start && src[end - 1] === "\n") {
    --end;
  }
  return src.slice(start, end);
}
function getPrettyContext(_ref, cst) {
  var start = _ref.start, end = _ref.end;
  var maxWidth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 80;
  var src = getLine(start.line, cst);
  if (!src)
    return null;
  var col = start.col;
  if (src.length > maxWidth) {
    if (col <= maxWidth - 10) {
      src = src.substr(0, maxWidth - 1) + "…";
    } else {
      var halfWidth = Math.round(maxWidth / 2);
      if (src.length > col + halfWidth)
        src = src.substr(0, col + halfWidth - 1) + "…";
      col -= src.length - maxWidth;
      src = "…" + src.substr(1 - maxWidth);
    }
  }
  var errLen = 1;
  var errEnd = "";
  if (end) {
    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
      errLen = end.col - start.col;
    } else {
      errLen = Math.min(src.length + 1, maxWidth) - col;
      errEnd = "…";
    }
  }
  var offset = col > 1 ? " ".repeat(col - 1) : "";
  var err = "^".repeat(errLen);
  return "".concat(src, "\n").concat(offset).concat(err).concat(errEnd);
}
var Char, Type, defaultTagPrefix, defaultTags, Range, Node, YAMLError, YAMLReferenceError, YAMLSemanticError, YAMLSyntaxError, YAMLWarning, PlainValue;
var init_PlainValue_b8036b75 = __esm({
  "node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/PlainValue-b8036b75.js"() {
    Char = {
      ANCHOR: "&",
      COMMENT: "#",
      TAG: "!",
      DIRECTIVES_END: "-",
      DOCUMENT_END: "."
    };
    Type = {
      ALIAS: "ALIAS",
      BLANK_LINE: "BLANK_LINE",
      BLOCK_FOLDED: "BLOCK_FOLDED",
      BLOCK_LITERAL: "BLOCK_LITERAL",
      COMMENT: "COMMENT",
      DIRECTIVE: "DIRECTIVE",
      DOCUMENT: "DOCUMENT",
      FLOW_MAP: "FLOW_MAP",
      FLOW_SEQ: "FLOW_SEQ",
      MAP: "MAP",
      MAP_KEY: "MAP_KEY",
      MAP_VALUE: "MAP_VALUE",
      PLAIN: "PLAIN",
      QUOTE_DOUBLE: "QUOTE_DOUBLE",
      QUOTE_SINGLE: "QUOTE_SINGLE",
      SEQ: "SEQ",
      SEQ_ITEM: "SEQ_ITEM"
    };
    defaultTagPrefix = "tag:yaml.org,2002:";
    defaultTags = {
      MAP: "tag:yaml.org,2002:map",
      SEQ: "tag:yaml.org,2002:seq",
      STR: "tag:yaml.org,2002:str"
    };
    Range = function() {
      function Range2(start, end) {
        _classCallCheck(this, Range2);
        this.start = start;
        this.end = end || start;
      }
      _createClass(Range2, [{
        key: "isEmpty",
        value: function isEmpty3() {
          return typeof this.start !== "number" || !this.end || this.end <= this.start;
        }
        /**
         * Set `origStart` and `origEnd` to point to the original source range for
         * this node, which may differ due to dropped CR characters.
         *
         * @param {number[]} cr - Positions of dropped CR characters
         * @param {number} offset - Starting index of `cr` from the last call
         * @returns {number} - The next offset, matching the one found for `origStart`
         */
      }, {
        key: "setOrigRange",
        value: function setOrigRange(cr, offset) {
          var start = this.start, end = this.end;
          if (cr.length === 0 || end <= cr[0]) {
            this.origStart = start;
            this.origEnd = end;
            return offset;
          }
          var i = offset;
          while (i < cr.length) {
            if (cr[i] > start)
              break;
            else
              ++i;
          }
          this.origStart = start + i;
          var nextOffset = i;
          while (i < cr.length) {
            if (cr[i] >= end)
              break;
            else
              ++i;
          }
          this.origEnd = end + i;
          return nextOffset;
        }
      }], [{
        key: "copy",
        value: function copy(orig) {
          return new Range2(orig.start, orig.end);
        }
      }]);
      return Range2;
    }();
    Node = function() {
      function Node4(type3, props3, context) {
        _classCallCheck(this, Node4);
        Object.defineProperty(this, "context", {
          value: context || null,
          writable: true
        });
        this.error = null;
        this.range = null;
        this.valueRange = null;
        this.props = props3 || [];
        this.type = type3;
        this.value = null;
      }
      _createClass(Node4, [{
        key: "getPropValue",
        value: function getPropValue(idx, key, skipKey) {
          if (!this.context)
            return null;
          var src = this.context.src;
          var prop3 = this.props[idx];
          return prop3 && src[prop3.start] === key ? src.slice(prop3.start + (skipKey ? 1 : 0), prop3.end) : null;
        }
      }, {
        key: "anchor",
        get: function get() {
          for (var i = 0; i < this.props.length; ++i) {
            var anchor = this.getPropValue(i, Char.ANCHOR, true);
            if (anchor != null)
              return anchor;
          }
          return null;
        }
      }, {
        key: "comment",
        get: function get() {
          var comments = [];
          for (var i = 0; i < this.props.length; ++i) {
            var comment = this.getPropValue(i, Char.COMMENT, true);
            if (comment != null)
              comments.push(comment);
          }
          return comments.length > 0 ? comments.join("\n") : null;
        }
      }, {
        key: "commentHasRequiredWhitespace",
        value: function commentHasRequiredWhitespace(start) {
          var src = this.context.src;
          if (this.header && start === this.header.end)
            return false;
          if (!this.valueRange)
            return false;
          var end = this.valueRange.end;
          return start !== end || Node4.atBlank(src, end - 1);
        }
      }, {
        key: "hasComment",
        get: function get() {
          if (this.context) {
            var src = this.context.src;
            for (var i = 0; i < this.props.length; ++i) {
              if (src[this.props[i].start] === Char.COMMENT)
                return true;
            }
          }
          return false;
        }
      }, {
        key: "hasProps",
        get: function get() {
          if (this.context) {
            var src = this.context.src;
            for (var i = 0; i < this.props.length; ++i) {
              if (src[this.props[i].start] !== Char.COMMENT)
                return true;
            }
          }
          return false;
        }
      }, {
        key: "includesTrailingLines",
        get: function get() {
          return false;
        }
      }, {
        key: "jsonLike",
        get: function get() {
          var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
          return jsonLikeTypes.indexOf(this.type) !== -1;
        }
      }, {
        key: "rangeAsLinePos",
        get: function get() {
          if (!this.range || !this.context)
            return void 0;
          var start = getLinePos(this.range.start, this.context.root);
          if (!start)
            return void 0;
          var end = getLinePos(this.range.end, this.context.root);
          return {
            start,
            end
          };
        }
      }, {
        key: "rawValue",
        get: function get() {
          if (!this.valueRange || !this.context)
            return null;
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          return this.context.src.slice(start, end);
        }
      }, {
        key: "tag",
        get: function get() {
          for (var i = 0; i < this.props.length; ++i) {
            var tag = this.getPropValue(i, Char.TAG, false);
            if (tag != null) {
              if (tag[1] === "<") {
                return {
                  verbatim: tag.slice(2, -1)
                };
              } else {
                var _tag$match = tag.match(/^(.*!)([^!]*)$/), _tag$match2 = _slicedToArray(_tag$match, 3);
                _tag$match2[0];
                var handle = _tag$match2[1], suffix = _tag$match2[2];
                return {
                  handle,
                  suffix
                };
              }
            }
          }
          return null;
        }
      }, {
        key: "valueRangeContainsNewline",
        get: function get() {
          if (!this.valueRange || !this.context)
            return false;
          var _this$valueRange2 = this.valueRange, start = _this$valueRange2.start, end = _this$valueRange2.end;
          var src = this.context.src;
          for (var i = start; i < end; ++i) {
            if (src[i] === "\n")
              return true;
          }
          return false;
        }
      }, {
        key: "parseComment",
        value: function parseComment(start) {
          var src = this.context.src;
          if (src[start] === Char.COMMENT) {
            var end = Node4.endOfLine(src, start + 1);
            var commentRange = new Range(start, end);
            this.props.push(commentRange);
            return end;
          }
          return start;
        }
        /**
         * Populates the `origStart` and `origEnd` values of all ranges for this
         * node. Extended by child classes to handle descendant nodes.
         *
         * @param {number[]} cr - Positions of dropped CR characters
         * @param {number} offset - Starting index of `cr` from the last call
         * @returns {number} - The next offset, matching the one found for `origStart`
         */
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          if (this.range)
            offset = this.range.setOrigRange(cr, offset);
          if (this.valueRange)
            this.valueRange.setOrigRange(cr, offset);
          this.props.forEach(function(prop3) {
            return prop3.setOrigRange(cr, offset);
          });
          return offset;
        }
      }, {
        key: "toString",
        value: function toString4() {
          var src = this.context.src, range3 = this.range, value2 = this.value;
          if (value2 != null)
            return value2;
          var str = src.slice(range3.start, range3.end);
          return Node4.addStringTerminator(src, range3.end, str);
        }
      }], [{
        key: "addStringTerminator",
        value: function addStringTerminator(src, offset, str) {
          if (str[str.length - 1] === "\n")
            return str;
          var next = Node4.endOfWhiteSpace(src, offset);
          return next >= src.length || src[next] === "\n" ? str + "\n" : str;
        }
        // ^(---|...)
      }, {
        key: "atDocumentBoundary",
        value: function atDocumentBoundary(src, offset, sep) {
          var ch0 = src[offset];
          if (!ch0)
            return true;
          var prev = src[offset - 1];
          if (prev && prev !== "\n")
            return false;
          if (sep) {
            if (ch0 !== sep)
              return false;
          } else {
            if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END)
              return false;
          }
          var ch1 = src[offset + 1];
          var ch2 = src[offset + 2];
          if (ch1 !== ch0 || ch2 !== ch0)
            return false;
          var ch3 = src[offset + 3];
          return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
        }
      }, {
        key: "endOfIdentifier",
        value: function endOfIdentifier(src, offset) {
          var ch = src[offset];
          var isVerbatim = ch === "<";
          var notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
          while (ch && notOk.indexOf(ch) === -1) {
            ch = src[offset += 1];
          }
          if (isVerbatim && ch === ">")
            offset += 1;
          return offset;
        }
      }, {
        key: "endOfIndent",
        value: function endOfIndent(src, offset) {
          var ch = src[offset];
          while (ch === " ") {
            ch = src[offset += 1];
          }
          return offset;
        }
      }, {
        key: "endOfLine",
        value: function endOfLine(src, offset) {
          var ch = src[offset];
          while (ch && ch !== "\n") {
            ch = src[offset += 1];
          }
          return offset;
        }
      }, {
        key: "endOfWhiteSpace",
        value: function endOfWhiteSpace(src, offset) {
          var ch = src[offset];
          while (ch === "	" || ch === " ") {
            ch = src[offset += 1];
          }
          return offset;
        }
      }, {
        key: "startOfLine",
        value: function startOfLine(src, offset) {
          var ch = src[offset - 1];
          if (ch === "\n")
            return offset;
          while (ch && ch !== "\n") {
            ch = src[offset -= 1];
          }
          return offset + 1;
        }
        /**
         * End of indentation, or null if the line's indent level is not more
         * than `indent`
         *
         * @param {string} src
         * @param {number} indent
         * @param {number} lineStart
         * @returns {?number}
         */
      }, {
        key: "endOfBlockIndent",
        value: function endOfBlockIndent(src, indent, lineStart) {
          var inEnd = Node4.endOfIndent(src, lineStart);
          if (inEnd > lineStart + indent) {
            return inEnd;
          } else {
            var wsEnd = Node4.endOfWhiteSpace(src, inEnd);
            var ch = src[wsEnd];
            if (!ch || ch === "\n")
              return wsEnd;
          }
          return null;
        }
      }, {
        key: "atBlank",
        value: function atBlank(src, offset, endAsBlank) {
          var ch = src[offset];
          return ch === "\n" || ch === "	" || ch === " " || endAsBlank && !ch;
        }
      }, {
        key: "nextNodeIsIndented",
        value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
          if (!ch || indentDiff < 0)
            return false;
          if (indentDiff > 0)
            return true;
          return indicatorAsIndent && ch === "-";
        }
        // should be at line or string end, or at next non-whitespace char
      }, {
        key: "normalizeOffset",
        value: function normalizeOffset(src, offset) {
          var ch = src[offset];
          return !ch ? offset : ch !== "\n" && src[offset - 1] === "\n" ? offset - 1 : Node4.endOfWhiteSpace(src, offset);
        }
        // fold single newline into space, multiple newlines to N - 1 newlines
        // presumes src[offset] === '\n'
      }, {
        key: "foldNewline",
        value: function foldNewline(src, offset, indent) {
          var inCount = 0;
          var error = false;
          var fold = "";
          var ch = src[offset + 1];
          while (ch === " " || ch === "	" || ch === "\n") {
            switch (ch) {
              case "\n":
                inCount = 0;
                offset += 1;
                fold += "\n";
                break;
              case "	":
                if (inCount <= indent)
                  error = true;
                offset = Node4.endOfWhiteSpace(src, offset + 2) - 1;
                break;
              case " ":
                inCount += 1;
                offset += 1;
                break;
            }
            ch = src[offset + 1];
          }
          if (!fold)
            fold = " ";
          if (ch && inCount <= indent)
            error = true;
          return {
            fold,
            offset,
            error
          };
        }
      }]);
      return Node4;
    }();
    YAMLError = function(_Error) {
      _inherits(YAMLError2, _Error);
      var _super = _createSuper(YAMLError2);
      function YAMLError2(name, source, message) {
        var _this;
        _classCallCheck(this, YAMLError2);
        if (!message || !(source instanceof Node))
          throw new Error("Invalid arguments for new ".concat(name));
        _this = _super.call(this);
        _this.name = name;
        _this.message = message;
        _this.source = source;
        return _this;
      }
      _createClass(YAMLError2, [{
        key: "makePretty",
        value: function makePretty() {
          if (!this.source)
            return;
          this.nodeType = this.source.type;
          var cst = this.source.context && this.source.context.root;
          if (typeof this.offset === "number") {
            this.range = new Range(this.offset, this.offset + 1);
            var start = cst && getLinePos(this.offset, cst);
            if (start) {
              var end = {
                line: start.line,
                col: start.col + 1
              };
              this.linePos = {
                start,
                end
              };
            }
            delete this.offset;
          } else {
            this.range = this.source.range;
            this.linePos = this.source.rangeAsLinePos;
          }
          if (this.linePos) {
            var _this$linePos$start = this.linePos.start, line = _this$linePos$start.line, col = _this$linePos$start.col;
            this.message += " at line ".concat(line, ", column ").concat(col);
            var ctx = cst && getPrettyContext(this.linePos, cst);
            if (ctx)
              this.message += ":\n\n".concat(ctx, "\n");
          }
          delete this.source;
        }
      }]);
      return YAMLError2;
    }(_wrapNativeSuper(Error));
    YAMLReferenceError = function(_YAMLError) {
      _inherits(YAMLReferenceError2, _YAMLError);
      var _super2 = _createSuper(YAMLReferenceError2);
      function YAMLReferenceError2(source, message) {
        _classCallCheck(this, YAMLReferenceError2);
        return _super2.call(this, "YAMLReferenceError", source, message);
      }
      return YAMLReferenceError2;
    }(YAMLError);
    YAMLSemanticError = function(_YAMLError2) {
      _inherits(YAMLSemanticError2, _YAMLError2);
      var _super3 = _createSuper(YAMLSemanticError2);
      function YAMLSemanticError2(source, message) {
        _classCallCheck(this, YAMLSemanticError2);
        return _super3.call(this, "YAMLSemanticError", source, message);
      }
      return YAMLSemanticError2;
    }(YAMLError);
    YAMLSyntaxError = function(_YAMLError3) {
      _inherits(YAMLSyntaxError2, _YAMLError3);
      var _super4 = _createSuper(YAMLSyntaxError2);
      function YAMLSyntaxError2(source, message) {
        _classCallCheck(this, YAMLSyntaxError2);
        return _super4.call(this, "YAMLSyntaxError", source, message);
      }
      return YAMLSyntaxError2;
    }(YAMLError);
    YAMLWarning = function(_YAMLError4) {
      _inherits(YAMLWarning2, _YAMLError4);
      var _super5 = _createSuper(YAMLWarning2);
      function YAMLWarning2(source, message) {
        _classCallCheck(this, YAMLWarning2);
        return _super5.call(this, "YAMLWarning", source, message);
      }
      return YAMLWarning2;
    }(YAMLError);
    PlainValue = function(_Node) {
      _inherits(PlainValue2, _Node);
      var _super = _createSuper(PlainValue2);
      function PlainValue2() {
        _classCallCheck(this, PlainValue2);
        return _super.apply(this, arguments);
      }
      _createClass(PlainValue2, [{
        key: "strValue",
        get: function get() {
          if (!this.valueRange || !this.context)
            return null;
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          var src = this.context.src;
          var ch = src[end - 1];
          while (start < end && (ch === "\n" || ch === "	" || ch === " ")) {
            ch = src[--end - 1];
          }
          var str = "";
          for (var i = start; i < end; ++i) {
            var _ch = src[i];
            if (_ch === "\n") {
              var _Node$foldNewline = Node.foldNewline(src, i, -1), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset;
              str += fold;
              i = offset;
            } else if (_ch === " " || _ch === "	") {
              var wsStart = i;
              var next = src[i + 1];
              while (i < end && (next === " " || next === "	")) {
                i += 1;
                next = src[i + 1];
              }
              if (next !== "\n")
                str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;
            } else {
              str += _ch;
            }
          }
          var ch0 = src[start];
          switch (ch0) {
            case "	": {
              var msg = "Plain value cannot start with a tab character";
              var errors = [new YAMLSemanticError(this, msg)];
              return {
                errors,
                str
              };
            }
            case "@":
            case "`": {
              var _msg = "Plain value cannot start with reserved character ".concat(ch0);
              var _errors = [new YAMLSemanticError(this, _msg)];
              return {
                errors: _errors,
                str
              };
            }
            default:
              return str;
          }
        }
      }, {
        key: "parseBlockValue",
        value: function parseBlockValue(start) {
          var _this$context = this.context, indent = _this$context.indent, inFlow = _this$context.inFlow, src = _this$context.src;
          var offset = start;
          var valueEnd = start;
          for (var ch = src[offset]; ch === "\n"; ch = src[offset]) {
            if (Node.atDocumentBoundary(src, offset + 1))
              break;
            var end = Node.endOfBlockIndent(src, indent, offset + 1);
            if (end === null || src[end] === "#")
              break;
            if (src[end] === "\n") {
              offset = end;
            } else {
              valueEnd = PlainValue2.endOfLine(src, end, inFlow);
              offset = valueEnd;
            }
          }
          if (this.valueRange.isEmpty())
            this.valueRange.start = start;
          this.valueRange.end = valueEnd;
          return valueEnd;
        }
        /**
         * Parses a plain value from the source
         *
         * Accepted forms are:
         * ```
         * #comment
         *
         * first line
         *
         * first line #comment
         *
         * first line
         * block
         * lines
         *
         * #comment
         * block
         * lines
         * ```
         * where block lines are empty or have an indent level greater than `indent`.
         *
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this scalar, may be `\n`
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var inFlow = context.inFlow, src = context.src;
          var offset = start;
          var ch = src[offset];
          if (ch && ch !== "#" && ch !== "\n") {
            offset = PlainValue2.endOfLine(src, start, inFlow);
          }
          this.valueRange = new Range(start, offset);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          if (!this.hasComment || this.valueRange.isEmpty()) {
            offset = this.parseBlockValue(offset);
          }
          return offset;
        }
      }], [{
        key: "endOfLine",
        value: function endOfLine(src, start, inFlow) {
          var ch = src[start];
          var offset = start;
          while (ch && ch !== "\n") {
            if (inFlow && (ch === "[" || ch === "]" || ch === "{" || ch === "}" || ch === ","))
              break;
            var next = src[offset + 1];
            if (ch === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ","))
              break;
            if ((ch === " " || ch === "	") && next === "#")
              break;
            offset += 1;
            ch = next;
          }
          return offset;
        }
      }]);
      return PlainValue2;
    }(Node);
  }
});

// node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/parse-cst.js
function grabCollectionEndComments(node) {
  var cnode = node;
  while (cnode instanceof CollectionItem) {
    cnode = cnode.node;
  }
  if (!(cnode instanceof Collection))
    return null;
  var len = cnode.items.length;
  var ci = -1;
  for (var i = len - 1; i >= 0; --i) {
    var n = cnode.items[i];
    if (n.type === Type.COMMENT) {
      var _n$context = n.context, indent = _n$context.indent, lineStart = _n$context.lineStart;
      if (indent > 0 && n.range.start >= lineStart + indent)
        break;
      ci = i;
    } else if (n.type === Type.BLANK_LINE)
      ci = i;
    else
      break;
  }
  if (ci === -1)
    return null;
  var ca = cnode.items.splice(ci, len - ci);
  var prevEnd = ca[0].range.start;
  while (true) {
    cnode.range.end = prevEnd;
    if (cnode.valueRange && cnode.valueRange.end > prevEnd)
      cnode.valueRange.end = prevEnd;
    if (cnode === node)
      break;
    cnode = cnode.context.parent;
  }
  return ca;
}
function createNewNode(type3, props3) {
  switch (type3) {
    case Type.ALIAS:
      return new Alias(type3, props3);
    case Type.BLOCK_FOLDED:
    case Type.BLOCK_LITERAL:
      return new BlockValue(type3, props3);
    case Type.FLOW_MAP:
    case Type.FLOW_SEQ:
      return new FlowCollection(type3, props3);
    case Type.MAP_KEY:
    case Type.MAP_VALUE:
    case Type.SEQ_ITEM:
      return new CollectionItem(type3, props3);
    case Type.COMMENT:
    case Type.PLAIN:
      return new PlainValue(type3, props3);
    case Type.QUOTE_DOUBLE:
      return new QuoteDouble(type3, props3);
    case Type.QUOTE_SINGLE:
      return new QuoteSingle(type3, props3);
    default:
      return null;
  }
}
function parse(src) {
  var cr = [];
  if (src.indexOf("\r") !== -1) {
    src = src.replace(/\r\n?/g, function(match3, offset2) {
      if (match3.length > 1)
        cr.push(offset2);
      return "\n";
    });
  }
  var documents = [];
  var offset = 0;
  do {
    var doc = new Document();
    var context = new ParseContext({
      src
    });
    offset = doc.parse(context, offset);
    documents.push(doc);
  } while (offset < src.length);
  documents.setOrigRanges = function() {
    if (cr.length === 0)
      return false;
    for (var i = 1; i < cr.length; ++i) {
      cr[i] -= i;
    }
    var crOffset = 0;
    for (var _i = 0; _i < documents.length; ++_i) {
      crOffset = documents[_i].setOrigRanges(cr, crOffset);
    }
    cr.splice(0, cr.length);
    return true;
  };
  documents.toString = function() {
    return documents.join("...\n");
  };
  return documents;
}
var BlankLine, CollectionItem, Comment, Collection, Directive, Document, Alias, Chomp, BlockValue, FlowCollection, QuoteDouble, QuoteSingle, ParseContext;
var init_parse_cst = __esm({
  "node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/parse-cst.js"() {
    init_PlainValue_b8036b75();
    BlankLine = function(_Node) {
      _inherits(BlankLine2, _Node);
      var _super = _createSuper(BlankLine2);
      function BlankLine2() {
        _classCallCheck(this, BlankLine2);
        return _super.call(this, Type.BLANK_LINE);
      }
      _createClass(BlankLine2, [{
        key: "includesTrailingLines",
        get: function get() {
          return true;
        }
        /**
         * Parses a blank line from the source
         *
         * @param {ParseContext} context
         * @param {number} start - Index of first \n character
         * @returns {number} - Index of the character after this
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          this.range = new Range(start, start + 1);
          return start + 1;
        }
      }]);
      return BlankLine2;
    }(Node);
    CollectionItem = function(_Node) {
      _inherits(CollectionItem2, _Node);
      var _super = _createSuper(CollectionItem2);
      function CollectionItem2(type3, props3) {
        var _this;
        _classCallCheck(this, CollectionItem2);
        _this = _super.call(this, type3, props3);
        _this.node = null;
        return _this;
      }
      _createClass(CollectionItem2, [{
        key: "includesTrailingLines",
        get: function get() {
          return !!this.node && this.node.includesTrailingLines;
        }
        /**
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var parseNode = context.parseNode, src = context.src;
          var atLineStart = context.atLineStart, lineStart = context.lineStart;
          if (!atLineStart && this.type === Type.SEQ_ITEM)
            this.error = new YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
          var indent = atLineStart ? start - lineStart : context.indent;
          var offset = Node.endOfWhiteSpace(src, start + 1);
          var ch = src[offset];
          var inlineComment = ch === "#";
          var comments = [];
          var blankLine = null;
          while (ch === "\n" || ch === "#") {
            if (ch === "#") {
              var _end = Node.endOfLine(src, offset + 1);
              comments.push(new Range(offset, _end));
              offset = _end;
            } else {
              atLineStart = true;
              lineStart = offset + 1;
              var wsEnd = Node.endOfWhiteSpace(src, lineStart);
              if (src[wsEnd] === "\n" && comments.length === 0) {
                blankLine = new BlankLine();
                lineStart = blankLine.parse({
                  src
                }, lineStart);
              }
              offset = Node.endOfIndent(src, lineStart);
            }
            ch = src[offset];
          }
          if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {
            this.node = parseNode({
              atLineStart,
              inCollection: false,
              indent,
              lineStart,
              parent: this
            }, offset);
          } else if (ch && lineStart > start + 1) {
            offset = lineStart - 1;
          }
          if (this.node) {
            if (blankLine) {
              var items = context.parent.items || context.parent.contents;
              if (items)
                items.push(blankLine);
            }
            if (comments.length)
              Array.prototype.push.apply(this.props, comments);
            offset = this.node.range.end;
          } else {
            if (inlineComment) {
              var c = comments[0];
              this.props.push(c);
              offset = c.end;
            } else {
              offset = Node.endOfLine(src, start + 1);
            }
          }
          var end = this.node ? this.node.valueRange.end : offset;
          this.valueRange = new Range(start, end);
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(CollectionItem2.prototype), "setOrigRanges", this).call(this, cr, offset);
          return this.node ? this.node.setOrigRanges(cr, offset) : offset;
        }
      }, {
        key: "toString",
        value: function toString4() {
          var src = this.context.src, node = this.node, range3 = this.range, value2 = this.value;
          if (value2 != null)
            return value2;
          var str = node ? src.slice(range3.start, node.range.start) + String(node) : src.slice(range3.start, range3.end);
          return Node.addStringTerminator(src, range3.end, str);
        }
      }]);
      return CollectionItem2;
    }(Node);
    Comment = function(_Node) {
      _inherits(Comment2, _Node);
      var _super = _createSuper(Comment2);
      function Comment2() {
        _classCallCheck(this, Comment2);
        return _super.call(this, Type.COMMENT);
      }
      _createClass(Comment2, [{
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var offset = this.parseComment(start);
          this.range = new Range(start, offset);
          return offset;
        }
      }]);
      return Comment2;
    }(Node);
    Collection = function(_Node) {
      _inherits(Collection3, _Node);
      var _super = _createSuper(Collection3);
      function Collection3(firstItem) {
        var _this;
        _classCallCheck(this, Collection3);
        _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);
        for (var i = firstItem.props.length - 1; i >= 0; --i) {
          if (firstItem.props[i].start < firstItem.context.lineStart) {
            _this.props = firstItem.props.slice(0, i + 1);
            firstItem.props = firstItem.props.slice(i + 1);
            var itemRange = firstItem.props[0] || firstItem.valueRange;
            firstItem.range.start = itemRange.start;
            break;
          }
        }
        _this.items = [firstItem];
        var ec = grabCollectionEndComments(firstItem);
        if (ec)
          Array.prototype.push.apply(_this.items, ec);
        return _this;
      }
      _createClass(Collection3, [{
        key: "includesTrailingLines",
        get: function get() {
          return this.items.length > 0;
        }
        /**
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var parseNode = context.parseNode, src = context.src;
          var lineStart = Node.startOfLine(src, start);
          var firstItem = this.items[0];
          firstItem.context.parent = this;
          this.valueRange = Range.copy(firstItem.valueRange);
          var indent = firstItem.range.start - firstItem.context.lineStart;
          var offset = start;
          offset = Node.normalizeOffset(src, offset);
          var ch = src[offset];
          var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;
          var prevIncludesTrailingLines = false;
          while (ch) {
            while (ch === "\n" || ch === "#") {
              if (atLineStart && ch === "\n" && !prevIncludesTrailingLines) {
                var blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                this.valueRange.end = offset;
                if (offset >= src.length) {
                  ch = null;
                  break;
                }
                this.items.push(blankLine);
                offset -= 1;
              } else if (ch === "#") {
                if (offset < lineStart + indent && !Collection3.nextContentHasIndent(src, offset, indent)) {
                  return offset;
                }
                var comment = new Comment();
                offset = comment.parse({
                  indent,
                  lineStart,
                  src
                }, offset);
                this.items.push(comment);
                this.valueRange.end = offset;
                if (offset >= src.length) {
                  ch = null;
                  break;
                }
              }
              lineStart = offset + 1;
              offset = Node.endOfIndent(src, lineStart);
              if (Node.atBlank(src, offset)) {
                var wsEnd = Node.endOfWhiteSpace(src, offset);
                var next = src[wsEnd];
                if (!next || next === "\n" || next === "#") {
                  offset = wsEnd;
                }
              }
              ch = src[offset];
              atLineStart = true;
            }
            if (!ch) {
              break;
            }
            if (offset !== lineStart + indent && (atLineStart || ch !== ":")) {
              if (offset < lineStart + indent) {
                if (lineStart > start)
                  offset = lineStart;
                break;
              } else if (!this.error) {
                var msg = "All collection items must start at the same column";
                this.error = new YAMLSyntaxError(this, msg);
              }
            }
            if (firstItem.type === Type.SEQ_ITEM) {
              if (ch !== "-") {
                if (lineStart > start)
                  offset = lineStart;
                break;
              }
            } else if (ch === "-" && !this.error) {
              var _next = src[offset + 1];
              if (!_next || _next === "\n" || _next === "	" || _next === " ") {
                var _msg = "A collection cannot be both a mapping and a sequence";
                this.error = new YAMLSyntaxError(this, _msg);
              }
            }
            var node = parseNode({
              atLineStart,
              inCollection: true,
              indent,
              lineStart,
              parent: this
            }, offset);
            if (!node)
              return offset;
            this.items.push(node);
            this.valueRange.end = node.valueRange.end;
            offset = Node.normalizeOffset(src, node.range.end);
            ch = src[offset];
            atLineStart = false;
            prevIncludesTrailingLines = node.includesTrailingLines;
            if (ch) {
              var ls = offset - 1;
              var prev = src[ls];
              while (prev === " " || prev === "	") {
                prev = src[--ls];
              }
              if (prev === "\n") {
                lineStart = ls + 1;
                atLineStart = true;
              }
            }
            var ec = grabCollectionEndComments(node);
            if (ec)
              Array.prototype.push.apply(this.items, ec);
          }
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(Collection3.prototype), "setOrigRanges", this).call(this, cr, offset);
          this.items.forEach(function(node) {
            offset = node.setOrigRanges(cr, offset);
          });
          return offset;
        }
      }, {
        key: "toString",
        value: function toString4() {
          var src = this.context.src, items = this.items, range3 = this.range, value2 = this.value;
          if (value2 != null)
            return value2;
          var str = src.slice(range3.start, items[0].range.start) + String(items[0]);
          for (var i = 1; i < items.length; ++i) {
            var item = items[i];
            var _item$context = item.context, atLineStart = _item$context.atLineStart, indent = _item$context.indent;
            if (atLineStart)
              for (var _i = 0; _i < indent; ++_i) {
                str += " ";
              }
            str += String(item);
          }
          return Node.addStringTerminator(src, range3.end, str);
        }
      }], [{
        key: "nextContentHasIndent",
        value: function nextContentHasIndent(src, offset, indent) {
          var lineStart = Node.endOfLine(src, offset) + 1;
          offset = Node.endOfWhiteSpace(src, lineStart);
          var ch = src[offset];
          if (!ch)
            return false;
          if (offset >= lineStart + indent)
            return true;
          if (ch !== "#" && ch !== "\n")
            return false;
          return Collection3.nextContentHasIndent(src, offset, indent);
        }
      }]);
      return Collection3;
    }(Node);
    Directive = function(_Node) {
      _inherits(Directive2, _Node);
      var _super = _createSuper(Directive2);
      function Directive2() {
        var _this;
        _classCallCheck(this, Directive2);
        _this = _super.call(this, Type.DIRECTIVE);
        _this.name = null;
        return _this;
      }
      _createClass(Directive2, [{
        key: "parameters",
        get: function get() {
          var raw = this.rawValue;
          return raw ? raw.trim().split(/[ \t]+/) : [];
        }
      }, {
        key: "parseName",
        value: function parseName(start) {
          var src = this.context.src;
          var offset = start;
          var ch = src[offset];
          while (ch && ch !== "\n" && ch !== "	" && ch !== " ") {
            ch = src[offset += 1];
          }
          this.name = src.slice(start, offset);
          return offset;
        }
      }, {
        key: "parseParameters",
        value: function parseParameters(start) {
          var src = this.context.src;
          var offset = start;
          var ch = src[offset];
          while (ch && ch !== "\n" && ch !== "#") {
            ch = src[offset += 1];
          }
          this.valueRange = new Range(start, offset);
          return offset;
        }
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var offset = this.parseName(start + 1);
          offset = this.parseParameters(offset);
          offset = this.parseComment(offset);
          this.range = new Range(start, offset);
          return offset;
        }
      }]);
      return Directive2;
    }(Node);
    Document = function(_Node) {
      _inherits(Document3, _Node);
      var _super = _createSuper(Document3);
      function Document3() {
        var _this;
        _classCallCheck(this, Document3);
        _this = _super.call(this, Type.DOCUMENT);
        _this.directives = null;
        _this.contents = null;
        _this.directivesEndMarker = null;
        _this.documentEndMarker = null;
        return _this;
      }
      _createClass(Document3, [{
        key: "parseDirectives",
        value: function parseDirectives2(start) {
          var src = this.context.src;
          this.directives = [];
          var atLineStart = true;
          var hasDirectives = false;
          var offset = start;
          while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {
            offset = Document3.startCommentOrEndBlankLine(src, offset);
            switch (src[offset]) {
              case "\n":
                if (atLineStart) {
                  var blankLine = new BlankLine();
                  offset = blankLine.parse({
                    src
                  }, offset);
                  if (offset < src.length) {
                    this.directives.push(blankLine);
                  }
                } else {
                  offset += 1;
                  atLineStart = true;
                }
                break;
              case "#":
                {
                  var comment = new Comment();
                  offset = comment.parse({
                    src
                  }, offset);
                  this.directives.push(comment);
                  atLineStart = false;
                }
                break;
              case "%":
                {
                  var directive = new Directive();
                  offset = directive.parse({
                    parent: this,
                    src
                  }, offset);
                  this.directives.push(directive);
                  hasDirectives = true;
                  atLineStart = false;
                }
                break;
              default:
                if (hasDirectives) {
                  this.error = new YAMLSemanticError(this, "Missing directives-end indicator line");
                } else if (this.directives.length > 0) {
                  this.contents = this.directives;
                  this.directives = [];
                }
                return offset;
            }
          }
          if (src[offset]) {
            this.directivesEndMarker = new Range(offset, offset + 3);
            return offset + 3;
          }
          if (hasDirectives) {
            this.error = new YAMLSemanticError(this, "Missing directives-end indicator line");
          } else if (this.directives.length > 0) {
            this.contents = this.directives;
            this.directives = [];
          }
          return offset;
        }
      }, {
        key: "parseContents",
        value: function parseContents2(start) {
          var _this$context = this.context, parseNode = _this$context.parseNode, src = _this$context.src;
          if (!this.contents)
            this.contents = [];
          var lineStart = start;
          while (src[lineStart - 1] === "-") {
            lineStart -= 1;
          }
          var offset = Node.endOfWhiteSpace(src, start);
          var atLineStart = lineStart === start;
          this.valueRange = new Range(offset);
          while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {
            switch (src[offset]) {
              case "\n":
                if (atLineStart) {
                  var blankLine = new BlankLine();
                  offset = blankLine.parse({
                    src
                  }, offset);
                  if (offset < src.length) {
                    this.contents.push(blankLine);
                  }
                } else {
                  offset += 1;
                  atLineStart = true;
                }
                lineStart = offset;
                break;
              case "#":
                {
                  var comment = new Comment();
                  offset = comment.parse({
                    src
                  }, offset);
                  this.contents.push(comment);
                  atLineStart = false;
                }
                break;
              default: {
                var iEnd = Node.endOfIndent(src, offset);
                var context = {
                  atLineStart,
                  indent: -1,
                  inFlow: false,
                  inCollection: false,
                  lineStart,
                  parent: this
                };
                var node = parseNode(context, iEnd);
                if (!node)
                  return this.valueRange.end = iEnd;
                this.contents.push(node);
                offset = node.range.end;
                atLineStart = false;
                var ec = grabCollectionEndComments(node);
                if (ec)
                  Array.prototype.push.apply(this.contents, ec);
              }
            }
            offset = Document3.startCommentOrEndBlankLine(src, offset);
          }
          this.valueRange.end = offset;
          if (src[offset]) {
            this.documentEndMarker = new Range(offset, offset + 3);
            offset += 3;
            if (src[offset]) {
              offset = Node.endOfWhiteSpace(src, offset);
              if (src[offset] === "#") {
                var _comment = new Comment();
                offset = _comment.parse({
                  src
                }, offset);
                this.contents.push(_comment);
              }
              switch (src[offset]) {
                case "\n":
                  offset += 1;
                  break;
                case void 0:
                  break;
                default:
                  this.error = new YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
              }
            }
          }
          return offset;
        }
        /**
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          context.root = this;
          this.context = context;
          var src = context.src;
          var offset = src.charCodeAt(start) === 65279 ? start + 1 : start;
          offset = this.parseDirectives(offset);
          offset = this.parseContents(offset);
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(Document3.prototype), "setOrigRanges", this).call(this, cr, offset);
          this.directives.forEach(function(node) {
            offset = node.setOrigRanges(cr, offset);
          });
          if (this.directivesEndMarker)
            offset = this.directivesEndMarker.setOrigRange(cr, offset);
          this.contents.forEach(function(node) {
            offset = node.setOrigRanges(cr, offset);
          });
          if (this.documentEndMarker)
            offset = this.documentEndMarker.setOrigRange(cr, offset);
          return offset;
        }
      }, {
        key: "toString",
        value: function toString4() {
          var contents = this.contents, directives = this.directives, value2 = this.value;
          if (value2 != null)
            return value2;
          var str = directives.join("");
          if (contents.length > 0) {
            if (directives.length > 0 || contents[0].type === Type.COMMENT)
              str += "---\n";
            str += contents.join("");
          }
          if (str[str.length - 1] !== "\n")
            str += "\n";
          return str;
        }
      }], [{
        key: "startCommentOrEndBlankLine",
        value: function startCommentOrEndBlankLine(src, start) {
          var offset = Node.endOfWhiteSpace(src, start);
          var ch = src[offset];
          return ch === "#" || ch === "\n" ? offset : start;
        }
      }]);
      return Document3;
    }(Node);
    Alias = function(_Node) {
      _inherits(Alias3, _Node);
      var _super = _createSuper(Alias3);
      function Alias3() {
        _classCallCheck(this, Alias3);
        return _super.apply(this, arguments);
      }
      _createClass(Alias3, [{
        key: "parse",
        value: (
          /**
           * Parses an *alias from the source
           *
           * @param {ParseContext} context
           * @param {number} start - Index of first character
           * @returns {number} - Index of the character after this scalar
           */
          function parse3(context, start) {
            this.context = context;
            var src = context.src;
            var offset = Node.endOfIdentifier(src, start + 1);
            this.valueRange = new Range(start + 1, offset);
            offset = Node.endOfWhiteSpace(src, offset);
            offset = this.parseComment(offset);
            return offset;
          }
        )
      }]);
      return Alias3;
    }(Node);
    Chomp = {
      CLIP: "CLIP",
      KEEP: "KEEP",
      STRIP: "STRIP"
    };
    BlockValue = function(_Node) {
      _inherits(BlockValue2, _Node);
      var _super = _createSuper(BlockValue2);
      function BlockValue2(type3, props3) {
        var _this;
        _classCallCheck(this, BlockValue2);
        _this = _super.call(this, type3, props3);
        _this.blockIndent = null;
        _this.chomping = Chomp.CLIP;
        _this.header = null;
        return _this;
      }
      _createClass(BlockValue2, [{
        key: "includesTrailingLines",
        get: function get() {
          return this.chomping === Chomp.KEEP;
        }
      }, {
        key: "strValue",
        get: function get() {
          if (!this.valueRange || !this.context)
            return null;
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
          if (this.valueRange.isEmpty())
            return "";
          var lastNewLine = null;
          var ch = src[end - 1];
          while (ch === "\n" || ch === "	" || ch === " ") {
            end -= 1;
            if (end <= start) {
              if (this.chomping === Chomp.KEEP)
                break;
              else
                return "";
            }
            if (ch === "\n")
              lastNewLine = end;
            ch = src[end - 1];
          }
          var keepStart = end + 1;
          if (lastNewLine) {
            if (this.chomping === Chomp.KEEP) {
              keepStart = lastNewLine;
              end = this.valueRange.end;
            } else {
              end = lastNewLine;
            }
          }
          var bi = indent + this.blockIndent;
          var folded = this.type === Type.BLOCK_FOLDED;
          var atStart = true;
          var str = "";
          var sep = "";
          var prevMoreIndented = false;
          for (var i = start; i < end; ++i) {
            for (var j = 0; j < bi; ++j) {
              if (src[i] !== " ")
                break;
              i += 1;
            }
            var _ch = src[i];
            if (_ch === "\n") {
              if (sep === "\n")
                str += "\n";
              else
                sep = "\n";
            } else {
              var lineEnd = Node.endOfLine(src, i);
              var line = src.slice(i, lineEnd);
              i = lineEnd;
              if (folded && (_ch === " " || _ch === "	") && i < keepStart) {
                if (sep === " ")
                  sep = "\n";
                else if (!prevMoreIndented && !atStart && sep === "\n")
                  sep = "\n\n";
                str += sep + line;
                sep = lineEnd < end && src[lineEnd] || "";
                prevMoreIndented = true;
              } else {
                str += sep + line;
                sep = folded && i < keepStart ? " " : "\n";
                prevMoreIndented = false;
              }
              if (atStart && line !== "")
                atStart = false;
            }
          }
          return this.chomping === Chomp.STRIP ? str : str + "\n";
        }
      }, {
        key: "parseBlockHeader",
        value: function parseBlockHeader(start) {
          var src = this.context.src;
          var offset = start + 1;
          var bi = "";
          while (true) {
            var ch = src[offset];
            switch (ch) {
              case "-":
                this.chomping = Chomp.STRIP;
                break;
              case "+":
                this.chomping = Chomp.KEEP;
                break;
              case "0":
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                bi += ch;
                break;
              default:
                this.blockIndent = Number(bi) || null;
                this.header = new Range(start, offset);
                return offset;
            }
            offset += 1;
          }
        }
      }, {
        key: "parseBlockValue",
        value: function parseBlockValue(start) {
          var _this$context2 = this.context, indent = _this$context2.indent, src = _this$context2.src;
          var explicit = !!this.blockIndent;
          var offset = start;
          var valueEnd = start;
          var minBlockIndent = 1;
          for (var ch = src[offset]; ch === "\n"; ch = src[offset]) {
            offset += 1;
            if (Node.atDocumentBoundary(src, offset))
              break;
            var end = Node.endOfBlockIndent(src, indent, offset);
            if (end === null)
              break;
            var _ch2 = src[end];
            var lineIndent = end - (offset + indent);
            if (!this.blockIndent) {
              if (src[end] !== "\n") {
                if (lineIndent < minBlockIndent) {
                  var msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                  this.error = new YAMLSemanticError(this, msg);
                }
                this.blockIndent = lineIndent;
              } else if (lineIndent > minBlockIndent) {
                minBlockIndent = lineIndent;
              }
            } else if (_ch2 && _ch2 !== "\n" && lineIndent < this.blockIndent) {
              if (src[end] === "#")
                break;
              if (!this.error) {
                var _src = explicit ? "explicit indentation indicator" : "first line";
                var _msg = "Block scalars must not be less indented than their ".concat(_src);
                this.error = new YAMLSemanticError(this, _msg);
              }
            }
            if (src[end] === "\n") {
              offset = end;
            } else {
              offset = valueEnd = Node.endOfLine(src, end);
            }
          }
          if (this.chomping !== Chomp.KEEP) {
            offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
          }
          this.valueRange = new Range(start + 1, offset);
          return offset;
        }
        /**
         * Parses a block value from the source
         *
         * Accepted forms are:
         * ```
         * BS
         * block
         * lines
         *
         * BS #comment
         * block
         * lines
         * ```
         * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
         * are empty or have an indent level greater than `indent`.
         *
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this block
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var src = context.src;
          var offset = this.parseBlockHeader(start);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          offset = this.parseBlockValue(offset);
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(BlockValue2.prototype), "setOrigRanges", this).call(this, cr, offset);
          return this.header ? this.header.setOrigRange(cr, offset) : offset;
        }
      }]);
      return BlockValue2;
    }(Node);
    FlowCollection = function(_Node) {
      _inherits(FlowCollection2, _Node);
      var _super = _createSuper(FlowCollection2);
      function FlowCollection2(type3, props3) {
        var _this;
        _classCallCheck(this, FlowCollection2);
        _this = _super.call(this, type3, props3);
        _this.items = null;
        return _this;
      }
      _createClass(FlowCollection2, [{
        key: "prevNodeIsJsonLike",
        value: function prevNodeIsJsonLike() {
          var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.items.length;
          var node = this.items[idx - 1];
          return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
        }
        /**
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var parseNode = context.parseNode, src = context.src;
          var indent = context.indent, lineStart = context.lineStart;
          var char = src[start];
          this.items = [{
            char,
            offset: start
          }];
          var offset = Node.endOfWhiteSpace(src, start + 1);
          char = src[offset];
          while (char && char !== "]" && char !== "}") {
            switch (char) {
              case "\n":
                {
                  lineStart = offset + 1;
                  var wsEnd = Node.endOfWhiteSpace(src, lineStart);
                  if (src[wsEnd] === "\n") {
                    var blankLine = new BlankLine();
                    lineStart = blankLine.parse({
                      src
                    }, lineStart);
                    this.items.push(blankLine);
                  }
                  offset = Node.endOfIndent(src, lineStart);
                  if (offset <= lineStart + indent) {
                    char = src[offset];
                    if (offset < lineStart + indent || char !== "]" && char !== "}") {
                      var msg = "Insufficient indentation in flow collection";
                      this.error = new YAMLSemanticError(this, msg);
                    }
                  }
                }
                break;
              case ",":
                {
                  this.items.push({
                    char,
                    offset
                  });
                  offset += 1;
                }
                break;
              case "#":
                {
                  var comment = new Comment();
                  offset = comment.parse({
                    src
                  }, offset);
                  this.items.push(comment);
                }
                break;
              case "?":
              case ":": {
                var next = src[offset + 1];
                if (next === "\n" || next === "	" || next === " " || next === "," || // in-flow : after JSON-like key does not need to be followed by whitespace
                char === ":" && this.prevNodeIsJsonLike()) {
                  this.items.push({
                    char,
                    offset
                  });
                  offset += 1;
                  break;
                }
              }
              default: {
                var node = parseNode({
                  atLineStart: false,
                  inCollection: false,
                  inFlow: true,
                  indent: -1,
                  lineStart,
                  parent: this
                }, offset);
                if (!node) {
                  this.valueRange = new Range(start, offset);
                  return offset;
                }
                this.items.push(node);
                offset = Node.normalizeOffset(src, node.range.end);
              }
            }
            offset = Node.endOfWhiteSpace(src, offset);
            char = src[offset];
          }
          this.valueRange = new Range(start, offset + 1);
          if (char) {
            this.items.push({
              char,
              offset
            });
            offset = Node.endOfWhiteSpace(src, offset + 1);
            offset = this.parseComment(offset);
          }
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(FlowCollection2.prototype), "setOrigRanges", this).call(this, cr, offset);
          this.items.forEach(function(node) {
            if (node instanceof Node) {
              offset = node.setOrigRanges(cr, offset);
            } else if (cr.length === 0) {
              node.origOffset = node.offset;
            } else {
              var i = offset;
              while (i < cr.length) {
                if (cr[i] > node.offset)
                  break;
                else
                  ++i;
              }
              node.origOffset = node.offset + i;
              offset = i;
            }
          });
          return offset;
        }
      }, {
        key: "toString",
        value: function toString4() {
          var src = this.context.src, items = this.items, range3 = this.range, value2 = this.value;
          if (value2 != null)
            return value2;
          var nodes = items.filter(function(item) {
            return item instanceof Node;
          });
          var str = "";
          var prevEnd = range3.start;
          nodes.forEach(function(node) {
            var prefix = src.slice(prevEnd, node.range.start);
            prevEnd = node.range.end;
            str += prefix + String(node);
            if (str[str.length - 1] === "\n" && src[prevEnd - 1] !== "\n" && src[prevEnd] === "\n") {
              prevEnd += 1;
            }
          });
          str += src.slice(prevEnd, range3.end);
          return Node.addStringTerminator(src, range3.end, str);
        }
      }]);
      return FlowCollection2;
    }(Node);
    QuoteDouble = function(_Node) {
      _inherits(QuoteDouble2, _Node);
      var _super = _createSuper(QuoteDouble2);
      function QuoteDouble2() {
        _classCallCheck(this, QuoteDouble2);
        return _super.apply(this, arguments);
      }
      _createClass(QuoteDouble2, [{
        key: "strValue",
        get: (
          /**
           * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
           */
          function get() {
            if (!this.valueRange || !this.context)
              return null;
            var errors = [];
            var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
            var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
            if (src[end - 1] !== '"')
              errors.push(new YAMLSyntaxError(this, 'Missing closing "quote'));
            var str = "";
            for (var i = start + 1; i < end - 1; ++i) {
              var ch = src[i];
              if (ch === "\n") {
                if (Node.atDocumentBoundary(src, i + 1))
                  errors.push(new YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
                var _Node$foldNewline = Node.foldNewline(src, i, indent), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset, error = _Node$foldNewline.error;
                str += fold;
                i = offset;
                if (error)
                  errors.push(new YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
              } else if (ch === "\\") {
                i += 1;
                switch (src[i]) {
                  case "0":
                    str += "\0";
                    break;
                  case "a":
                    str += "\x07";
                    break;
                  case "b":
                    str += "\b";
                    break;
                  case "e":
                    str += "\x1B";
                    break;
                  case "f":
                    str += "\f";
                    break;
                  case "n":
                    str += "\n";
                    break;
                  case "r":
                    str += "\r";
                    break;
                  case "t":
                    str += "	";
                    break;
                  case "v":
                    str += "\v";
                    break;
                  case "N":
                    str += "";
                    break;
                  case "_":
                    str += " ";
                    break;
                  case "L":
                    str += "\u2028";
                    break;
                  case "P":
                    str += "\u2029";
                    break;
                  case " ":
                    str += " ";
                    break;
                  case '"':
                    str += '"';
                    break;
                  case "/":
                    str += "/";
                    break;
                  case "\\":
                    str += "\\";
                    break;
                  case "	":
                    str += "	";
                    break;
                  case "x":
                    str += this.parseCharCode(i + 1, 2, errors);
                    i += 2;
                    break;
                  case "u":
                    str += this.parseCharCode(i + 1, 4, errors);
                    i += 4;
                    break;
                  case "U":
                    str += this.parseCharCode(i + 1, 8, errors);
                    i += 8;
                    break;
                  case "\n":
                    while (src[i + 1] === " " || src[i + 1] === "	") {
                      i += 1;
                    }
                    break;
                  default:
                    errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(i - 1, 2))));
                    str += "\\" + src[i];
                }
              } else if (ch === " " || ch === "	") {
                var wsStart = i;
                var next = src[i + 1];
                while (next === " " || next === "	") {
                  i += 1;
                  next = src[i + 1];
                }
                if (next !== "\n")
                  str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
              } else {
                str += ch;
              }
            }
            return errors.length > 0 ? {
              errors,
              str
            } : str;
          }
        )
      }, {
        key: "parseCharCode",
        value: function parseCharCode(offset, length4, errors) {
          var src = this.context.src;
          var cc = src.substr(offset, length4);
          var ok = cc.length === length4 && /^[0-9a-fA-F]+$/.test(cc);
          var code = ok ? parseInt(cc, 16) : NaN;
          if (isNaN(code)) {
            errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(offset - 2, length4 + 2))));
            return src.substr(offset - 2, length4 + 2);
          }
          return String.fromCodePoint(code);
        }
        /**
         * Parses a "double quoted" value from the source
         *
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this scalar
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var src = context.src;
          var offset = QuoteDouble2.endOfQuote(src, start + 1);
          this.valueRange = new Range(start, offset);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          return offset;
        }
      }], [{
        key: "endOfQuote",
        value: function endOfQuote(src, offset) {
          var ch = src[offset];
          while (ch && ch !== '"') {
            offset += ch === "\\" ? 2 : 1;
            ch = src[offset];
          }
          return offset + 1;
        }
      }]);
      return QuoteDouble2;
    }(Node);
    QuoteSingle = function(_Node) {
      _inherits(QuoteSingle2, _Node);
      var _super = _createSuper(QuoteSingle2);
      function QuoteSingle2() {
        _classCallCheck(this, QuoteSingle2);
        return _super.apply(this, arguments);
      }
      _createClass(QuoteSingle2, [{
        key: "strValue",
        get: (
          /**
           * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
           */
          function get() {
            if (!this.valueRange || !this.context)
              return null;
            var errors = [];
            var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
            var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
            if (src[end - 1] !== "'")
              errors.push(new YAMLSyntaxError(this, "Missing closing 'quote"));
            var str = "";
            for (var i = start + 1; i < end - 1; ++i) {
              var ch = src[i];
              if (ch === "\n") {
                if (Node.atDocumentBoundary(src, i + 1))
                  errors.push(new YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
                var _Node$foldNewline = Node.foldNewline(src, i, indent), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset, error = _Node$foldNewline.error;
                str += fold;
                i = offset;
                if (error)
                  errors.push(new YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
              } else if (ch === "'") {
                str += ch;
                i += 1;
                if (src[i] !== "'")
                  errors.push(new YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
              } else if (ch === " " || ch === "	") {
                var wsStart = i;
                var next = src[i + 1];
                while (next === " " || next === "	") {
                  i += 1;
                  next = src[i + 1];
                }
                if (next !== "\n")
                  str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
              } else {
                str += ch;
              }
            }
            return errors.length > 0 ? {
              errors,
              str
            } : str;
          }
        )
        /**
         * Parses a 'single quoted' value from the source
         *
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this scalar
         */
      }, {
        key: "parse",
        value: function parse3(context, start) {
          this.context = context;
          var src = context.src;
          var offset = QuoteSingle2.endOfQuote(src, start + 1);
          this.valueRange = new Range(start, offset);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          return offset;
        }
      }], [{
        key: "endOfQuote",
        value: function endOfQuote(src, offset) {
          var ch = src[offset];
          while (ch) {
            if (ch === "'") {
              if (src[offset + 1] !== "'")
                break;
              ch = src[offset += 2];
            } else {
              ch = src[offset += 1];
            }
          }
          return offset + 1;
        }
      }]);
      return QuoteSingle2;
    }(Node);
    ParseContext = function() {
      function ParseContext2() {
        var _this = this;
        var orig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, atLineStart = _ref.atLineStart, inCollection = _ref.inCollection, inFlow = _ref.inFlow, indent = _ref.indent, lineStart = _ref.lineStart, parent = _ref.parent;
        _classCallCheck(this, ParseContext2);
        _defineProperty(this, "parseNode", function(overlay, start) {
          if (Node.atDocumentBoundary(_this.src, start))
            return null;
          var context = new ParseContext2(_this, overlay);
          var _context$parseProps = context.parseProps(start), props3 = _context$parseProps.props, type3 = _context$parseProps.type, valueStart = _context$parseProps.valueStart;
          var node = createNewNode(type3, props3);
          var offset = node.parse(context, valueStart);
          node.range = new Range(start, offset);
          if (offset <= start) {
            node.error = new Error("Node#parse consumed no characters");
            node.error.parseEnd = offset;
            node.error.source = node;
            node.range.end = start + 1;
          }
          if (context.nodeStartsCollection(node)) {
            if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {
              node.error = new YAMLSyntaxError(node, "Block collection must not have preceding content here (e.g. directives-end indicator)");
            }
            var collection = new Collection(node);
            offset = collection.parse(new ParseContext2(context), offset);
            collection.range = new Range(start, offset);
            return collection;
          }
          return node;
        });
        this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
        this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
        this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
        this.indent = indent != null ? indent : orig.indent;
        this.lineStart = lineStart != null ? lineStart : orig.lineStart;
        this.parent = parent != null ? parent : orig.parent || {};
        this.root = orig.root;
        this.src = orig.src;
      }
      _createClass(ParseContext2, [{
        key: "nodeStartsCollection",
        value: function nodeStartsCollection(node) {
          var inCollection = this.inCollection, inFlow = this.inFlow, src = this.src;
          if (inCollection || inFlow)
            return false;
          if (node instanceof CollectionItem)
            return true;
          var offset = node.range.end;
          if (src[offset] === "\n" || src[offset - 1] === "\n")
            return false;
          offset = Node.endOfWhiteSpace(src, offset);
          return src[offset] === ":";
        }
        // Anchor and tag are before type, which determines the node implementation
        // class; hence this intermediate step.
      }, {
        key: "parseProps",
        value: function parseProps(offset) {
          var inFlow = this.inFlow, parent = this.parent, src = this.src;
          var props3 = [];
          var lineHasProps = false;
          offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);
          var ch = src[offset];
          while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === "\n") {
            if (ch === "\n") {
              var inEnd = offset;
              var lineStart = void 0;
              do {
                lineStart = inEnd + 1;
                inEnd = Node.endOfIndent(src, lineStart);
              } while (src[inEnd] === "\n");
              var indentDiff = inEnd - (lineStart + this.indent);
              var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;
              if (src[inEnd] !== "#" && !Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent))
                break;
              this.atLineStart = true;
              this.lineStart = lineStart;
              lineHasProps = false;
              offset = inEnd;
            } else if (ch === Char.COMMENT) {
              var end = Node.endOfLine(src, offset + 1);
              props3.push(new Range(offset, end));
              offset = end;
            } else {
              var _end = Node.endOfIdentifier(src, offset + 1);
              if (ch === Char.TAG && src[_end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, _end + 13))) {
                _end = Node.endOfIdentifier(src, _end + 5);
              }
              props3.push(new Range(offset, _end));
              lineHasProps = true;
              offset = Node.endOfWhiteSpace(src, _end);
            }
            ch = src[offset];
          }
          if (lineHasProps && ch === ":" && Node.atBlank(src, offset + 1, true))
            offset -= 1;
          var type3 = ParseContext2.parseType(src, offset, inFlow);
          return {
            props: props3,
            type: type3,
            valueStart: offset
          };
        }
        /**
         * Parses a node from the source
         * @param {ParseContext} overlay
         * @param {number} start - Index of first non-whitespace character for the node
         * @returns {?Node} - null if at a document boundary
         */
      }], [{
        key: "parseType",
        value: function parseType(src, offset, inFlow) {
          switch (src[offset]) {
            case "*":
              return Type.ALIAS;
            case ">":
              return Type.BLOCK_FOLDED;
            case "|":
              return Type.BLOCK_LITERAL;
            case "{":
              return Type.FLOW_MAP;
            case "[":
              return Type.FLOW_SEQ;
            case "?":
              return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;
            case ":":
              return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;
            case "-":
              return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;
            case '"':
              return Type.QUOTE_DOUBLE;
            case "'":
              return Type.QUOTE_SINGLE;
            default:
              return Type.PLAIN;
          }
        }
      }]);
      return ParseContext2;
    }();
  }
});

// node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/resolveSeq-492ab440.js
function addCommentBefore(str, indent, comment) {
  if (!comment)
    return str;
  var cc = comment.replace(/[\s\S]^/gm, "$&".concat(indent, "#"));
  return "#".concat(cc, "\n").concat(indent).concat(str);
}
function addComment(str, indent, comment) {
  return !comment ? str : comment.indexOf("\n") === -1 ? "".concat(str, " #").concat(comment) : "".concat(str, "\n") + comment.replace(/^/gm, "".concat(indent || "", "#"));
}
function toJSON(value2, arg, ctx) {
  if (Array.isArray(value2))
    return value2.map(function(v, i) {
      return toJSON(v, String(i), ctx);
    });
  if (value2 && typeof value2.toJSON === "function") {
    var anchor = ctx && ctx.anchors && ctx.anchors.get(value2);
    if (anchor)
      ctx.onCreate = function(res2) {
        anchor.res = res2;
        delete ctx.onCreate;
      };
    var res = value2.toJSON(arg, ctx);
    if (anchor && ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if ((!ctx || !ctx.keep) && typeof value2 === "bigint")
    return Number(value2);
  return value2;
}
function collectionFromPath(schema, path3, value2) {
  var v = value2;
  for (var i = path3.length - 1; i >= 0; --i) {
    var k = path3[i];
    if (Number.isInteger(k) && k >= 0) {
      var a = [];
      a[k] = v;
      v = a;
    } else {
      var o3 = {};
      Object.defineProperty(o3, k, {
        value: v,
        writable: true,
        enumerable: true,
        configurable: true
      });
      v = o3;
    }
  }
  return schema.createNode(v, false);
}
function asItemIndex(key) {
  var idx = key instanceof Scalar ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return Number.isInteger(idx) && idx >= 0 ? idx : null;
}
function findPair(items, key) {
  var k = key instanceof Scalar ? key.value : key;
  var _iterator = _createForOfIteratorHelper(items), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var it = _step.value;
      if (it instanceof Pair) {
        if (it.key === key || it.key === k)
          return it;
        if (it.key && it.key.value === k)
          return it;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return void 0;
}
function resolveScalar(str, tags2, scalarFallback) {
  var _iterator = _createForOfIteratorHelper(tags2), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, format = _step$value.format, test3 = _step$value.test, resolve27 = _step$value.resolve;
      if (test3) {
        var match3 = str.match(test3);
        if (match3) {
          var res = resolve27.apply(null, match3);
          if (!(res instanceof Scalar))
            res = new Scalar(res);
          if (format)
            res.format = format;
          return res;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (scalarFallback)
    str = scalarFallback(str);
  return new Scalar(str);
}
function foldFlowLines(text, indent, mode, _ref) {
  var indentAtStart = _ref.indentAtStart, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth, _ref$minContentWidth = _ref.minContentWidth, minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth, onFold = _ref.onFold, onOverflow = _ref.onOverflow;
  if (!lineWidth || lineWidth < 0)
    return text;
  var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  var folds = [];
  var escapedFolds = {};
  var end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  var split2 = void 0;
  var prev = void 0;
  var overflow = false;
  var i = -1;
  var escStart = -1;
  var escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1)
      end = i + endStep;
  }
  for (var ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split2 = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        var next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split2 = i;
      }
      if (i >= end) {
        if (split2) {
          folds.push(split2);
          end = split2 + endStep;
          split2 = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          var j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split2 = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  var res = text.slice(0, folds[0]);
  for (var _i = 0; _i < folds.length; ++_i) {
    var fold = folds[_i];
    var _end = folds[_i + 1] || text.length;
    if (fold === 0)
      res = "\n".concat(indent).concat(text.slice(0, _end));
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += "".concat(text[fold], "\\");
      res += "\n".concat(indent).concat(text.slice(fold + 1, _end));
    }
  }
  return res;
}
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  var limit = lineWidth - indentLength;
  var strLen = str.length;
  if (strLen <= limit)
    return false;
  for (var i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value2, ctx) {
  var implicitKey = ctx.implicitKey;
  var _strOptions$doubleQuo = strOptions.doubleQuoted, jsonEncoding = _strOptions$doubleQuo.jsonEncoding, minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;
  var json2 = JSON.stringify(value2);
  if (jsonEncoding)
    return json2;
  var indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
  var str = "";
  var start = 0;
  for (var i = 0, ch = json2[i]; ch; ch = json2[++i]) {
    if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
      str += json2.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json2[i + 1]) {
        case "u":
          {
            str += json2.slice(start, i);
            var code = json2.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json2.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json2.slice(start, i) + "\n\n";
            while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json2[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json2.slice(start) : json2;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value2, ctx) {
  if (ctx.implicitKey) {
    if (/\n/.test(value2))
      return doubleQuotedString(value2, ctx);
  } else {
    if (/[ \t]\n|\n[ \t]/.test(value2))
      return doubleQuotedString(value2, ctx);
  }
  var indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
  var res = "'" + value2.replace(/'/g, "''").replace(/\n+/g, "$&\n".concat(indent)) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function blockString(_ref2, ctx, onComment, onChompKeep) {
  var comment = _ref2.comment, type3 = _ref2.type, value2 = _ref2.value;
  if (/\n[\t ]+$/.test(value2) || /^\s*$/.test(value2)) {
    return doubleQuotedString(value2, ctx);
  }
  var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value2) ? "  " : "");
  var indentSize = indent ? "2" : "1";
  var literal = type3 === Type.BLOCK_FOLDED ? false : type3 === Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value2, strOptions.fold.lineWidth, indent.length);
  var header = literal ? "|" : ">";
  if (!value2)
    return header + "\n";
  var wsStart = "";
  var wsEnd = "";
  value2 = value2.replace(/[\n\t ]*$/, function(ws2) {
    var n = ws2.indexOf("\n");
    if (n === -1) {
      header += "-";
    } else if (value2 === ws2 || n !== ws2.length - 1) {
      header += "+";
      if (onChompKeep)
        onChompKeep();
    }
    wsEnd = ws2.replace(/\n$/, "");
    return "";
  }).replace(/^[\n ]*/, function(ws2) {
    if (ws2.indexOf(" ") !== -1)
      header += indentSize;
    var m = ws2.match(/ +$/);
    if (m) {
      wsStart = ws2.slice(0, -m[0].length);
      return m[0];
    } else {
      wsStart = ws2;
      return "";
    }
  });
  if (wsEnd)
    wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, "$&".concat(indent));
  if (wsStart)
    wsStart = wsStart.replace(/\n+/g, "$&".concat(indent));
  if (comment) {
    header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
    if (onComment)
      onComment();
  }
  if (!value2)
    return "".concat(header).concat(indentSize, "\n").concat(indent).concat(wsEnd);
  if (literal) {
    value2 = value2.replace(/\n+/g, "$&".concat(indent));
    return "".concat(header, "\n").concat(indent).concat(wsStart).concat(value2).concat(wsEnd);
  }
  value2 = value2.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, "$&".concat(indent));
  var body = foldFlowLines("".concat(wsStart).concat(value2).concat(wsEnd), indent, FOLD_BLOCK, strOptions.fold);
  return "".concat(header, "\n").concat(indent).concat(body);
}
function plainString(item, ctx, onComment, onChompKeep) {
  var comment = item.comment, type3 = item.type, value2 = item.value;
  var actualString = ctx.actualString, implicitKey = ctx.implicitKey, indent = ctx.indent, inFlow = ctx.inFlow;
  if (implicitKey && /[\n[\]{},]/.test(value2) || inFlow && /[[\]{},]/.test(value2)) {
    return doubleQuotedString(value2, ctx);
  }
  if (!value2 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value2)) {
    return implicitKey || inFlow || value2.indexOf("\n") === -1 ? value2.indexOf('"') !== -1 && value2.indexOf("'") === -1 ? singleQuotedString(value2, ctx) : doubleQuotedString(value2, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type3 !== Type.PLAIN && value2.indexOf("\n") !== -1) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value2)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  var str = value2.replace(/\n+/g, "$&\n".concat(indent));
  if (actualString) {
    var tags2 = ctx.doc.schema.tags;
    var resolved = resolveScalar(str, tags2, tags2.scalarFallback).value;
    if (typeof resolved !== "string")
      return doubleQuotedString(value2, ctx);
  }
  var body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
  if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
    if (onComment)
      onComment();
    return addCommentBefore(body, indent, comment);
  }
  return body;
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  var defaultType = strOptions.defaultType;
  var implicitKey = ctx.implicitKey, inFlow = ctx.inFlow;
  var _item = item, type3 = _item.type, value2 = _item.value;
  if (typeof value2 !== "string") {
    value2 = String(value2);
    item = Object.assign({}, item, {
      value: value2
    });
  }
  var _stringify = function _stringify2(_type) {
    switch (_type) {
      case Type.BLOCK_FOLDED:
      case Type.BLOCK_LITERAL:
        return blockString(item, ctx, onComment, onChompKeep);
      case Type.QUOTE_DOUBLE:
        return doubleQuotedString(value2, ctx);
      case Type.QUOTE_SINGLE:
        return singleQuotedString(value2, ctx);
      case Type.PLAIN:
        return plainString(item, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  if (type3 !== Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value2)) {
    type3 = Type.QUOTE_DOUBLE;
  } else if ((implicitKey || inFlow) && (type3 === Type.BLOCK_FOLDED || type3 === Type.BLOCK_LITERAL)) {
    type3 = Type.QUOTE_DOUBLE;
  }
  var res = _stringify(type3);
  if (res === null) {
    res = _stringify(defaultType);
    if (res === null)
      throw new Error("Unsupported default string type ".concat(defaultType));
  }
  return res;
}
function stringifyNumber(_ref) {
  var format = _ref.format, minFractionDigits = _ref.minFractionDigits, tag = _ref.tag, value2 = _ref.value;
  if (typeof value2 === "bigint")
    return String(value2);
  if (!isFinite(value2))
    return isNaN(value2) ? ".nan" : value2 < 0 ? "-.inf" : ".inf";
  var n = JSON.stringify(value2);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    var i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    var d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0) {
      n += "0";
    }
  }
  return n;
}
function checkFlowCollectionEnd(errors, cst) {
  var char, name;
  switch (cst.type) {
    case Type.FLOW_MAP:
      char = "}";
      name = "flow map";
      break;
    case Type.FLOW_SEQ:
      char = "]";
      name = "flow sequence";
      break;
    default:
      errors.push(new YAMLSemanticError(cst, "Not a flow collection!?"));
      return;
  }
  var lastItem;
  for (var i = cst.items.length - 1; i >= 0; --i) {
    var item = cst.items[i];
    if (!item || item.type !== Type.COMMENT) {
      lastItem = item;
      break;
    }
  }
  if (lastItem && lastItem.char !== char) {
    var msg = "Expected ".concat(name, " to end with ").concat(char);
    var err;
    if (typeof lastItem.offset === "number") {
      err = new YAMLSemanticError(cst, msg);
      err.offset = lastItem.offset + 1;
    } else {
      err = new YAMLSemanticError(lastItem, msg);
      if (lastItem.range && lastItem.range.end)
        err.offset = lastItem.range.end - lastItem.range.start;
    }
    errors.push(err);
  }
}
function checkFlowCommentSpace(errors, comment) {
  var prev = comment.context.src[comment.range.start - 1];
  if (prev !== "\n" && prev !== "	" && prev !== " ") {
    var msg = "Comments must be separated from other tokens by white space characters";
    errors.push(new YAMLSemanticError(comment, msg));
  }
}
function getLongKeyError(source, key) {
  var sk = String(key);
  var k = sk.substr(0, 8) + "..." + sk.substr(-8);
  return new YAMLSemanticError(source, 'The "'.concat(k, '" key is too long'));
}
function resolveComments(collection, comments) {
  var _iterator = _createForOfIteratorHelper(comments), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, afterKey = _step$value.afterKey, before = _step$value.before, comment = _step$value.comment;
      var item = collection.items[before];
      if (!item) {
        if (comment !== void 0) {
          if (collection.comment)
            collection.comment += "\n" + comment;
          else
            collection.comment = comment;
        }
      } else {
        if (afterKey && item.value)
          item = item.value;
        if (comment === void 0) {
          if (afterKey || !item.commentBefore)
            item.spaceBefore = true;
        } else {
          if (item.commentBefore)
            item.commentBefore += "\n" + comment;
          else
            item.commentBefore = comment;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function resolveString(doc, node) {
  var res = node.strValue;
  if (!res)
    return "";
  if (typeof res === "string")
    return res;
  res.errors.forEach(function(error) {
    if (!error.source)
      error.source = node;
    doc.errors.push(error);
  });
  return res.str;
}
function resolveTagHandle(doc, node) {
  var _node$tag = node.tag, handle = _node$tag.handle, suffix = _node$tag.suffix;
  var prefix = doc.tagPrefixes.find(function(p) {
    return p.handle === handle;
  });
  if (!prefix) {
    var dtp = doc.getDefaults().tagPrefixes;
    if (dtp)
      prefix = dtp.find(function(p) {
        return p.handle === handle;
      });
    if (!prefix)
      throw new YAMLSemanticError(node, "The ".concat(handle, " tag handle is non-default and was not declared."));
  }
  if (!suffix)
    throw new YAMLSemanticError(node, "The ".concat(handle, " tag has no suffix."));
  if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
    if (suffix[0] === "^") {
      doc.warnings.push(new YAMLWarning(node, "YAML 1.0 ^ tag expansion is not supported"));
      return suffix;
    }
    if (/[:/]/.test(suffix)) {
      var vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
      return vocab ? "tag:".concat(vocab[1], ".yaml.org,2002:").concat(vocab[2]) : "tag:".concat(suffix);
    }
  }
  return prefix.prefix + decodeURIComponent(suffix);
}
function resolveTagName(doc, node) {
  var tag = node.tag, type3 = node.type;
  var nonSpecific = false;
  if (tag) {
    var handle = tag.handle, suffix = tag.suffix, verbatim = tag.verbatim;
    if (verbatim) {
      if (verbatim !== "!" && verbatim !== "!!")
        return verbatim;
      var msg = "Verbatim tags aren't resolved, so ".concat(verbatim, " is invalid.");
      doc.errors.push(new YAMLSemanticError(node, msg));
    } else if (handle === "!" && !suffix) {
      nonSpecific = true;
    } else {
      try {
        return resolveTagHandle(doc, node);
      } catch (error) {
        doc.errors.push(error);
      }
    }
  }
  switch (type3) {
    case Type.BLOCK_FOLDED:
    case Type.BLOCK_LITERAL:
    case Type.QUOTE_DOUBLE:
    case Type.QUOTE_SINGLE:
      return defaultTags.STR;
    case Type.FLOW_MAP:
    case Type.MAP:
      return defaultTags.MAP;
    case Type.FLOW_SEQ:
    case Type.SEQ:
      return defaultTags.SEQ;
    case Type.PLAIN:
      return nonSpecific ? defaultTags.STR : null;
    default:
      return null;
  }
}
function resolveByTagName(doc, node, tagName) {
  var tags2 = doc.schema.tags;
  var matchWithTest = [];
  var _iterator = _createForOfIteratorHelper(tags2), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var tag = _step.value;
      if (tag.tag === tagName) {
        if (tag.test)
          matchWithTest.push(tag);
        else {
          var res = tag.resolve(doc, node);
          return res instanceof Collection2 ? res : new Scalar(res);
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var str = resolveString(doc, node);
  if (typeof str === "string" && matchWithTest.length > 0)
    return resolveScalar(str, matchWithTest, tags2.scalarFallback);
  return null;
}
function getFallbackTagName(_ref) {
  var type3 = _ref.type;
  switch (type3) {
    case Type.FLOW_MAP:
    case Type.MAP:
      return defaultTags.MAP;
    case Type.FLOW_SEQ:
    case Type.SEQ:
      return defaultTags.SEQ;
    default:
      return defaultTags.STR;
  }
}
function resolveTag(doc, node, tagName) {
  try {
    var res = resolveByTagName(doc, node, tagName);
    if (res) {
      if (tagName && node.tag)
        res.tag = tagName;
      return res;
    }
  } catch (error) {
    if (!error.source)
      error.source = node;
    doc.errors.push(error);
    return null;
  }
  try {
    var fallback = getFallbackTagName(node);
    if (!fallback)
      throw new Error("The tag ".concat(tagName, " is unavailable"));
    var msg = "The tag ".concat(tagName, " is unavailable, falling back to ").concat(fallback);
    doc.warnings.push(new YAMLWarning(node, msg));
    var _res = resolveByTagName(doc, node, fallback);
    _res.tag = tagName;
    return _res;
  } catch (error) {
    var refError = new YAMLReferenceError(node, error.message);
    refError.stack = error.stack;
    doc.errors.push(refError);
    return null;
  }
}
function resolveNodeProps(errors, node) {
  var comments = {
    before: [],
    after: []
  };
  var hasAnchor = false;
  var hasTag = false;
  var props3 = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;
  var _iterator = _createForOfIteratorHelper(props3), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, start = _step$value.start, end = _step$value.end;
      switch (node.context.src[start]) {
        case Char.COMMENT: {
          if (!node.commentHasRequiredWhitespace(start)) {
            var msg = "Comments must be separated from other tokens by white space characters";
            errors.push(new YAMLSemanticError(node, msg));
          }
          var header = node.header, valueRange = node.valueRange;
          var cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
          cc.push(node.context.src.slice(start + 1, end));
          break;
        }
        case Char.ANCHOR:
          if (hasAnchor) {
            var _msg = "A node can have at most one anchor";
            errors.push(new YAMLSemanticError(node, _msg));
          }
          hasAnchor = true;
          break;
        case Char.TAG:
          if (hasTag) {
            var _msg2 = "A node can have at most one tag";
            errors.push(new YAMLSemanticError(node, _msg2));
          }
          hasTag = true;
          break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    comments,
    hasAnchor,
    hasTag
  };
}
function resolveNodeValue(doc, node) {
  var anchors = doc.anchors, errors = doc.errors, schema = doc.schema;
  if (node.type === Type.ALIAS) {
    var name = node.rawValue;
    var src = anchors.getNode(name);
    if (!src) {
      var msg = "Aliased anchor not found: ".concat(name);
      errors.push(new YAMLReferenceError(node, msg));
      return null;
    }
    var res = new Alias2(src);
    anchors._cstAliases.push(res);
    return res;
  }
  var tagName = resolveTagName(doc, node);
  if (tagName)
    return resolveTag(doc, node, tagName);
  if (node.type !== Type.PLAIN) {
    var _msg3 = "Failed to resolve ".concat(node.type, " node here");
    errors.push(new YAMLSyntaxError(node, _msg3));
    return null;
  }
  try {
    var str = resolveString(doc, node);
    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
  } catch (error) {
    if (!error.source)
      error.source = node;
    errors.push(error);
    return null;
  }
}
function resolveNode(doc, node) {
  if (!node)
    return null;
  if (node.error)
    doc.errors.push(node.error);
  var _resolveNodeProps = resolveNodeProps(doc.errors, node), comments = _resolveNodeProps.comments, hasAnchor = _resolveNodeProps.hasAnchor, hasTag = _resolveNodeProps.hasTag;
  if (hasAnchor) {
    var anchors = doc.anchors;
    var name = node.anchor;
    var prev = anchors.getNode(name);
    if (prev)
      anchors.map[anchors.newName(name)] = prev;
    anchors.map[name] = node;
  }
  if (node.type === Type.ALIAS && (hasAnchor || hasTag)) {
    var msg = "An alias node must not specify any properties";
    doc.errors.push(new YAMLSemanticError(node, msg));
  }
  var res = resolveNodeValue(doc, node);
  if (res) {
    res.range = [node.range.start, node.range.end];
    if (doc.options.keepCstNodes)
      res.cstNode = node;
    if (doc.options.keepNodeTypes)
      res.type = node.type;
    var cb = comments.before.join("\n");
    if (cb) {
      res.commentBefore = res.commentBefore ? "".concat(res.commentBefore, "\n").concat(cb) : cb;
    }
    var ca = comments.after.join("\n");
    if (ca)
      res.comment = res.comment ? "".concat(res.comment, "\n").concat(ca) : ca;
  }
  return node.resolved = res;
}
function resolveMap(doc, cst) {
  if (cst.type !== Type.MAP && cst.type !== Type.FLOW_MAP) {
    var msg = "A ".concat(cst.type, " node cannot be resolved as a mapping");
    doc.errors.push(new YAMLSyntaxError(cst, msg));
    return null;
  }
  var _ref = cst.type === Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst), comments = _ref.comments, items = _ref.items;
  var map4 = new YAMLMap();
  map4.items = items;
  resolveComments(map4, comments);
  var hasCollectionKey = false;
  for (var i = 0; i < items.length; ++i) {
    var iKey = items[i].key;
    if (iKey instanceof Collection2)
      hasCollectionKey = true;
    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
      items[i] = new Merge(items[i]);
      var sources = items[i].value.items;
      var error = null;
      sources.some(function(node) {
        if (node instanceof Alias2) {
          var type3 = node.source.type;
          if (type3 === Type.MAP || type3 === Type.FLOW_MAP)
            return false;
          return error = "Merge nodes aliases can only point to maps";
        }
        return error = "Merge nodes can only have Alias nodes as values";
      });
      if (error)
        doc.errors.push(new YAMLSemanticError(cst, error));
    } else {
      for (var j = i + 1; j < items.length; ++j) {
        var jKey = items[j].key;
        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
          var _msg = 'Map keys must be unique; "'.concat(iKey, '" is repeated');
          doc.errors.push(new YAMLSemanticError(cst, _msg));
          break;
        }
      }
    }
  }
  if (hasCollectionKey && !doc.options.mapAsMap) {
    var warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    doc.warnings.push(new YAMLWarning(cst, warn2));
  }
  cst.resolved = map4;
  return map4;
}
function resolvePairComment(item, pair3) {
  if (!valueHasPairComment(item))
    return;
  var comment = item.getPropValue(0, Char.COMMENT, true);
  var found = false;
  var cb = pair3.value.commentBefore;
  if (cb && cb.startsWith(comment)) {
    pair3.value.commentBefore = cb.substr(comment.length + 1);
    found = true;
  } else {
    var cc = pair3.value.comment;
    if (!item.node && cc && cc.startsWith(comment)) {
      pair3.value.comment = cc.substr(comment.length + 1);
      found = true;
    }
  }
  if (found)
    pair3.comment = comment;
}
function resolveBlockMapItems(doc, cst) {
  var comments = [];
  var items = [];
  var key = void 0;
  var keyStart = null;
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    switch (item.type) {
      case Type.BLANK_LINE:
        comments.push({
          afterKey: !!key,
          before: items.length
        });
        break;
      case Type.COMMENT:
        comments.push({
          afterKey: !!key,
          before: items.length,
          comment: item.comment
        });
        break;
      case Type.MAP_KEY:
        if (key !== void 0)
          items.push(new Pair(key));
        if (item.error)
          doc.errors.push(item.error);
        key = resolveNode(doc, item.node);
        keyStart = null;
        break;
      case Type.MAP_VALUE:
        {
          if (key === void 0)
            key = null;
          if (item.error)
            doc.errors.push(item.error);
          if (!item.context.atLineStart && item.node && item.node.type === Type.MAP && !item.node.context.atLineStart) {
            var msg = "Nested mappings are not allowed in compact mappings";
            doc.errors.push(new YAMLSemanticError(item.node, msg));
          }
          var valueNode = item.node;
          if (!valueNode && item.props.length > 0) {
            valueNode = new PlainValue(Type.PLAIN, []);
            valueNode.context = {
              parent: item,
              src: item.context.src
            };
            var pos = item.range.start + 1;
            valueNode.range = {
              start: pos,
              end: pos
            };
            valueNode.valueRange = {
              start: pos,
              end: pos
            };
            if (typeof item.range.origStart === "number") {
              var origPos = item.range.origStart + 1;
              valueNode.range.origStart = valueNode.range.origEnd = origPos;
              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
            }
          }
          var pair3 = new Pair(key, resolveNode(doc, valueNode));
          resolvePairComment(item, pair3);
          items.push(pair3);
          if (key && typeof keyStart === "number") {
            if (item.range.start > keyStart + 1024)
              doc.errors.push(getLongKeyError(cst, key));
          }
          key = void 0;
          keyStart = null;
        }
        break;
      default:
        if (key !== void 0)
          items.push(new Pair(key));
        key = resolveNode(doc, item);
        keyStart = item.range.start;
        if (item.error)
          doc.errors.push(item.error);
        next:
          for (var j = i + 1; ; ++j) {
            var nextItem = cst.items[j];
            switch (nextItem && nextItem.type) {
              case Type.BLANK_LINE:
              case Type.COMMENT:
                continue next;
              case Type.MAP_VALUE:
                break next;
              default: {
                var _msg2 = "Implicit map keys need to be followed by map values";
                doc.errors.push(new YAMLSemanticError(item, _msg2));
                break next;
              }
            }
          }
        if (item.valueRangeContainsNewline) {
          var _msg3 = "Implicit map keys need to be on a single line";
          doc.errors.push(new YAMLSemanticError(item, _msg3));
        }
    }
  }
  if (key !== void 0)
    items.push(new Pair(key));
  return {
    comments,
    items
  };
}
function resolveFlowMapItems(doc, cst) {
  var comments = [];
  var items = [];
  var key = void 0;
  var explicitKey = false;
  var next = "{";
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    if (typeof item.char === "string") {
      var char = item.char, offset = item.offset;
      if (char === "?" && key === void 0 && !explicitKey) {
        explicitKey = true;
        next = ":";
        continue;
      }
      if (char === ":") {
        if (key === void 0)
          key = null;
        if (next === ":") {
          next = ",";
          continue;
        }
      } else {
        if (explicitKey) {
          if (key === void 0 && char !== ",")
            key = null;
          explicitKey = false;
        }
        if (key !== void 0) {
          items.push(new Pair(key));
          key = void 0;
          if (char === ",") {
            next = ":";
            continue;
          }
        }
      }
      if (char === "}") {
        if (i === cst.items.length - 1)
          continue;
      } else if (char === next) {
        next = ":";
        continue;
      }
      var msg = "Flow map contains an unexpected ".concat(char);
      var err = new YAMLSyntaxError(cst, msg);
      err.offset = offset;
      doc.errors.push(err);
    } else if (item.type === Type.BLANK_LINE) {
      comments.push({
        afterKey: !!key,
        before: items.length
      });
    } else if (item.type === Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        afterKey: !!key,
        before: items.length,
        comment: item.comment
      });
    } else if (key === void 0) {
      if (next === ",")
        doc.errors.push(new YAMLSemanticError(item, "Separator , missing in flow map"));
      key = resolveNode(doc, item);
    } else {
      if (next !== ",")
        doc.errors.push(new YAMLSemanticError(item, "Indicator : missing in flow map entry"));
      items.push(new Pair(key, resolveNode(doc, item)));
      key = void 0;
      explicitKey = false;
    }
  }
  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== void 0)
    items.push(new Pair(key));
  return {
    comments,
    items
  };
}
function resolveSeq(doc, cst) {
  if (cst.type !== Type.SEQ && cst.type !== Type.FLOW_SEQ) {
    var msg = "A ".concat(cst.type, " node cannot be resolved as a sequence");
    doc.errors.push(new YAMLSyntaxError(cst, msg));
    return null;
  }
  var _ref = cst.type === Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst), comments = _ref.comments, items = _ref.items;
  var seq2 = new YAMLSeq();
  seq2.items = items;
  resolveComments(seq2, comments);
  if (!doc.options.mapAsMap && items.some(function(it) {
    return it instanceof Pair && it.key instanceof Collection2;
  })) {
    var warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    doc.warnings.push(new YAMLWarning(cst, warn2));
  }
  cst.resolved = seq2;
  return seq2;
}
function resolveBlockSeqItems(doc, cst) {
  var comments = [];
  var items = [];
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    switch (item.type) {
      case Type.BLANK_LINE:
        comments.push({
          before: items.length
        });
        break;
      case Type.COMMENT:
        comments.push({
          comment: item.comment,
          before: items.length
        });
        break;
      case Type.SEQ_ITEM:
        if (item.error)
          doc.errors.push(item.error);
        items.push(resolveNode(doc, item.node));
        if (item.hasProps) {
          var msg = "Sequence items cannot have tags or anchors before the - indicator";
          doc.errors.push(new YAMLSemanticError(item, msg));
        }
        break;
      default:
        if (item.error)
          doc.errors.push(item.error);
        doc.errors.push(new YAMLSyntaxError(item, "Unexpected ".concat(item.type, " node in sequence")));
    }
  }
  return {
    comments,
    items
  };
}
function resolveFlowSeqItems(doc, cst) {
  var comments = [];
  var items = [];
  var explicitKey = false;
  var key = void 0;
  var keyStart = null;
  var next = "[";
  var prevItem = null;
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    if (typeof item.char === "string") {
      var char = item.char, offset = item.offset;
      if (char !== ":" && (explicitKey || key !== void 0)) {
        if (explicitKey && key === void 0)
          key = next ? items.pop() : null;
        items.push(new Pair(key));
        explicitKey = false;
        key = void 0;
        keyStart = null;
      }
      if (char === next) {
        next = null;
      } else if (!next && char === "?") {
        explicitKey = true;
      } else if (next !== "[" && char === ":" && key === void 0) {
        if (next === ",") {
          key = items.pop();
          if (key instanceof Pair) {
            var msg = "Chaining flow sequence pairs is invalid";
            var err = new YAMLSemanticError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }
          if (!explicitKey && typeof keyStart === "number") {
            var keyEnd = item.range ? item.range.start : item.offset;
            if (keyEnd > keyStart + 1024)
              doc.errors.push(getLongKeyError(cst, key));
            var src = prevItem.context.src;
            for (var _i = keyStart; _i < keyEnd; ++_i) {
              if (src[_i] === "\n") {
                var _msg = "Implicit keys of flow sequence pairs need to be on a single line";
                doc.errors.push(new YAMLSemanticError(prevItem, _msg));
                break;
              }
            }
          }
        } else {
          key = null;
        }
        keyStart = null;
        explicitKey = false;
        next = null;
      } else if (next === "[" || char !== "]" || i < cst.items.length - 1) {
        var _msg2 = "Flow sequence contains an unexpected ".concat(char);
        var _err = new YAMLSyntaxError(cst, _msg2);
        _err.offset = offset;
        doc.errors.push(_err);
      }
    } else if (item.type === Type.BLANK_LINE) {
      comments.push({
        before: items.length
      });
    } else if (item.type === Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        comment: item.comment,
        before: items.length
      });
    } else {
      if (next) {
        var _msg3 = "Expected a ".concat(next, " in flow sequence");
        doc.errors.push(new YAMLSemanticError(item, _msg3));
      }
      var value2 = resolveNode(doc, item);
      if (key === void 0) {
        items.push(value2);
        prevItem = item;
      } else {
        items.push(new Pair(key, value2));
        key = void 0;
      }
      keyStart = item.range.start;
      next = ",";
    }
  }
  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== void 0)
    items.push(new Pair(key));
  return {
    comments,
    items
  };
}
var Node2, Scalar, isEmptyPath, Collection2, YAMLSeq, stringifyKey, Pair, getAliasCount, Alias2, YAMLMap, MERGE_KEY, Merge, binaryOptions, boolOptions, intOptions, nullOptions, strOptions, FOLD_FLOW, FOLD_BLOCK, FOLD_QUOTED, consumeMoreIndentedLines, getFoldOptions, containsDocumentMarker, isCollectionItem, valueHasPairComment;
var init_resolveSeq_492ab440 = __esm({
  "node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/resolveSeq-492ab440.js"() {
    init_PlainValue_b8036b75();
    Node2 = function Node3() {
      _classCallCheck(this, Node3);
    };
    Scalar = function(_Node) {
      _inherits(Scalar2, _Node);
      var _super = _createSuper(Scalar2);
      function Scalar2(value2) {
        var _this;
        _classCallCheck(this, Scalar2);
        _this = _super.call(this);
        _this.value = value2;
        return _this;
      }
      _createClass(Scalar2, [{
        key: "toJSON",
        value: function toJSON$1(arg, ctx) {
          return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
        }
      }, {
        key: "toString",
        value: function toString4() {
          return String(this.value);
        }
      }]);
      return Scalar2;
    }(Node2);
    isEmptyPath = function isEmptyPath2(path3) {
      return path3 == null || _typeof(path3) === "object" && path3[Symbol.iterator]().next().done;
    };
    Collection2 = function(_Node) {
      _inherits(Collection3, _Node);
      var _super = _createSuper(Collection3);
      function Collection3(schema) {
        var _this;
        _classCallCheck(this, Collection3);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "items", []);
        _this.schema = schema;
        return _this;
      }
      _createClass(Collection3, [{
        key: "addIn",
        value: function addIn(path3, value2) {
          if (isEmptyPath(path3))
            this.add(value2);
          else {
            var _path = _toArray(path3), key = _path[0], rest = _path.slice(1);
            var node = this.get(key, true);
            if (node instanceof Collection3)
              node.addIn(rest, value2);
            else if (node === void 0 && this.schema)
              this.set(key, collectionFromPath(this.schema, rest, value2));
            else
              throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
          }
        }
      }, {
        key: "deleteIn",
        value: function deleteIn(_ref) {
          var _ref2 = _toArray(_ref), key = _ref2[0], rest = _ref2.slice(1);
          if (rest.length === 0)
            return this.delete(key);
          var node = this.get(key, true);
          if (node instanceof Collection3)
            return node.deleteIn(rest);
          else
            throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
        }
      }, {
        key: "getIn",
        value: function getIn(_ref3, keepScalar) {
          var _ref4 = _toArray(_ref3), key = _ref4[0], rest = _ref4.slice(1);
          var node = this.get(key, true);
          if (rest.length === 0)
            return !keepScalar && node instanceof Scalar ? node.value : node;
          else
            return node instanceof Collection3 ? node.getIn(rest, keepScalar) : void 0;
        }
      }, {
        key: "hasAllNullValues",
        value: function hasAllNullValues() {
          return this.items.every(function(node) {
            if (!node || node.type !== "PAIR")
              return false;
            var n = node.value;
            return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
          });
        }
      }, {
        key: "hasIn",
        value: function hasIn3(_ref5) {
          var _ref6 = _toArray(_ref5), key = _ref6[0], rest = _ref6.slice(1);
          if (rest.length === 0)
            return this.has(key);
          var node = this.get(key, true);
          return node instanceof Collection3 ? node.hasIn(rest) : false;
        }
      }, {
        key: "setIn",
        value: function setIn(_ref7, value2) {
          var _ref8 = _toArray(_ref7), key = _ref8[0], rest = _ref8.slice(1);
          if (rest.length === 0) {
            this.set(key, value2);
          } else {
            var node = this.get(key, true);
            if (node instanceof Collection3)
              node.setIn(rest, value2);
            else if (node === void 0 && this.schema)
              this.set(key, collectionFromPath(this.schema, rest, value2));
            else
              throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
          }
        }
        // overridden in implementations
        /* istanbul ignore next */
      }, {
        key: "toJSON",
        value: function toJSON2() {
          return null;
        }
      }, {
        key: "toString",
        value: function toString4(ctx, _ref9, onComment, onChompKeep) {
          var _this2 = this;
          var blockItem = _ref9.blockItem, flowChars = _ref9.flowChars, isMap = _ref9.isMap, itemIndent = _ref9.itemIndent;
          var _ctx = ctx, indent = _ctx.indent, indentStep = _ctx.indentStep, stringify16 = _ctx.stringify;
          var inFlow = this.type === Type.FLOW_MAP || this.type === Type.FLOW_SEQ || ctx.inFlow;
          if (inFlow)
            itemIndent += indentStep;
          var allNullValues = isMap && this.hasAllNullValues();
          ctx = Object.assign({}, ctx, {
            allNullValues,
            indent: itemIndent,
            inFlow,
            type: null
          });
          var chompKeep = false;
          var hasItemWithNewLine = false;
          var nodes = this.items.reduce(function(nodes2, item, i) {
            var comment;
            if (item) {
              if (!chompKeep && item.spaceBefore)
                nodes2.push({
                  type: "comment",
                  str: ""
                });
              if (item.commentBefore)
                item.commentBefore.match(/^.*$/gm).forEach(function(line) {
                  nodes2.push({
                    type: "comment",
                    str: "#".concat(line)
                  });
                });
              if (item.comment)
                comment = item.comment;
              if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment)))
                hasItemWithNewLine = true;
            }
            chompKeep = false;
            var str2 = stringify16(item, ctx, function() {
              return comment = null;
            }, function() {
              return chompKeep = true;
            });
            if (inFlow && !hasItemWithNewLine && str2.includes("\n"))
              hasItemWithNewLine = true;
            if (inFlow && i < _this2.items.length - 1)
              str2 += ",";
            str2 = addComment(str2, itemIndent, comment);
            if (chompKeep && (comment || inFlow))
              chompKeep = false;
            nodes2.push({
              type: "item",
              str: str2
            });
            return nodes2;
          }, []);
          var str;
          if (nodes.length === 0) {
            str = flowChars.start + flowChars.end;
          } else if (inFlow) {
            var start = flowChars.start, end = flowChars.end;
            var strings = nodes.map(function(n) {
              return n.str;
            });
            if (hasItemWithNewLine || strings.reduce(function(sum2, str2) {
              return sum2 + str2.length + 2;
            }, 2) > Collection3.maxFlowStringSingleLineLength) {
              str = start;
              var _iterator = _createForOfIteratorHelper(strings), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var s = _step.value;
                  str += s ? "\n".concat(indentStep).concat(indent).concat(s) : "\n";
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              str += "\n".concat(indent).concat(end);
            } else {
              str = "".concat(start, " ").concat(strings.join(" "), " ").concat(end);
            }
          } else {
            var _strings = nodes.map(blockItem);
            str = _strings.shift();
            var _iterator2 = _createForOfIteratorHelper(_strings), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var _s = _step2.value;
                str += _s ? "\n".concat(indent).concat(_s) : "\n";
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          if (this.comment) {
            str += "\n" + this.comment.replace(/^/gm, "".concat(indent, "#"));
            if (onComment)
              onComment();
          } else if (chompKeep && onChompKeep)
            onChompKeep();
          return str;
        }
      }]);
      return Collection3;
    }(Node2);
    _defineProperty(Collection2, "maxFlowStringSingleLineLength", 60);
    YAMLSeq = function(_Collection) {
      _inherits(YAMLSeq2, _Collection);
      var _super = _createSuper(YAMLSeq2);
      function YAMLSeq2() {
        _classCallCheck(this, YAMLSeq2);
        return _super.apply(this, arguments);
      }
      _createClass(YAMLSeq2, [{
        key: "add",
        value: function add3(value2) {
          this.items.push(value2);
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          var idx = asItemIndex(key);
          if (typeof idx !== "number")
            return false;
          var del = this.items.splice(idx, 1);
          return del.length > 0;
        }
      }, {
        key: "get",
        value: function get(key, keepScalar) {
          var idx = asItemIndex(key);
          if (typeof idx !== "number")
            return void 0;
          var it = this.items[idx];
          return !keepScalar && it instanceof Scalar ? it.value : it;
        }
      }, {
        key: "has",
        value: function has3(key) {
          var idx = asItemIndex(key);
          return typeof idx === "number" && idx < this.items.length;
        }
      }, {
        key: "set",
        value: function set4(key, value2) {
          var idx = asItemIndex(key);
          if (typeof idx !== "number")
            throw new Error("Expected a valid index, not ".concat(key, "."));
          this.items[idx] = value2;
        }
      }, {
        key: "toJSON",
        value: function toJSON$1(_, ctx) {
          var seq2 = [];
          if (ctx && ctx.onCreate)
            ctx.onCreate(seq2);
          var i = 0;
          var _iterator = _createForOfIteratorHelper(this.items), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var item = _step.value;
              seq2.push(toJSON(item, String(i++), ctx));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return seq2;
        }
      }, {
        key: "toString",
        value: function toString4(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          return _get(_getPrototypeOf(YAMLSeq2.prototype), "toString", this).call(this, ctx, {
            blockItem: function blockItem(n) {
              return n.type === "comment" ? n.str : "- ".concat(n.str);
            },
            flowChars: {
              start: "[",
              end: "]"
            },
            isMap: false,
            itemIndent: (ctx.indent || "") + "  "
          }, onComment, onChompKeep);
        }
      }]);
      return YAMLSeq2;
    }(Collection2);
    stringifyKey = function stringifyKey2(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (_typeof(jsKey) !== "object")
        return String(jsKey);
      if (key instanceof Node2 && ctx && ctx.doc)
        return key.toString({
          anchors: /* @__PURE__ */ Object.create(null),
          doc: ctx.doc,
          indent: "",
          indentStep: ctx.indentStep,
          inFlow: true,
          inStringifyKey: true,
          stringify: ctx.stringify
        });
      return JSON.stringify(jsKey);
    };
    Pair = function(_Node) {
      _inherits(Pair2, _Node);
      var _super = _createSuper(Pair2);
      function Pair2(key) {
        var _this;
        var value2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        _classCallCheck(this, Pair2);
        _this = _super.call(this);
        _this.key = key;
        _this.value = value2;
        _this.type = Pair2.Type.PAIR;
        return _this;
      }
      _createClass(Pair2, [{
        key: "commentBefore",
        get: function get() {
          return this.key instanceof Node2 ? this.key.commentBefore : void 0;
        },
        set: function set4(cb) {
          if (this.key == null)
            this.key = new Scalar(null);
          if (this.key instanceof Node2)
            this.key.commentBefore = cb;
          else {
            var msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
            throw new Error(msg);
          }
        }
      }, {
        key: "addToJSMap",
        value: function addToJSMap(ctx, map4) {
          var key = toJSON(this.key, "", ctx);
          if (map4 instanceof Map) {
            var value2 = toJSON(this.value, key, ctx);
            map4.set(key, value2);
          } else if (map4 instanceof Set) {
            map4.add(key);
          } else {
            var stringKey = stringifyKey(this.key, key, ctx);
            var _value = toJSON(this.value, stringKey, ctx);
            if (stringKey in map4)
              Object.defineProperty(map4, stringKey, {
                value: _value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            else
              map4[stringKey] = _value;
          }
          return map4;
        }
      }, {
        key: "toJSON",
        value: function toJSON2(_, ctx) {
          var pair3 = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
          return this.addToJSMap(ctx, pair3);
        }
      }, {
        key: "toString",
        value: function toString4(ctx, onComment, onChompKeep) {
          if (!ctx || !ctx.doc)
            return JSON.stringify(this);
          var _ctx$doc$options = ctx.doc.options, indentSize = _ctx$doc$options.indent, indentSeq = _ctx$doc$options.indentSeq, simpleKeys = _ctx$doc$options.simpleKeys;
          var key = this.key, value2 = this.value;
          var keyComment = key instanceof Node2 && key.comment;
          if (simpleKeys) {
            if (keyComment) {
              throw new Error("With simple keys, key nodes cannot have comments");
            }
            if (key instanceof Collection2) {
              var msg = "With simple keys, collection cannot be used as a key value";
              throw new Error(msg);
            }
          }
          var explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node2 ? key instanceof Collection2 || key.type === Type.BLOCK_FOLDED || key.type === Type.BLOCK_LITERAL : _typeof(key) === "object"));
          var _ctx = ctx, doc = _ctx.doc, indent = _ctx.indent, indentStep = _ctx.indentStep, stringify16 = _ctx.stringify;
          ctx = Object.assign({}, ctx, {
            implicitKey: !explicitKey,
            indent: indent + indentStep
          });
          var chompKeep = false;
          var str = stringify16(key, ctx, function() {
            return keyComment = null;
          }, function() {
            return chompKeep = true;
          });
          str = addComment(str, ctx.indent, keyComment);
          if (!explicitKey && str.length > 1024) {
            if (simpleKeys)
              throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
            explicitKey = true;
          }
          if (ctx.allNullValues && !simpleKeys) {
            if (this.comment) {
              str = addComment(str, ctx.indent, this.comment);
              if (onComment)
                onComment();
            } else if (chompKeep && !keyComment && onChompKeep)
              onChompKeep();
            return ctx.inFlow && !explicitKey ? str : "? ".concat(str);
          }
          str = explicitKey ? "? ".concat(str, "\n").concat(indent, ":") : "".concat(str, ":");
          if (this.comment) {
            str = addComment(str, ctx.indent, this.comment);
            if (onComment)
              onComment();
          }
          var vcb = "";
          var valueComment = null;
          if (value2 instanceof Node2) {
            if (value2.spaceBefore)
              vcb = "\n";
            if (value2.commentBefore) {
              var cs = value2.commentBefore.replace(/^/gm, "".concat(ctx.indent, "#"));
              vcb += "\n".concat(cs);
            }
            valueComment = value2.comment;
          } else if (value2 && _typeof(value2) === "object") {
            value2 = doc.schema.createNode(value2, true);
          }
          ctx.implicitKey = false;
          if (!explicitKey && !this.comment && value2 instanceof Scalar)
            ctx.indentAtStart = str.length + 1;
          chompKeep = false;
          if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value2 instanceof YAMLSeq && value2.type !== Type.FLOW_SEQ && !value2.tag && !doc.anchors.getName(value2)) {
            ctx.indent = ctx.indent.substr(2);
          }
          var valueStr = stringify16(value2, ctx, function() {
            return valueComment = null;
          }, function() {
            return chompKeep = true;
          });
          var ws2 = " ";
          if (vcb || this.comment) {
            ws2 = "".concat(vcb, "\n").concat(ctx.indent);
          } else if (!explicitKey && value2 instanceof Collection2) {
            var flow = valueStr[0] === "[" || valueStr[0] === "{";
            if (!flow || valueStr.includes("\n"))
              ws2 = "\n".concat(ctx.indent);
          } else if (valueStr[0] === "\n")
            ws2 = "";
          if (chompKeep && !valueComment && onChompKeep)
            onChompKeep();
          return addComment(str + ws2 + valueStr, ctx.indent, valueComment);
        }
      }]);
      return Pair2;
    }(Node2);
    _defineProperty(Pair, "Type", {
      PAIR: "PAIR",
      MERGE_PAIR: "MERGE_PAIR"
    });
    getAliasCount = function getAliasCount2(node, anchors) {
      if (node instanceof Alias2) {
        var anchor = anchors.get(node.source);
        return anchor.count * anchor.aliasCount;
      } else if (node instanceof Collection2) {
        var count = 0;
        var _iterator = _createForOfIteratorHelper(node.items), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var item = _step.value;
            var c = getAliasCount2(item, anchors);
            if (c > count)
              count = c;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return count;
      } else if (node instanceof Pair) {
        var kc = getAliasCount2(node.key, anchors);
        var vc = getAliasCount2(node.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    };
    Alias2 = function(_Node) {
      _inherits(Alias3, _Node);
      var _super = _createSuper(Alias3);
      function Alias3(source) {
        var _this;
        _classCallCheck(this, Alias3);
        _this = _super.call(this);
        _this.source = source;
        _this.type = Type.ALIAS;
        return _this;
      }
      _createClass(Alias3, [{
        key: "tag",
        set: function set4(t) {
          throw new Error("Alias nodes cannot have tags");
        }
      }, {
        key: "toJSON",
        value: function toJSON$1(arg, ctx) {
          if (!ctx)
            return toJSON(this.source, arg, ctx);
          var anchors = ctx.anchors, maxAliasCount = ctx.maxAliasCount;
          var anchor = anchors.get(this.source);
          if (!anchor || anchor.res === void 0) {
            var msg = "This should not happen: Alias anchor was not resolved?";
            if (this.cstNode)
              throw new YAMLReferenceError(this.cstNode, msg);
            else
              throw new ReferenceError(msg);
          }
          if (maxAliasCount >= 0) {
            anchor.count += 1;
            if (anchor.aliasCount === 0)
              anchor.aliasCount = getAliasCount(this.source, anchors);
            if (anchor.count * anchor.aliasCount > maxAliasCount) {
              var _msg = "Excessive alias count indicates a resource exhaustion attack";
              if (this.cstNode)
                throw new YAMLReferenceError(this.cstNode, _msg);
              else
                throw new ReferenceError(_msg);
            }
          }
          return anchor.res;
        }
        // Only called when stringifying an alias mapping key while constructing
        // Object output.
      }, {
        key: "toString",
        value: function toString4(ctx) {
          return Alias3.stringify(this, ctx);
        }
      }], [{
        key: "stringify",
        value: function stringify16(_ref, _ref2) {
          var range3 = _ref.range, source = _ref.source;
          var anchors = _ref2.anchors, doc = _ref2.doc, implicitKey = _ref2.implicitKey, inStringifyKey = _ref2.inStringifyKey;
          var anchor = Object.keys(anchors).find(function(a) {
            return anchors[a] === source;
          });
          if (!anchor && inStringifyKey)
            anchor = doc.anchors.getName(source) || doc.anchors.newName();
          if (anchor)
            return "*".concat(anchor).concat(implicitKey ? " " : "");
          var msg = doc.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
          throw new Error("".concat(msg, " [").concat(range3, "]"));
        }
      }]);
      return Alias3;
    }(Node2);
    _defineProperty(Alias2, "default", true);
    YAMLMap = function(_Collection) {
      _inherits(YAMLMap2, _Collection);
      var _super = _createSuper(YAMLMap2);
      function YAMLMap2() {
        _classCallCheck(this, YAMLMap2);
        return _super.apply(this, arguments);
      }
      _createClass(YAMLMap2, [{
        key: "add",
        value: function add3(pair3, overwrite) {
          if (!pair3)
            pair3 = new Pair(pair3);
          else if (!(pair3 instanceof Pair))
            pair3 = new Pair(pair3.key || pair3, pair3.value);
          var prev = findPair(this.items, pair3.key);
          var sortEntries = this.schema && this.schema.sortMapEntries;
          if (prev) {
            if (overwrite)
              prev.value = pair3.value;
            else
              throw new Error("Key ".concat(pair3.key, " already set"));
          } else if (sortEntries) {
            var i = this.items.findIndex(function(item) {
              return sortEntries(pair3, item) < 0;
            });
            if (i === -1)
              this.items.push(pair3);
            else
              this.items.splice(i, 0, pair3);
          } else {
            this.items.push(pair3);
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          var it = findPair(this.items, key);
          if (!it)
            return false;
          var del = this.items.splice(this.items.indexOf(it), 1);
          return del.length > 0;
        }
      }, {
        key: "get",
        value: function get(key, keepScalar) {
          var it = findPair(this.items, key);
          var node = it && it.value;
          return !keepScalar && node instanceof Scalar ? node.value : node;
        }
      }, {
        key: "has",
        value: function has3(key) {
          return !!findPair(this.items, key);
        }
      }, {
        key: "set",
        value: function set4(key, value2) {
          this.add(new Pair(key, value2), true);
        }
        /**
         * @param {*} arg ignored
         * @param {*} ctx Conversion context, originally set in Document#toJSON()
         * @param {Class} Type If set, forces the returned collection type
         * @returns {*} Instance of Type, Map, or Object
         */
      }, {
        key: "toJSON",
        value: function toJSON2(_, ctx, Type2) {
          var map4 = Type2 ? new Type2() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
          if (ctx && ctx.onCreate)
            ctx.onCreate(map4);
          var _iterator2 = _createForOfIteratorHelper(this.items), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var item = _step2.value;
              item.addToJSMap(ctx, map4);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          return map4;
        }
      }, {
        key: "toString",
        value: function toString4(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          var _iterator3 = _createForOfIteratorHelper(this.items), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var item = _step3.value;
              if (!(item instanceof Pair))
                throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(item), " instead"));
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          return _get(_getPrototypeOf(YAMLMap2.prototype), "toString", this).call(this, ctx, {
            blockItem: function blockItem(n) {
              return n.str;
            },
            flowChars: {
              start: "{",
              end: "}"
            },
            isMap: true,
            itemIndent: ctx.indent || ""
          }, onComment, onChompKeep);
        }
      }]);
      return YAMLMap2;
    }(Collection2);
    MERGE_KEY = "<<";
    Merge = function(_Pair) {
      _inherits(Merge2, _Pair);
      var _super = _createSuper(Merge2);
      function Merge2(pair3) {
        var _this;
        _classCallCheck(this, Merge2);
        if (pair3 instanceof Pair) {
          var seq2 = pair3.value;
          if (!(seq2 instanceof YAMLSeq)) {
            seq2 = new YAMLSeq();
            seq2.items.push(pair3.value);
            seq2.range = pair3.value.range;
          }
          _this = _super.call(this, pair3.key, seq2);
          _this.range = pair3.range;
        } else {
          _this = _super.call(this, new Scalar(MERGE_KEY), new YAMLSeq());
        }
        _this.type = Pair.Type.MERGE_PAIR;
        return _possibleConstructorReturn(_this);
      }
      _createClass(Merge2, [{
        key: "addToJSMap",
        value: function addToJSMap(ctx, map4) {
          var _iterator = _createForOfIteratorHelper(this.value.items), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var source = _step.value.source;
              if (!(source instanceof YAMLMap))
                throw new Error("Merge sources must be maps");
              var srcMap = source.toJSON(null, ctx, Map);
              var _iterator2 = _createForOfIteratorHelper(srcMap), _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                  var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], value2 = _step2$value[1];
                  if (map4 instanceof Map) {
                    if (!map4.has(key))
                      map4.set(key, value2);
                  } else if (map4 instanceof Set) {
                    map4.add(key);
                  } else if (!Object.prototype.hasOwnProperty.call(map4, key)) {
                    Object.defineProperty(map4, key, {
                      value: value2,
                      writable: true,
                      enumerable: true,
                      configurable: true
                    });
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return map4;
        }
      }, {
        key: "toString",
        value: function toString4(ctx, onComment) {
          var seq2 = this.value;
          if (seq2.items.length > 1)
            return _get(_getPrototypeOf(Merge2.prototype), "toString", this).call(this, ctx, onComment);
          this.value = seq2.items[0];
          var str = _get(_getPrototypeOf(Merge2.prototype), "toString", this).call(this, ctx, onComment);
          this.value = seq2;
          return str;
        }
      }]);
      return Merge2;
    }(Pair);
    binaryOptions = {
      defaultType: Type.BLOCK_LITERAL,
      lineWidth: 76
    };
    boolOptions = {
      trueStr: "true",
      falseStr: "false"
    };
    intOptions = {
      asBigInt: false
    };
    nullOptions = {
      nullStr: "null"
    };
    strOptions = {
      defaultType: Type.PLAIN,
      doubleQuoted: {
        jsonEncoding: false,
        minMultiLineLength: 40
      },
      fold: {
        lineWidth: 80,
        minContentWidth: 20
      }
    };
    FOLD_FLOW = "flow";
    FOLD_BLOCK = "block";
    FOLD_QUOTED = "quoted";
    consumeMoreIndentedLines = function consumeMoreIndentedLines2(text, i) {
      var ch = text[i + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text[i += 1];
        } while (ch && ch !== "\n");
        ch = text[i + 1];
      }
      return i;
    };
    getFoldOptions = function getFoldOptions2(_ref) {
      var indentAtStart = _ref.indentAtStart;
      return indentAtStart ? Object.assign({
        indentAtStart
      }, strOptions.fold) : strOptions.fold;
    };
    containsDocumentMarker = function containsDocumentMarker2(str) {
      return /^(%|---|\.\.\.)/m.test(str);
    };
    isCollectionItem = function isCollectionItem2(node) {
      if (!node)
        return false;
      var type3 = node.type;
      return type3 === Type.MAP_KEY || type3 === Type.MAP_VALUE || type3 === Type.SEQ_ITEM;
    };
    valueHasPairComment = function valueHasPairComment2(_ref2) {
      var _ref2$context = _ref2.context, lineStart = _ref2$context.lineStart, node = _ref2$context.node, src = _ref2$context.src, props3 = _ref2.props;
      if (props3.length === 0)
        return false;
      var start = props3[0].start;
      if (node && start > node.valueRange.start)
        return false;
      if (src[start] !== Char.COMMENT)
        return false;
      for (var i = lineStart; i < start; ++i) {
        if (src[i] === "\n")
          return false;
      }
      return true;
    };
  }
});

// node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/warnings-df54cb69.js
function parsePairs(doc, cst) {
  var seq2 = resolveSeq(doc, cst);
  for (var i = 0; i < seq2.items.length; ++i) {
    var item = seq2.items[i];
    if (item instanceof Pair)
      continue;
    else if (item instanceof YAMLMap) {
      if (item.items.length > 1) {
        var msg = "Each pair must have its own sequence indicator";
        throw new YAMLSemanticError(cst, msg);
      }
      var pair3 = item.items[0] || new Pair();
      if (item.commentBefore)
        pair3.commentBefore = pair3.commentBefore ? "".concat(item.commentBefore, "\n").concat(pair3.commentBefore) : item.commentBefore;
      if (item.comment)
        pair3.comment = pair3.comment ? "".concat(item.comment, "\n").concat(pair3.comment) : item.comment;
      item = pair3;
    }
    seq2.items[i] = item instanceof Pair ? item : new Pair(item);
  }
  return seq2;
}
function createPairs(schema, iterable, ctx) {
  var pairs2 = new YAMLSeq(schema);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  var _iterator = _createForOfIteratorHelper(iterable), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var it = _step.value;
      var key = void 0, value2 = void 0;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value2 = it[1];
        } else
          throw new TypeError("Expected [key, value] tuple: ".concat(it));
      } else if (it && it instanceof Object) {
        var keys4 = Object.keys(it);
        if (keys4.length === 1) {
          key = keys4[0];
          value2 = it[key];
        } else
          throw new TypeError("Expected { key: value } tuple: ".concat(it));
      } else {
        key = it;
      }
      var pair3 = schema.createPair(key, value2, ctx);
      pairs2.items.push(pair3);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return pairs2;
}
function parseOMap(doc, cst) {
  var pairs2 = parsePairs(doc, cst);
  var seenKeys = [];
  var _iterator2 = _createForOfIteratorHelper(pairs2.items), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var key = _step2.value.key;
      if (key instanceof Scalar) {
        if (seenKeys.includes(key.value)) {
          var msg = "Ordered maps must not include duplicate keys";
          throw new YAMLSemanticError(cst, msg);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return Object.assign(new YAMLOMap(), pairs2);
}
function createOMap(schema, iterable, ctx) {
  var pairs2 = createPairs(schema, iterable, ctx);
  var omap2 = new YAMLOMap();
  omap2.items = pairs2.items;
  return omap2;
}
function parseSet(doc, cst) {
  var map4 = resolveMap(doc, cst);
  if (!map4.hasAllNullValues())
    throw new YAMLSemanticError(cst, "Set items must all have null values");
  return Object.assign(new YAMLSet(), map4);
}
function createSet(schema, iterable, ctx) {
  var set4 = new YAMLSet();
  var _iterator = _createForOfIteratorHelper(iterable), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var value2 = _step.value;
      set4.items.push(schema.createPair(value2, null, ctx));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return set4;
}
function shouldWarn(deprecation) {
  var env = typeof process !== "undefined" && process.env || {};
  if (deprecation) {
    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined")
      return !YAML_SILENCE_DEPRECATION_WARNINGS;
    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
  }
  if (typeof YAML_SILENCE_WARNINGS !== "undefined")
    return !YAML_SILENCE_WARNINGS;
  return !env.YAML_SILENCE_WARNINGS;
}
function warn(warning, type3) {
  if (shouldWarn(false)) {
    var emit = typeof process !== "undefined" && process.emitWarning;
    if (emit)
      emit(warning, type3);
    else {
      console.warn(type3 ? "".concat(type3, ": ").concat(warning) : warning);
    }
  }
}
function warnOptionDeprecation(name, alternative) {
  if (!warned[name] && shouldWarn(true)) {
    warned[name] = true;
    var msg = "The option '".concat(name, "' will be removed in a future release");
    msg += alternative ? ", use '".concat(alternative, "' instead.") : ".";
    warn(msg, "DeprecationWarning");
  }
}
var binary, pairs, YAMLOMap, omap, YAMLSet, set, parseSexagesimal, stringifySexagesimal, intTime, floatTime, timestamp, warned;
var init_warnings_df54cb69 = __esm({
  "node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/warnings-df54cb69.js"() {
    init_PlainValue_b8036b75();
    init_resolveSeq_492ab440();
    binary = {
      identify: function identify(value2) {
        return value2 instanceof Uint8Array;
      },
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve: function resolve(doc, node) {
        var src = resolveString(doc, node);
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          var str = atob(src.replace(/[\n\r]/g, ""));
          var buffer = new Uint8Array(str.length);
          for (var i = 0; i < str.length; ++i) {
            buffer[i] = str.charCodeAt(i);
          }
          return buffer;
        } else {
          var msg = "This environment does not support reading binary tags; either Buffer or atob is required";
          doc.errors.push(new YAMLReferenceError(node, msg));
          return null;
        }
      },
      options: binaryOptions,
      stringify: function stringify(_ref, ctx, onComment, onChompKeep) {
        var comment = _ref.comment, type3 = _ref.type, value2 = _ref.value;
        var src;
        if (typeof Buffer === "function") {
          src = value2 instanceof Buffer ? value2.toString("base64") : Buffer.from(value2.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          var s = "";
          for (var i = 0; i < value2.length; ++i) {
            s += String.fromCharCode(value2[i]);
          }
          src = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type3)
          type3 = binaryOptions.defaultType;
        if (type3 === Type.QUOTE_DOUBLE) {
          value2 = src;
        } else {
          var lineWidth = binaryOptions.lineWidth;
          var n = Math.ceil(src.length / lineWidth);
          var lines = new Array(n);
          for (var _i = 0, o3 = 0; _i < n; ++_i, o3 += lineWidth) {
            lines[_i] = src.substr(o3, lineWidth);
          }
          value2 = lines.join(type3 === Type.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString({
          comment,
          type: type3,
          value: value2
        }, ctx, onComment, onChompKeep);
      }
    };
    pairs = {
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: parsePairs,
      createNode: createPairs
    };
    YAMLOMap = function(_YAMLSeq) {
      _inherits(YAMLOMap2, _YAMLSeq);
      var _super = _createSuper(YAMLOMap2);
      function YAMLOMap2() {
        var _this;
        _classCallCheck(this, YAMLOMap2);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "add", YAMLMap.prototype.add.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "delete", YAMLMap.prototype.delete.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "get", YAMLMap.prototype.get.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "has", YAMLMap.prototype.has.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "set", YAMLMap.prototype.set.bind(_assertThisInitialized(_this)));
        _this.tag = YAMLOMap2.tag;
        return _this;
      }
      _createClass(YAMLOMap2, [{
        key: "toJSON",
        value: function toJSON$1(_, ctx) {
          var map4 = /* @__PURE__ */ new Map();
          if (ctx && ctx.onCreate)
            ctx.onCreate(map4);
          var _iterator = _createForOfIteratorHelper(this.items), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var pair3 = _step.value;
              var key = void 0, value2 = void 0;
              if (pair3 instanceof Pair) {
                key = toJSON(pair3.key, "", ctx);
                value2 = toJSON(pair3.value, key, ctx);
              } else {
                key = toJSON(pair3, "", ctx);
              }
              if (map4.has(key))
                throw new Error("Ordered maps must not include duplicate keys");
              map4.set(key, value2);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return map4;
        }
      }]);
      return YAMLOMap2;
    }(YAMLSeq);
    _defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
    omap = {
      identify: function identify2(value2) {
        return value2 instanceof Map;
      },
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve: parseOMap,
      createNode: createOMap
    };
    YAMLSet = function(_YAMLMap) {
      _inherits(YAMLSet2, _YAMLMap);
      var _super = _createSuper(YAMLSet2);
      function YAMLSet2() {
        var _this;
        _classCallCheck(this, YAMLSet2);
        _this = _super.call(this);
        _this.tag = YAMLSet2.tag;
        return _this;
      }
      _createClass(YAMLSet2, [{
        key: "add",
        value: function add3(key) {
          var pair3 = key instanceof Pair ? key : new Pair(key);
          var prev = findPair(this.items, pair3.key);
          if (!prev)
            this.items.push(pair3);
        }
      }, {
        key: "get",
        value: function get(key, keepPair) {
          var pair3 = findPair(this.items, key);
          return !keepPair && pair3 instanceof Pair ? pair3.key instanceof Scalar ? pair3.key.value : pair3.key : pair3;
        }
      }, {
        key: "set",
        value: function set4(key, value2) {
          if (typeof value2 !== "boolean")
            throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(_typeof(value2)));
          var prev = findPair(this.items, key);
          if (prev && !value2) {
            this.items.splice(this.items.indexOf(prev), 1);
          } else if (!prev && value2) {
            this.items.push(new Pair(key));
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON2(_, ctx) {
          return _get(_getPrototypeOf(YAMLSet2.prototype), "toJSON", this).call(this, _, ctx, Set);
        }
      }, {
        key: "toString",
        value: function toString4(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          if (this.hasAllNullValues())
            return _get(_getPrototypeOf(YAMLSet2.prototype), "toString", this).call(this, ctx, onComment, onChompKeep);
          else
            throw new Error("Set items must all have null values");
        }
      }]);
      return YAMLSet2;
    }(YAMLMap);
    _defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
    set = {
      identify: function identify3(value2) {
        return value2 instanceof Set;
      },
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve: parseSet,
      createNode: createSet
    };
    parseSexagesimal = function parseSexagesimal2(sign, parts) {
      var n = parts.split(":").reduce(function(n2, p) {
        return n2 * 60 + Number(p);
      }, 0);
      return sign === "-" ? -n : n;
    };
    stringifySexagesimal = function stringifySexagesimal2(_ref) {
      var value2 = _ref.value;
      if (isNaN(value2) || !isFinite(value2))
        return stringifyNumber(value2);
      var sign = "";
      if (value2 < 0) {
        sign = "-";
        value2 = Math.abs(value2);
      }
      var parts = [value2 % 60];
      if (value2 < 60) {
        parts.unshift(0);
      } else {
        value2 = Math.round((value2 - parts[0]) / 60);
        parts.unshift(value2 % 60);
        if (value2 >= 60) {
          value2 = Math.round((value2 - parts[0]) / 60);
          parts.unshift(value2);
        }
      }
      return sign + parts.map(function(n) {
        return n < 10 ? "0" + String(n) : String(n);
      }).join(":").replace(/000000\d*$/, "");
    };
    intTime = {
      identify: function identify4(value2) {
        return typeof value2 === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
      resolve: function resolve2(str, sign, parts) {
        return parseSexagesimal(sign, parts.replace(/_/g, ""));
      },
      stringify: stringifySexagesimal
    };
    floatTime = {
      identify: function identify5(value2) {
        return typeof value2 === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
      resolve: function resolve3(str, sign, parts) {
        return parseSexagesimal(sign, parts.replace(/_/g, ""));
      },
      stringify: stringifySexagesimal
    };
    timestamp = {
      identify: function identify6(value2) {
        return value2 instanceof Date;
      },
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
      resolve: function resolve4(str, year, month, day, hour, minute, second, millisec, tz) {
        if (millisec)
          millisec = (millisec + "00").substr(1, 3);
        var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
        if (tz && tz !== "Z") {
          var d = parseSexagesimal(tz[0], tz.slice(1));
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: function stringify2(_ref2) {
        var value2 = _ref2.value;
        return value2.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "");
      }
    };
    warned = {};
  }
});

// node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/Schema-e94716c8.js
function createMap(schema, obj, ctx) {
  var map4 = new YAMLMap(schema);
  if (obj instanceof Map) {
    var _iterator = _createForOfIteratorHelper(obj), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], value2 = _step$value[1];
        map4.items.push(schema.createPair(key, value2, ctx));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else if (obj && _typeof(obj) === "object") {
    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var _key = _Object$keys[_i];
      map4.items.push(schema.createPair(_key, obj[_key], ctx));
    }
  }
  if (typeof schema.sortMapEntries === "function") {
    map4.items.sort(schema.sortMapEntries);
  }
  return map4;
}
function createSeq(schema, obj, ctx) {
  var seq2 = new YAMLSeq(schema);
  if (obj && obj[Symbol.iterator]) {
    var _iterator = _createForOfIteratorHelper(obj), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var it = _step.value;
        var v = schema.createNode(it, ctx.wrapScalars, null, ctx);
        seq2.items.push(v);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return seq2;
}
function intStringify$1(node, radix, prefix) {
  var value2 = node.value;
  if (intIdentify$2(value2) && value2 >= 0)
    return prefix + value2.toString(radix);
  return stringifyNumber(node);
}
function intResolve2(sign, src, radix) {
  var str = src.replace(/_/g, "");
  if (intOptions.asBigInt) {
    switch (radix) {
      case 2:
        str = "0b".concat(str);
        break;
      case 8:
        str = "0o".concat(str);
        break;
      case 16:
        str = "0x".concat(str);
        break;
    }
    var _n = BigInt(str);
    return sign === "-" ? BigInt(-1) * _n : _n;
  }
  var n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
  var value2 = node.value;
  if (intIdentify3(value2)) {
    var str = value2.toString(radix);
    return value2 < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
function findTagObject(value2, tagName, tags2) {
  if (tagName) {
    var match3 = tags2.filter(function(t) {
      return t.tag === tagName;
    });
    var tagObj = match3.find(function(t) {
      return !t.format;
    }) || match3[0];
    if (!tagObj)
      throw new Error("Tag ".concat(tagName, " not found"));
    return tagObj;
  }
  return tags2.find(function(t) {
    return (t.identify && t.identify(value2) || t.class && value2 instanceof t.class) && !t.format;
  });
}
function createNode4(value2, tagName, ctx) {
  if (value2 instanceof Node2)
    return value2;
  var defaultPrefix = ctx.defaultPrefix, onTagObj = ctx.onTagObj, prevObjects = ctx.prevObjects, schema = ctx.schema, wrapScalars = ctx.wrapScalars;
  if (tagName && tagName.startsWith("!!"))
    tagName = defaultPrefix + tagName.slice(2);
  var tagObj = findTagObject(value2, tagName, schema.tags);
  if (!tagObj) {
    if (typeof value2.toJSON === "function")
      value2 = value2.toJSON();
    if (!value2 || _typeof(value2) !== "object")
      return wrapScalars ? new Scalar(value2) : value2;
    tagObj = value2 instanceof Map ? map : value2[Symbol.iterator] ? seq : map;
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  var obj = {
    value: void 0,
    node: void 0
  };
  if (value2 && _typeof(value2) === "object" && prevObjects) {
    var prev = prevObjects.get(value2);
    if (prev) {
      var alias = new Alias2(prev);
      ctx.aliasNodes.push(alias);
      return alias;
    }
    obj.value = value2;
    prevObjects.set(value2, obj);
  }
  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value2, ctx) : wrapScalars ? new Scalar(value2) : value2;
  if (tagName && obj.node instanceof Node2)
    obj.node.tag = tagName;
  return obj.node;
}
function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
  var tags2 = schemas2[schemaId.replace(/\W/g, "")];
  if (!tags2) {
    var keys4 = Object.keys(schemas2).map(function(key) {
      return JSON.stringify(key);
    }).join(", ");
    throw new Error('Unknown schema "'.concat(schemaId, '"; use one of ').concat(keys4));
  }
  if (Array.isArray(customTags)) {
    var _iterator = _createForOfIteratorHelper(customTags), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var tag = _step.value;
        tags2 = tags2.concat(tag);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else if (typeof customTags === "function") {
    tags2 = customTags(tags2.slice());
  }
  for (var i = 0; i < tags2.length; ++i) {
    var _tag = tags2[i];
    if (typeof _tag === "string") {
      var tagObj = knownTags[_tag];
      if (!tagObj) {
        var _keys = Object.keys(knownTags).map(function(key) {
          return JSON.stringify(key);
        }).join(", ");
        throw new Error('Unknown custom tag "'.concat(_tag, '"; use one of ').concat(_keys));
      }
      tags2[i] = tagObj;
    }
  }
  return tags2;
}
var map, seq, string, failsafe, intIdentify$2, intResolve$1, nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj, core, intIdentify$1, stringifyJSON, json, boolStringify, intIdentify3, yaml11, schemas, tags, sortMapEntriesByKey, Schema;
var init_Schema_e94716c8 = __esm({
  "node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/Schema-e94716c8.js"() {
    init_PlainValue_b8036b75();
    init_resolveSeq_492ab440();
    init_warnings_df54cb69();
    map = {
      createNode: createMap,
      default: true,
      nodeClass: YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: resolveMap
    };
    seq = {
      createNode: createSeq,
      default: true,
      nodeClass: YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: resolveSeq
    };
    string = {
      identify: function identify7(value2) {
        return typeof value2 === "string";
      },
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveString,
      stringify: function stringify3(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
      },
      options: strOptions
    };
    failsafe = [map, seq, string];
    intIdentify$2 = function intIdentify(value2) {
      return typeof value2 === "bigint" || Number.isInteger(value2);
    };
    intResolve$1 = function intResolve(src, part, radix) {
      return intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
    };
    nullObj = {
      identify: function identify8(value2) {
        return value2 == null;
      },
      createNode: function createNode(schema, value2, ctx) {
        return ctx.wrapScalars ? new Scalar(null) : null;
      },
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: function resolve5() {
        return null;
      },
      options: nullOptions,
      stringify: function stringify4() {
        return nullOptions.nullStr;
      }
    };
    boolObj = {
      identify: function identify9(value2) {
        return typeof value2 === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: function resolve6(str) {
        return str[0] === "t" || str[0] === "T";
      },
      options: boolOptions,
      stringify: function stringify5(_ref) {
        var value2 = _ref.value;
        return value2 ? boolOptions.trueStr : boolOptions.falseStr;
      }
    };
    octObj = {
      identify: function identify10(value2) {
        return intIdentify$2(value2) && value2 >= 0;
      },
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o([0-7]+)$/,
      resolve: function resolve7(str, oct) {
        return intResolve$1(str, oct, 8);
      },
      options: intOptions,
      stringify: function stringify6(node) {
        return intStringify$1(node, 8, "0o");
      }
    };
    intObj = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: function resolve8(str) {
        return intResolve$1(str, str, 10);
      },
      options: intOptions,
      stringify: stringifyNumber
    };
    hexObj = {
      identify: function identify11(value2) {
        return intIdentify$2(value2) && value2 >= 0;
      },
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x([0-9a-fA-F]+)$/,
      resolve: function resolve9(str, hex) {
        return intResolve$1(str, hex, 16);
      },
      options: intOptions,
      stringify: function stringify7(node) {
        return intStringify$1(node, 16, "0x");
      }
    };
    nanObj = {
      identify: function identify12(value2) {
        return typeof value2 === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: function resolve10(str, nan) {
        return nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
      },
      stringify: stringifyNumber
    };
    expObj = {
      identify: function identify13(value2) {
        return typeof value2 === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: function resolve11(str) {
        return parseFloat(str);
      },
      stringify: function stringify8(_ref2) {
        var value2 = _ref2.value;
        return Number(value2).toExponential();
      }
    };
    floatObj = {
      identify: function identify14(value2) {
        return typeof value2 === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
      resolve: function resolve12(str, frac1, frac2) {
        var frac = frac1 || frac2;
        var node = new Scalar(parseFloat(str));
        if (frac && frac[frac.length - 1] === "0")
          node.minFractionDigits = frac.length;
        return node;
      },
      stringify: stringifyNumber
    };
    core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
    intIdentify$1 = function intIdentify2(value2) {
      return typeof value2 === "bigint" || Number.isInteger(value2);
    };
    stringifyJSON = function stringifyJSON2(_ref) {
      var value2 = _ref.value;
      return JSON.stringify(value2);
    };
    json = [map, seq, {
      identify: function identify15(value2) {
        return typeof value2 === "string";
      },
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveString,
      stringify: stringifyJSON
    }, {
      identify: function identify16(value2) {
        return value2 == null;
      },
      createNode: function createNode2(schema, value2, ctx) {
        return ctx.wrapScalars ? new Scalar(null) : null;
      },
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: function resolve13() {
        return null;
      },
      stringify: stringifyJSON
    }, {
      identify: function identify17(value2) {
        return typeof value2 === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: function resolve14(str) {
        return str === "true";
      },
      stringify: stringifyJSON
    }, {
      identify: intIdentify$1,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: function resolve15(str) {
        return intOptions.asBigInt ? BigInt(str) : parseInt(str, 10);
      },
      stringify: function stringify9(_ref2) {
        var value2 = _ref2.value;
        return intIdentify$1(value2) ? value2.toString() : JSON.stringify(value2);
      }
    }, {
      identify: function identify18(value2) {
        return typeof value2 === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: function resolve16(str) {
        return parseFloat(str);
      },
      stringify: stringifyJSON
    }];
    json.scalarFallback = function(str) {
      throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(str)));
    };
    boolStringify = function boolStringify2(_ref) {
      var value2 = _ref.value;
      return value2 ? boolOptions.trueStr : boolOptions.falseStr;
    };
    intIdentify3 = function intIdentify4(value2) {
      return typeof value2 === "bigint" || Number.isInteger(value2);
    };
    yaml11 = failsafe.concat([{
      identify: function identify19(value2) {
        return value2 == null;
      },
      createNode: function createNode3(schema, value2, ctx) {
        return ctx.wrapScalars ? new Scalar(null) : null;
      },
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: function resolve17() {
        return null;
      },
      options: nullOptions,
      stringify: function stringify10() {
        return nullOptions.nullStr;
      }
    }, {
      identify: function identify20(value2) {
        return typeof value2 === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: function resolve18() {
        return true;
      },
      options: boolOptions,
      stringify: boolStringify
    }, {
      identify: function identify21(value2) {
        return typeof value2 === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: function resolve19() {
        return false;
      },
      options: boolOptions,
      stringify: boolStringify
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^([-+]?)0b([0-1_]+)$/,
      resolve: function resolve20(str, sign, bin) {
        return intResolve2(sign, bin, 2);
      },
      stringify: function stringify11(node) {
        return intStringify(node, 2, "0b");
      }
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^([-+]?)0([0-7_]+)$/,
      resolve: function resolve21(str, sign, oct) {
        return intResolve2(sign, oct, 8);
      },
      stringify: function stringify12(node) {
        return intStringify(node, 8, "0");
      }
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^([-+]?)([0-9][0-9_]*)$/,
      resolve: function resolve22(str, sign, abs) {
        return intResolve2(sign, abs, 10);
      },
      stringify: stringifyNumber
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
      resolve: function resolve23(str, sign, hex) {
        return intResolve2(sign, hex, 16);
      },
      stringify: function stringify13(node) {
        return intStringify(node, 16, "0x");
      }
    }, {
      identify: function identify22(value2) {
        return typeof value2 === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: function resolve24(str, nan) {
        return nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
      },
      stringify: stringifyNumber
    }, {
      identify: function identify23(value2) {
        return typeof value2 === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: function resolve25(str) {
        return parseFloat(str.replace(/_/g, ""));
      },
      stringify: function stringify14(_ref2) {
        var value2 = _ref2.value;
        return Number(value2).toExponential();
      }
    }, {
      identify: function identify24(value2) {
        return typeof value2 === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
      resolve: function resolve26(str, frac) {
        var node = new Scalar(parseFloat(str.replace(/_/g, "")));
        if (frac) {
          var f = frac.replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber
    }], binary, omap, pairs, set, intTime, floatTime, timestamp);
    schemas = {
      core,
      failsafe,
      json,
      yaml11
    };
    tags = {
      binary,
      bool: boolObj,
      float: floatObj,
      floatExp: expObj,
      floatNaN: nanObj,
      floatTime,
      int: intObj,
      intHex: hexObj,
      intOct: octObj,
      intTime,
      map,
      null: nullObj,
      omap,
      pairs,
      seq,
      set,
      timestamp
    };
    sortMapEntriesByKey = function sortMapEntriesByKey2(a, b) {
      return a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    };
    Schema = function() {
      function Schema2(_ref) {
        var customTags = _ref.customTags, merge3 = _ref.merge, schema = _ref.schema, sortMapEntries = _ref.sortMapEntries, deprecatedCustomTags = _ref.tags;
        _classCallCheck(this, Schema2);
        this.merge = !!merge3;
        this.name = schema;
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        if (!customTags && deprecatedCustomTags)
          warnOptionDeprecation("tags", "customTags");
        this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
      }
      _createClass(Schema2, [{
        key: "createNode",
        value: function createNode$1(value2, wrapScalars, tagName, ctx) {
          var baseCtx = {
            defaultPrefix: Schema2.defaultPrefix,
            schema: this,
            wrapScalars
          };
          var createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
          return createNode4(value2, tagName, createCtx);
        }
      }, {
        key: "createPair",
        value: function createPair(key, value2, ctx) {
          if (!ctx)
            ctx = {
              wrapScalars: true
            };
          var k = this.createNode(key, ctx.wrapScalars, null, ctx);
          var v = this.createNode(value2, ctx.wrapScalars, null, ctx);
          return new Pair(k, v);
        }
      }]);
      return Schema2;
    }();
    _defineProperty(Schema, "defaultPrefix", defaultTagPrefix);
    _defineProperty(Schema, "defaultTags", defaultTags);
  }
});

// node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  YAML: () => YAML
});
function stringifyTag(doc, tag) {
  if ((doc.version || doc.options.version) === "1.0") {
    var priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
    if (priv)
      return "!" + priv[1];
    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
    return vocab ? "!".concat(vocab[1], "/").concat(vocab[2]) : "!".concat(tag.replace(/^tag:/, ""));
  }
  var p = doc.tagPrefixes.find(function(p2) {
    return tag.indexOf(p2.prefix) === 0;
  });
  if (!p) {
    var dtp = doc.getDefaults().tagPrefixes;
    p = dtp && dtp.find(function(p2) {
      return tag.indexOf(p2.prefix) === 0;
    });
  }
  if (!p)
    return tag[0] === "!" ? tag : "!<".concat(tag, ">");
  var suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, function(ch) {
    return {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    }[ch];
  });
  return p.handle + suffix;
}
function getTagObject(tags2, item) {
  if (item instanceof Alias2)
    return Alias2;
  if (item.tag) {
    var match3 = tags2.filter(function(t) {
      return t.tag === item.tag;
    });
    if (match3.length > 0)
      return match3.find(function(t) {
        return t.format === item.format;
      }) || match3[0];
  }
  var tagObj, obj;
  if (item instanceof Scalar) {
    obj = item.value;
    var _match = tags2.filter(function(t) {
      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;
    });
    tagObj = _match.find(function(t) {
      return t.format === item.format;
    }) || _match.find(function(t) {
      return !t.format;
    });
  } else {
    obj = item;
    tagObj = tags2.find(function(t) {
      return t.nodeClass && obj instanceof t.nodeClass;
    });
  }
  if (!tagObj) {
    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);
    throw new Error("Tag not resolved for ".concat(name, " value"));
  }
  return tagObj;
}
function stringifyProps(node, tagObj, _ref) {
  var anchors = _ref.anchors, doc = _ref.doc;
  var props3 = [];
  var anchor = doc.anchors.getName(node);
  if (anchor) {
    anchors[anchor] = node;
    props3.push("&".concat(anchor));
  }
  if (node.tag) {
    props3.push(stringifyTag(doc, node.tag));
  } else if (!tagObj.default) {
    props3.push(stringifyTag(doc, tagObj.tag));
  }
  return props3.join(" ");
}
function stringify$1(item, ctx, onComment, onChompKeep) {
  var _ctx$doc = ctx.doc, anchors = _ctx$doc.anchors, schema = _ctx$doc.schema;
  var tagObj;
  if (!(item instanceof Node2)) {
    var createCtx = {
      aliasNodes: [],
      onTagObj: function onTagObj(o3) {
        return tagObj = o3;
      },
      prevObjects: /* @__PURE__ */ new Map()
    };
    item = schema.createNode(item, true, null, createCtx);
    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var alias = _step.value;
        alias.source = alias.source.node;
        var name = anchors.getName(alias.source);
        if (!name) {
          name = anchors.newName();
          anchors.map[name] = alias.source;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  if (item instanceof Pair)
    return item.toString(ctx, onComment, onChompKeep);
  if (!tagObj)
    tagObj = getTagObject(schema.tags, item);
  var props3 = stringifyProps(item, tagObj, ctx);
  if (props3.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart || 0) + props3.length + 1;
  var str = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
  if (!props3)
    return str;
  return item instanceof Scalar || str[0] === "{" || str[0] === "[" ? "".concat(props3, " ").concat(str) : "".concat(props3, "\n").concat(ctx.indent).concat(str);
}
function parseContents(doc, contents) {
  var comments = {
    before: [],
    after: []
  };
  var body = void 0;
  var spaceBefore = false;
  var _iterator = _createForOfIteratorHelper(contents), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var node = _step.value;
      if (node.valueRange) {
        if (body !== void 0) {
          var msg = "Document contains trailing content not separated by a ... or --- line";
          doc.errors.push(new YAMLSyntaxError(node, msg));
          break;
        }
        var res = resolveNode(doc, node);
        if (spaceBefore) {
          res.spaceBefore = true;
          spaceBefore = false;
        }
        body = res;
      } else if (node.comment !== null) {
        var cc = body === void 0 ? comments.before : comments.after;
        cc.push(node.comment);
      } else if (node.type === Type.BLANK_LINE) {
        spaceBefore = true;
        if (body === void 0 && comments.before.length > 0 && !doc.commentBefore) {
          doc.commentBefore = comments.before.join("\n");
          comments.before = [];
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  doc.contents = body || null;
  if (!body) {
    doc.comment = comments.before.concat(comments.after).join("\n") || null;
  } else {
    var cb = comments.before.join("\n");
    if (cb) {
      var cbNode = body instanceof Collection2 && body.items[0] ? body.items[0] : body;
      cbNode.commentBefore = cbNode.commentBefore ? "".concat(cb, "\n").concat(cbNode.commentBefore) : cb;
    }
    doc.comment = comments.after.join("\n") || null;
  }
}
function resolveTagDirective(_ref, directive) {
  var tagPrefixes = _ref.tagPrefixes;
  var _directive$parameters = _slicedToArray(directive.parameters, 2), handle = _directive$parameters[0], prefix = _directive$parameters[1];
  if (!handle || !prefix) {
    var msg = "Insufficient parameters given for %TAG directive";
    throw new YAMLSemanticError(directive, msg);
  }
  if (tagPrefixes.some(function(p) {
    return p.handle === handle;
  })) {
    var _msg = "The %TAG directive must only be given at most once per handle in the same document.";
    throw new YAMLSemanticError(directive, _msg);
  }
  return {
    handle,
    prefix
  };
}
function resolveYamlDirective(doc, directive) {
  var _directive$parameters2 = _slicedToArray(directive.parameters, 1), version = _directive$parameters2[0];
  if (directive.name === "YAML:1.0")
    version = "1.0";
  if (!version) {
    var msg = "Insufficient parameters given for %YAML directive";
    throw new YAMLSemanticError(directive, msg);
  }
  if (!documentOptions[version]) {
    var v0 = doc.version || doc.options.version;
    var _msg2 = "Document will be parsed as YAML ".concat(v0, " rather than YAML ").concat(version);
    doc.warnings.push(new YAMLWarning(directive, _msg2));
  }
  return version;
}
function parseDirectives(doc, directives, prevDoc) {
  var directiveComments = [];
  var hasDirectives = false;
  var _iterator = _createForOfIteratorHelper(directives), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var directive = _step.value;
      var comment = directive.comment, name = directive.name;
      switch (name) {
        case "TAG":
          try {
            doc.tagPrefixes.push(resolveTagDirective(doc, directive));
          } catch (error) {
            doc.errors.push(error);
          }
          hasDirectives = true;
          break;
        case "YAML":
        case "YAML:1.0":
          if (doc.version) {
            var msg = "The %YAML directive must only be given at most once per document.";
            doc.errors.push(new YAMLSemanticError(directive, msg));
          }
          try {
            doc.version = resolveYamlDirective(doc, directive);
          } catch (error) {
            doc.errors.push(error);
          }
          hasDirectives = true;
          break;
        default:
          if (name) {
            var _msg3 = "YAML only supports %TAG and %YAML directives, and not %".concat(name);
            doc.warnings.push(new YAMLWarning(directive, _msg3));
          }
      }
      if (comment)
        directiveComments.push(comment);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (prevDoc && !hasDirectives && "1.1" === (doc.version || prevDoc.version || doc.options.version)) {
    var copyTagPrefix = function copyTagPrefix2(_ref2) {
      var handle = _ref2.handle, prefix = _ref2.prefix;
      return {
        handle,
        prefix
      };
    };
    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
    doc.version = prevDoc.version;
  }
  doc.commentBefore = directiveComments.join("\n") || null;
}
function assertCollection(contents) {
  if (contents instanceof Collection2)
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
function createNode5(value2) {
  var wrapScalars = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var tag = arguments.length > 2 ? arguments[2] : void 0;
  if (tag === void 0 && typeof wrapScalars === "string") {
    tag = wrapScalars;
    wrapScalars = true;
  }
  var options = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);
  var schema = new Schema(options);
  return schema.createNode(value2, wrapScalars, tag);
}
function parseAllDocuments(src, options) {
  var stream = [];
  var prev;
  var _iterator = _createForOfIteratorHelper(parse(src)), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var cstDoc = _step.value;
      var doc = new Document2(options);
      doc.parse(cstDoc, prev);
      stream.push(doc);
      prev = doc;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return stream;
}
function parseDocument(src, options) {
  var cst = parse(src);
  var doc = new Document2(options).parse(cst[0]);
  if (cst.length > 1) {
    var errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));
  }
  return doc;
}
function parse2(src, options) {
  var doc = parseDocument(src, options);
  doc.warnings.forEach(function(warning) {
    return warn(warning);
  });
  if (doc.errors.length > 0)
    throw doc.errors[0];
  return doc.toJSON();
}
function stringify15(value2, options) {
  var doc = new Document2(options);
  doc.contents = value2;
  return String(doc);
}
var defaultOptions, scalarOptions, documentOptions, Anchors, visit, listTagNames, Document$1, Document2, YAML;
var init_dist = __esm({
  "node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/dist/index.js"() {
    init_PlainValue_b8036b75();
    init_parse_cst();
    init_resolveSeq_492ab440();
    init_Schema_e94716c8();
    init_warnings_df54cb69();
    defaultOptions = {
      anchorPrefix: "a",
      customTags: null,
      indent: 2,
      indentSeq: true,
      keepCstNodes: false,
      keepNodeTypes: true,
      keepBlobsInJSON: true,
      mapAsMap: false,
      maxAliasCount: 100,
      prettyErrors: false,
      // TODO Set true in v2
      simpleKeys: false,
      version: "1.2"
    };
    scalarOptions = {
      get binary() {
        return binaryOptions;
      },
      set binary(opt) {
        Object.assign(binaryOptions, opt);
      },
      get bool() {
        return boolOptions;
      },
      set bool(opt) {
        Object.assign(boolOptions, opt);
      },
      get int() {
        return intOptions;
      },
      set int(opt) {
        Object.assign(intOptions, opt);
      },
      get null() {
        return nullOptions;
      },
      set null(opt) {
        Object.assign(nullOptions, opt);
      },
      get str() {
        return strOptions;
      },
      set str(opt) {
        Object.assign(strOptions, opt);
      }
    };
    documentOptions = {
      "1.0": {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: defaultTagPrefix
        }, {
          handle: "!!",
          prefix: "tag:private.yaml.org,2002:"
        }]
      },
      1.1: {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: defaultTagPrefix
        }]
      },
      1.2: {
        schema: "core",
        merge: false,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: defaultTagPrefix
        }]
      }
    };
    Anchors = function() {
      function Anchors2(prefix) {
        _classCallCheck(this, Anchors2);
        _defineProperty(this, "map", /* @__PURE__ */ Object.create(null));
        this.prefix = prefix;
      }
      _createClass(Anchors2, [{
        key: "createAlias",
        value: function createAlias(node, name) {
          this.setAnchor(node, name);
          return new Alias2(node);
        }
      }, {
        key: "createMergePair",
        value: function createMergePair() {
          var _this = this;
          var merge3 = new Merge();
          for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
            sources[_key] = arguments[_key];
          }
          merge3.value.items = sources.map(function(s) {
            if (s instanceof Alias2) {
              if (s.source instanceof YAMLMap)
                return s;
            } else if (s instanceof YAMLMap) {
              return _this.createAlias(s);
            }
            throw new Error("Merge sources must be Map nodes or their Aliases");
          });
          return merge3;
        }
      }, {
        key: "getName",
        value: function getName(node) {
          var map4 = this.map;
          return Object.keys(map4).find(function(a) {
            return map4[a] === node;
          });
        }
      }, {
        key: "getNames",
        value: function getNames() {
          return Object.keys(this.map);
        }
      }, {
        key: "getNode",
        value: function getNode(name) {
          return this.map[name];
        }
      }, {
        key: "newName",
        value: function newName(prefix) {
          if (!prefix)
            prefix = this.prefix;
          var names = Object.keys(this.map);
          for (var i = 1; true; ++i) {
            var name = "".concat(prefix).concat(i);
            if (!names.includes(name))
              return name;
          }
        }
        // During parsing, map & aliases contain CST nodes
      }, {
        key: "resolveNodes",
        value: function resolveNodes() {
          var map4 = this.map, _cstAliases = this._cstAliases;
          Object.keys(map4).forEach(function(a) {
            map4[a] = map4[a].resolved;
          });
          _cstAliases.forEach(function(a) {
            a.source = a.source.resolved;
          });
          delete this._cstAliases;
        }
      }, {
        key: "setAnchor",
        value: function setAnchor(node, name) {
          if (node != null && !Anchors2.validAnchorNode(node)) {
            throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
          }
          if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
            throw new Error("Anchor names must not contain whitespace or control characters");
          }
          var map4 = this.map;
          var prev = node && Object.keys(map4).find(function(a) {
            return map4[a] === node;
          });
          if (prev) {
            if (!name) {
              return prev;
            } else if (prev !== name) {
              delete map4[prev];
              map4[name] = node;
            }
          } else {
            if (!name) {
              if (!node)
                return null;
              name = this.newName();
            }
            map4[name] = node;
          }
          return name;
        }
      }], [{
        key: "validAnchorNode",
        value: function validAnchorNode(node) {
          return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;
        }
      }]);
      return Anchors2;
    }();
    visit = function visit2(node, tags2) {
      if (node && _typeof(node) === "object") {
        var tag = node.tag;
        if (node instanceof Collection2) {
          if (tag)
            tags2[tag] = true;
          node.items.forEach(function(n) {
            return visit2(n, tags2);
          });
        } else if (node instanceof Pair) {
          visit2(node.key, tags2);
          visit2(node.value, tags2);
        } else if (node instanceof Scalar) {
          if (tag)
            tags2[tag] = true;
        }
      }
      return tags2;
    };
    listTagNames = function listTagNames2(node) {
      return Object.keys(visit(node, {}));
    };
    Document$1 = function() {
      function Document3(options) {
        _classCallCheck(this, Document3);
        this.anchors = new Anchors(options.anchorPrefix);
        this.commentBefore = null;
        this.comment = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.errors = [];
        this.options = options;
        this.schema = null;
        this.tagPrefixes = [];
        this.version = null;
        this.warnings = [];
      }
      _createClass(Document3, [{
        key: "add",
        value: function add3(value2) {
          assertCollection(this.contents);
          return this.contents.add(value2);
        }
      }, {
        key: "addIn",
        value: function addIn(path3, value2) {
          assertCollection(this.contents);
          this.contents.addIn(path3, value2);
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          assertCollection(this.contents);
          return this.contents.delete(key);
        }
      }, {
        key: "deleteIn",
        value: function deleteIn(path3) {
          if (isEmptyPath(path3)) {
            if (this.contents == null)
              return false;
            this.contents = null;
            return true;
          }
          assertCollection(this.contents);
          return this.contents.deleteIn(path3);
        }
      }, {
        key: "getDefaults",
        value: function getDefaults() {
          return Document3.defaults[this.version] || Document3.defaults[this.options.version] || {};
        }
      }, {
        key: "get",
        value: function get(key, keepScalar) {
          return this.contents instanceof Collection2 ? this.contents.get(key, keepScalar) : void 0;
        }
      }, {
        key: "getIn",
        value: function getIn(path3, keepScalar) {
          if (isEmptyPath(path3))
            return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;
          return this.contents instanceof Collection2 ? this.contents.getIn(path3, keepScalar) : void 0;
        }
      }, {
        key: "has",
        value: function has3(key) {
          return this.contents instanceof Collection2 ? this.contents.has(key) : false;
        }
      }, {
        key: "hasIn",
        value: function hasIn3(path3) {
          if (isEmptyPath(path3))
            return this.contents !== void 0;
          return this.contents instanceof Collection2 ? this.contents.hasIn(path3) : false;
        }
      }, {
        key: "set",
        value: function set4(key, value2) {
          assertCollection(this.contents);
          this.contents.set(key, value2);
        }
      }, {
        key: "setIn",
        value: function setIn(path3, value2) {
          if (isEmptyPath(path3))
            this.contents = value2;
          else {
            assertCollection(this.contents);
            this.contents.setIn(path3, value2);
          }
        }
      }, {
        key: "setSchema",
        value: function setSchema(id, customTags) {
          if (!id && !customTags && this.schema)
            return;
          if (typeof id === "number")
            id = id.toFixed(1);
          if (id === "1.0" || id === "1.1" || id === "1.2") {
            if (this.version)
              this.version = id;
            else
              this.options.version = id;
            delete this.options.schema;
          } else if (id && typeof id === "string") {
            this.options.schema = id;
          }
          if (Array.isArray(customTags))
            this.options.customTags = customTags;
          var opt = Object.assign({}, this.getDefaults(), this.options);
          this.schema = new Schema(opt);
        }
      }, {
        key: "parse",
        value: function parse3(node, prevDoc) {
          if (this.options.keepCstNodes)
            this.cstNode = node;
          if (this.options.keepNodeTypes)
            this.type = "DOCUMENT";
          var _node$directives = node.directives, directives = _node$directives === void 0 ? [] : _node$directives, _node$contents = node.contents, contents = _node$contents === void 0 ? [] : _node$contents, directivesEndMarker = node.directivesEndMarker, error = node.error, valueRange = node.valueRange;
          if (error) {
            if (!error.source)
              error.source = this;
            this.errors.push(error);
          }
          parseDirectives(this, directives, prevDoc);
          if (directivesEndMarker)
            this.directivesEndMarker = true;
          this.range = valueRange ? [valueRange.start, valueRange.end] : null;
          this.setSchema();
          this.anchors._cstAliases = [];
          parseContents(this, contents);
          this.anchors.resolveNodes();
          if (this.options.prettyErrors) {
            var _iterator = _createForOfIteratorHelper(this.errors), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var _error = _step.value;
                if (_error instanceof YAMLError)
                  _error.makePretty();
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            var _iterator2 = _createForOfIteratorHelper(this.warnings), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var warn2 = _step2.value;
                if (warn2 instanceof YAMLError)
                  warn2.makePretty();
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          return this;
        }
      }, {
        key: "listNonDefaultTags",
        value: function listNonDefaultTags() {
          return listTagNames(this.contents).filter(function(t) {
            return t.indexOf(Schema.defaultPrefix) !== 0;
          });
        }
      }, {
        key: "setTagPrefix",
        value: function setTagPrefix(handle, prefix) {
          if (handle[0] !== "!" || handle[handle.length - 1] !== "!")
            throw new Error("Handle must start and end with !");
          if (prefix) {
            var prev = this.tagPrefixes.find(function(p) {
              return p.handle === handle;
            });
            if (prev)
              prev.prefix = prefix;
            else
              this.tagPrefixes.push({
                handle,
                prefix
              });
          } else {
            this.tagPrefixes = this.tagPrefixes.filter(function(p) {
              return p.handle !== handle;
            });
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON$1(arg, onAnchor) {
          var _this = this;
          var _this$options = this.options, keepBlobsInJSON = _this$options.keepBlobsInJSON, mapAsMap = _this$options.mapAsMap, maxAliasCount = _this$options.maxAliasCount;
          var keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof Scalar));
          var ctx = {
            doc: this,
            indentStep: "  ",
            keep,
            mapAsMap: keep && !!mapAsMap,
            maxAliasCount,
            stringify: stringify$1
            // Requiring directly in Pair would create circular dependencies
          };
          var anchorNames = Object.keys(this.anchors.map);
          if (anchorNames.length > 0)
            ctx.anchors = new Map(anchorNames.map(function(name) {
              return [_this.anchors.map[name], {
                alias: [],
                aliasCount: 0,
                count: 1
              }];
            }));
          var res = toJSON(this.contents, arg, ctx);
          if (typeof onAnchor === "function" && ctx.anchors) {
            var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()), _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                var _step3$value = _step3.value, count = _step3$value.count, _res = _step3$value.res;
                onAnchor(_res, count);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
          return res;
        }
      }, {
        key: "toString",
        value: function toString4() {
          if (this.errors.length > 0)
            throw new Error("Document with errors cannot be stringified");
          var indentSize = this.options.indent;
          if (!Number.isInteger(indentSize) || indentSize <= 0) {
            var s = JSON.stringify(indentSize);
            throw new Error('"indent" option must be a positive integer, not '.concat(s));
          }
          this.setSchema();
          var lines = [];
          var hasDirectives = false;
          if (this.version) {
            var vd = "%YAML 1.2";
            if (this.schema.name === "yaml-1.1") {
              if (this.version === "1.0")
                vd = "%YAML:1.0";
              else if (this.version === "1.1")
                vd = "%YAML 1.1";
            }
            lines.push(vd);
            hasDirectives = true;
          }
          var tagNames = this.listNonDefaultTags();
          this.tagPrefixes.forEach(function(_ref) {
            var handle = _ref.handle, prefix = _ref.prefix;
            if (tagNames.some(function(t) {
              return t.indexOf(prefix) === 0;
            })) {
              lines.push("%TAG ".concat(handle, " ").concat(prefix));
              hasDirectives = true;
            }
          });
          if (hasDirectives || this.directivesEndMarker)
            lines.push("---");
          if (this.commentBefore) {
            if (hasDirectives || !this.directivesEndMarker)
              lines.unshift("");
            lines.unshift(this.commentBefore.replace(/^/gm, "#"));
          }
          var ctx = {
            anchors: /* @__PURE__ */ Object.create(null),
            doc: this,
            indent: "",
            indentStep: " ".repeat(indentSize),
            stringify: stringify$1
            // Requiring directly in nodes would create circular dependencies
          };
          var chompKeep = false;
          var contentComment = null;
          if (this.contents) {
            if (this.contents instanceof Node2) {
              if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker))
                lines.push("");
              if (this.contents.commentBefore)
                lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
              ctx.forceBlockIndent = !!this.comment;
              contentComment = this.contents.comment;
            }
            var onChompKeep = contentComment ? null : function() {
              return chompKeep = true;
            };
            var body = stringify$1(this.contents, ctx, function() {
              return contentComment = null;
            }, onChompKeep);
            lines.push(addComment(body, "", contentComment));
          } else if (this.contents !== void 0) {
            lines.push(stringify$1(this.contents, ctx));
          }
          if (this.comment) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
              lines.push("");
            lines.push(this.comment.replace(/^/gm, "#"));
          }
          return lines.join("\n") + "\n";
        }
      }]);
      return Document3;
    }();
    _defineProperty(Document$1, "defaults", documentOptions);
    Document2 = function(_YAMLDocument) {
      _inherits(Document3, _YAMLDocument);
      var _super = _createSuper(Document3);
      function Document3(options) {
        _classCallCheck(this, Document3);
        return _super.call(this, Object.assign({}, defaultOptions, options));
      }
      return Document3;
    }(Document$1);
    YAML = {
      createNode: createNode5,
      defaultOptions,
      Document: Document2,
      parse: parse2,
      parseAllDocuments,
      parseCST: parse,
      parseDocument,
      scalarOptions,
      stringify: stringify15
    };
  }
});

// node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/index.js
var require_browser2 = __commonJS({
  "node_modules/.pnpm/yaml@1.10.2/node_modules/yaml/browser/index.js"(exports, module) {
    module.exports = (init_dist(), __toCommonJS(dist_exports)).YAML;
  }
});

// node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/loaders.js
var require_loaders = __commonJS({
  "node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/loaders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.loaders = void 0;
    var importFresh;
    var loadJs = function loadJs2(filepath) {
      if (importFresh === void 0) {
        importFresh = require_import_fresh();
      }
      const result = importFresh(filepath);
      return result;
    };
    var parseJson;
    var loadJson = function loadJson2(filepath, content) {
      if (parseJson === void 0) {
        parseJson = require_parse_json();
      }
      try {
        const result = parseJson(content);
        return result;
      } catch (error) {
        error.message = `JSON Error in ${filepath}:
${error.message}`;
        throw error;
      }
    };
    var yaml;
    var loadYaml = function loadYaml2(filepath, content) {
      if (yaml === void 0) {
        yaml = require_browser2();
      }
      try {
        const result = yaml.parse(content, {
          prettyErrors: true
        });
        return result;
      } catch (error) {
        error.message = `YAML Error in ${filepath}:
${error.message}`;
        throw error;
      }
    };
    var loaders = {
      loadJs,
      loadJson,
      loadYaml
    };
    exports.loaders = loaders;
  }
});

// node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/getPropertyByPath.js
var require_getPropertyByPath = __commonJS({
  "node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/getPropertyByPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getPropertyByPath = getPropertyByPath;
    function getPropertyByPath(source, path3) {
      if (typeof path3 === "string" && Object.prototype.hasOwnProperty.call(source, path3)) {
        return source[path3];
      }
      const parsedPath = typeof path3 === "string" ? path3.split(".") : path3;
      return parsedPath.reduce((previous, key) => {
        if (previous === void 0) {
          return previous;
        }
        return previous[key];
      }, source);
    }
  }
});

// node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/ExplorerBase.js
var require_ExplorerBase = __commonJS({
  "node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/ExplorerBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExplorerBase = void 0;
    exports.getExtensionDescription = getExtensionDescription;
    var _path = _interopRequireDefault(require_path());
    var _loaders = require_loaders();
    var _getPropertyByPath = require_getPropertyByPath();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ExplorerBase = class {
      constructor(options) {
        if (options.cache === true) {
          this.loadCache = /* @__PURE__ */ new Map();
          this.searchCache = /* @__PURE__ */ new Map();
        }
        this.config = options;
        this.validateConfig();
      }
      clearLoadCache() {
        if (this.loadCache) {
          this.loadCache.clear();
        }
      }
      clearSearchCache() {
        if (this.searchCache) {
          this.searchCache.clear();
        }
      }
      clearCaches() {
        this.clearLoadCache();
        this.clearSearchCache();
      }
      validateConfig() {
        const config = this.config;
        config.searchPlaces.forEach((place) => {
          const loaderKey = _path.default.extname(place) || "noExt";
          const loader = config.loaders[loaderKey];
          if (!loader) {
            throw new Error(`No loader specified for ${getExtensionDescription(place)}, so searchPlaces item "${place}" is invalid`);
          }
          if (typeof loader !== "function") {
            throw new Error(`loader for ${getExtensionDescription(place)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
          }
        });
      }
      shouldSearchStopWithResult(result) {
        if (result === null)
          return false;
        if (result.isEmpty && this.config.ignoreEmptySearchPlaces)
          return false;
        return true;
      }
      nextDirectoryToSearch(currentDir, currentResult) {
        if (this.shouldSearchStopWithResult(currentResult)) {
          return null;
        }
        const nextDir = nextDirUp(currentDir);
        if (nextDir === currentDir || currentDir === this.config.stopDir) {
          return null;
        }
        return nextDir;
      }
      loadPackageProp(filepath, content) {
        const parsedContent = _loaders.loaders.loadJson(filepath, content);
        const packagePropValue = (0, _getPropertyByPath.getPropertyByPath)(parsedContent, this.config.packageProp);
        return packagePropValue || null;
      }
      getLoaderEntryForFile(filepath) {
        if (_path.default.basename(filepath) === "package.json") {
          const loader2 = this.loadPackageProp.bind(this);
          return loader2;
        }
        const loaderKey = _path.default.extname(filepath) || "noExt";
        const loader = this.config.loaders[loaderKey];
        if (!loader) {
          throw new Error(`No loader specified for ${getExtensionDescription(filepath)}`);
        }
        return loader;
      }
      loadedContentToCosmiconfigResult(filepath, loadedContent) {
        if (loadedContent === null) {
          return null;
        }
        if (loadedContent === void 0) {
          return {
            filepath,
            config: void 0,
            isEmpty: true
          };
        }
        return {
          config: loadedContent,
          filepath
        };
      }
      validateFilePath(filepath) {
        if (!filepath) {
          throw new Error("load must pass a non-empty string");
        }
      }
    };
    exports.ExplorerBase = ExplorerBase;
    function nextDirUp(dir) {
      return _path.default.dirname(dir);
    }
    function getExtensionDescription(filepath) {
      const ext = _path.default.extname(filepath);
      return ext ? `extension "${ext}"` : "files without extensions";
    }
  }
});

// node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/readFile.js
var require_readFile = __commonJS({
  "node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/readFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.readFile = readFile;
    exports.readFileSync = readFileSync;
    var _fs = _interopRequireDefault(require_fs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function fsReadFileAsync(pathname, encoding) {
      return new Promise((resolve27, reject3) => {
        _fs.default.readFile(pathname, encoding, (error, contents) => {
          if (error) {
            reject3(error);
            return;
          }
          resolve27(contents);
        });
      });
    }
    async function readFile(filepath, options = {}) {
      const throwNotFound = options.throwNotFound === true;
      try {
        const content = await fsReadFileAsync(filepath, "utf8");
        return content;
      } catch (error) {
        if (throwNotFound === false && (error.code === "ENOENT" || error.code === "EISDIR")) {
          return null;
        }
        throw error;
      }
    }
    function readFileSync(filepath, options = {}) {
      const throwNotFound = options.throwNotFound === true;
      try {
        const content = _fs.default.readFileSync(filepath, "utf8");
        return content;
      } catch (error) {
        if (throwNotFound === false && (error.code === "ENOENT" || error.code === "EISDIR")) {
          return null;
        }
        throw error;
      }
    }
  }
});

// node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/cacheWrapper.js
var require_cacheWrapper = __commonJS({
  "node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/cacheWrapper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.cacheWrapper = cacheWrapper;
    exports.cacheWrapperSync = cacheWrapperSync;
    async function cacheWrapper(cache, key, fn) {
      const cached = cache.get(key);
      if (cached !== void 0) {
        return cached;
      }
      const result = await fn();
      cache.set(key, result);
      return result;
    }
    function cacheWrapperSync(cache, key, fn) {
      const cached = cache.get(key);
      if (cached !== void 0) {
        return cached;
      }
      const result = fn();
      cache.set(key, result);
      return result;
    }
  }
});

// node_modules/.pnpm/path-type@4.0.0/node_modules/path-type/index.js
var require_path_type = __commonJS({
  "node_modules/.pnpm/path-type@4.0.0/node_modules/path-type/index.js"(exports) {
    "use strict";
    var { promisify } = require_util();
    var fs = require_fs();
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify(fs[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    exports.isFile = isType.bind(null, "stat", "isFile");
    exports.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/getDirectory.js
var require_getDirectory = __commonJS({
  "node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/getDirectory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getDirectory = getDirectory;
    exports.getDirectorySync = getDirectorySync;
    var _path = _interopRequireDefault(require_path());
    var _pathType = require_path_type();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function getDirectory(filepath) {
      const filePathIsDirectory = await (0, _pathType.isDirectory)(filepath);
      if (filePathIsDirectory === true) {
        return filepath;
      }
      const directory = _path.default.dirname(filepath);
      return directory;
    }
    function getDirectorySync(filepath) {
      const filePathIsDirectory = (0, _pathType.isDirectorySync)(filepath);
      if (filePathIsDirectory === true) {
        return filepath;
      }
      const directory = _path.default.dirname(filepath);
      return directory;
    }
  }
});

// node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/Explorer.js
var require_Explorer = __commonJS({
  "node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/Explorer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Explorer = void 0;
    var _path = _interopRequireDefault(require_path());
    var _ExplorerBase = require_ExplorerBase();
    var _readFile = require_readFile();
    var _cacheWrapper = require_cacheWrapper();
    var _getDirectory = require_getDirectory();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Explorer = class extends _ExplorerBase.ExplorerBase {
      constructor(options) {
        super(options);
      }
      async search(searchFrom = process.cwd()) {
        const startDirectory = await (0, _getDirectory.getDirectory)(searchFrom);
        const result = await this.searchFromDirectory(startDirectory);
        return result;
      }
      async searchFromDirectory(dir) {
        const absoluteDir = _path.default.resolve(process.cwd(), dir);
        const run = async () => {
          const result = await this.searchDirectory(absoluteDir);
          const nextDir = this.nextDirectoryToSearch(absoluteDir, result);
          if (nextDir) {
            return this.searchFromDirectory(nextDir);
          }
          const transformResult = await this.config.transform(result);
          return transformResult;
        };
        if (this.searchCache) {
          return (0, _cacheWrapper.cacheWrapper)(this.searchCache, absoluteDir, run);
        }
        return run();
      }
      async searchDirectory(dir) {
        for await (const place of this.config.searchPlaces) {
          const placeResult = await this.loadSearchPlace(dir, place);
          if (this.shouldSearchStopWithResult(placeResult) === true) {
            return placeResult;
          }
        }
        return null;
      }
      async loadSearchPlace(dir, place) {
        const filepath = _path.default.join(dir, place);
        const fileContents = await (0, _readFile.readFile)(filepath);
        const result = await this.createCosmiconfigResult(filepath, fileContents);
        return result;
      }
      async loadFileContent(filepath, content) {
        if (content === null) {
          return null;
        }
        if (content.trim() === "") {
          return void 0;
        }
        const loader = this.getLoaderEntryForFile(filepath);
        const loaderResult = await loader(filepath, content);
        return loaderResult;
      }
      async createCosmiconfigResult(filepath, content) {
        const fileContent = await this.loadFileContent(filepath, content);
        const result = this.loadedContentToCosmiconfigResult(filepath, fileContent);
        return result;
      }
      async load(filepath) {
        this.validateFilePath(filepath);
        const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);
        const runLoad = async () => {
          const fileContents = await (0, _readFile.readFile)(absoluteFilePath, {
            throwNotFound: true
          });
          const result = await this.createCosmiconfigResult(absoluteFilePath, fileContents);
          const transformResult = await this.config.transform(result);
          return transformResult;
        };
        if (this.loadCache) {
          return (0, _cacheWrapper.cacheWrapper)(this.loadCache, absoluteFilePath, runLoad);
        }
        return runLoad();
      }
    };
    exports.Explorer = Explorer;
  }
});

// node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/ExplorerSync.js
var require_ExplorerSync = __commonJS({
  "node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/ExplorerSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExplorerSync = void 0;
    var _path = _interopRequireDefault(require_path());
    var _ExplorerBase = require_ExplorerBase();
    var _readFile = require_readFile();
    var _cacheWrapper = require_cacheWrapper();
    var _getDirectory = require_getDirectory();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ExplorerSync = class extends _ExplorerBase.ExplorerBase {
      constructor(options) {
        super(options);
      }
      searchSync(searchFrom = process.cwd()) {
        const startDirectory = (0, _getDirectory.getDirectorySync)(searchFrom);
        const result = this.searchFromDirectorySync(startDirectory);
        return result;
      }
      searchFromDirectorySync(dir) {
        const absoluteDir = _path.default.resolve(process.cwd(), dir);
        const run = () => {
          const result = this.searchDirectorySync(absoluteDir);
          const nextDir = this.nextDirectoryToSearch(absoluteDir, result);
          if (nextDir) {
            return this.searchFromDirectorySync(nextDir);
          }
          const transformResult = this.config.transform(result);
          return transformResult;
        };
        if (this.searchCache) {
          return (0, _cacheWrapper.cacheWrapperSync)(this.searchCache, absoluteDir, run);
        }
        return run();
      }
      searchDirectorySync(dir) {
        for (const place of this.config.searchPlaces) {
          const placeResult = this.loadSearchPlaceSync(dir, place);
          if (this.shouldSearchStopWithResult(placeResult) === true) {
            return placeResult;
          }
        }
        return null;
      }
      loadSearchPlaceSync(dir, place) {
        const filepath = _path.default.join(dir, place);
        const content = (0, _readFile.readFileSync)(filepath);
        const result = this.createCosmiconfigResultSync(filepath, content);
        return result;
      }
      loadFileContentSync(filepath, content) {
        if (content === null) {
          return null;
        }
        if (content.trim() === "") {
          return void 0;
        }
        const loader = this.getLoaderEntryForFile(filepath);
        const loaderResult = loader(filepath, content);
        return loaderResult;
      }
      createCosmiconfigResultSync(filepath, content) {
        const fileContent = this.loadFileContentSync(filepath, content);
        const result = this.loadedContentToCosmiconfigResult(filepath, fileContent);
        return result;
      }
      loadSync(filepath) {
        this.validateFilePath(filepath);
        const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);
        const runLoadSync = () => {
          const content = (0, _readFile.readFileSync)(absoluteFilePath, {
            throwNotFound: true
          });
          const cosmiconfigResult = this.createCosmiconfigResultSync(absoluteFilePath, content);
          const transformResult = this.config.transform(cosmiconfigResult);
          return transformResult;
        };
        if (this.loadCache) {
          return (0, _cacheWrapper.cacheWrapperSync)(this.loadCache, absoluteFilePath, runLoadSync);
        }
        return runLoadSync();
      }
    };
    exports.ExplorerSync = ExplorerSync;
  }
});

// node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/cosmiconfig@7.1.0/node_modules/cosmiconfig/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.cosmiconfig = cosmiconfig;
    exports.cosmiconfigSync = cosmiconfigSync;
    exports.defaultLoaders = void 0;
    var _os = _interopRequireDefault(require_os());
    var _Explorer = require_Explorer();
    var _ExplorerSync = require_ExplorerSync();
    var _loaders = require_loaders();
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function cosmiconfig(moduleName, options = {}) {
      const normalizedOptions = normalizeOptions(moduleName, options);
      const explorer = new _Explorer.Explorer(normalizedOptions);
      return {
        search: explorer.search.bind(explorer),
        load: explorer.load.bind(explorer),
        clearLoadCache: explorer.clearLoadCache.bind(explorer),
        clearSearchCache: explorer.clearSearchCache.bind(explorer),
        clearCaches: explorer.clearCaches.bind(explorer)
      };
    }
    function cosmiconfigSync(moduleName, options = {}) {
      const normalizedOptions = normalizeOptions(moduleName, options);
      const explorerSync = new _ExplorerSync.ExplorerSync(normalizedOptions);
      return {
        search: explorerSync.searchSync.bind(explorerSync),
        load: explorerSync.loadSync.bind(explorerSync),
        clearLoadCache: explorerSync.clearLoadCache.bind(explorerSync),
        clearSearchCache: explorerSync.clearSearchCache.bind(explorerSync),
        clearCaches: explorerSync.clearCaches.bind(explorerSync)
      };
    }
    var defaultLoaders = Object.freeze({
      ".cjs": _loaders.loaders.loadJs,
      ".js": _loaders.loaders.loadJs,
      ".json": _loaders.loaders.loadJson,
      ".yaml": _loaders.loaders.loadYaml,
      ".yml": _loaders.loaders.loadYaml,
      noExt: _loaders.loaders.loadYaml
    });
    exports.defaultLoaders = defaultLoaders;
    var identity2 = function identity3(x) {
      return x;
    };
    function normalizeOptions(moduleName, options) {
      const defaults = {
        packageProp: moduleName,
        searchPlaces: ["package.json", `.${moduleName}rc`, `.${moduleName}rc.json`, `.${moduleName}rc.yaml`, `.${moduleName}rc.yml`, `.${moduleName}rc.js`, `.${moduleName}rc.cjs`, `.config/${moduleName}rc`, `.config/${moduleName}rc.json`, `.config/${moduleName}rc.yaml`, `.config/${moduleName}rc.yml`, `.config/${moduleName}rc.js`, `.config/${moduleName}rc.cjs`, `${moduleName}.config.js`, `${moduleName}.config.cjs`],
        ignoreEmptySearchPlaces: true,
        stopDir: _os.default.homedir(),
        cache: true,
        transform: identity2,
        loaders: defaultLoaders
      };
      const normalizedOptions = {
        ...defaults,
        ...options,
        loaders: {
          ...defaults.loaders,
          ...options.loaders
        }
      };
      return normalizedOptions;
    }
  }
});

// node_modules/.pnpm/babel-plugin-macros@3.1.0/node_modules/babel-plugin-macros/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/babel-plugin-macros@3.1.0/node_modules/babel-plugin-macros/dist/index.js"(exports, module) {
    "use strict";
    var p = require_path();
    var resolve27 = require_resolve();
    var macrosRegex = /[./]macro(\.c?js)?$/;
    var testMacrosRegex = (v) => macrosRegex.test(v);
    var MacroError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "MacroError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, this.constructor);
        } else if (!this.stack) {
          this.stack = new Error(message).stack;
        }
      }
    };
    var _configExplorer = null;
    function getConfigExplorer() {
      return _configExplorer = _configExplorer || // Lazy load cosmiconfig since it is a relatively large bundle
      require_dist().cosmiconfigSync("babel-plugin-macros", {
        searchPlaces: ["package.json", ".babel-plugin-macrosrc", ".babel-plugin-macrosrc.json", ".babel-plugin-macrosrc.yaml", ".babel-plugin-macrosrc.yml", ".babel-plugin-macrosrc.js", "babel-plugin-macros.config.js"],
        packageProp: "babelMacros"
      });
    }
    function createMacro(macro, options = {}) {
      if (options.configName === "options") {
        throw new Error(`You cannot use the configName "options". It is reserved for babel-plugin-macros.`);
      }
      macroWrapper.isBabelMacro = true;
      macroWrapper.options = options;
      return macroWrapper;
      function macroWrapper(args) {
        const {
          source,
          isBabelMacrosCall
        } = args;
        if (!isBabelMacrosCall) {
          throw new MacroError(`The macro you imported from "${source}" is being executed outside the context of compilation with babel-plugin-macros. This indicates that you don't have the babel plugin "babel-plugin-macros" configured correctly. Please see the documentation for how to configure babel-plugin-macros properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md`);
        }
        return macro(args);
      }
    }
    function nodeResolvePath(source, basedir) {
      return resolve27.sync(source, {
        basedir,
        extensions: [".js", ".ts", ".tsx", ".mjs", ".cjs", ".jsx"],
        // This is here to support the package being globally installed
        // read more: https://github.com/kentcdodds/babel-plugin-macros/pull/138
        paths: [p.resolve(__dirname, "../../")]
      });
    }
    function macrosPlugin(babel, {
      require: _require = __require,
      resolvePath = nodeResolvePath,
      isMacrosName = testMacrosRegex,
      ...options
    } = {}) {
      function interopRequire(path3) {
        const o3 = _require(path3);
        return o3 && o3.__esModule && o3.default ? o3.default : o3;
      }
      return {
        name: "macros",
        visitor: {
          Program(progPath, state) {
            progPath.traverse({
              ImportDeclaration(path3) {
                const isMacros = looksLike(path3, {
                  node: {
                    source: {
                      value: (v) => isMacrosName(v)
                    }
                  }
                });
                if (!isMacros) {
                  return;
                }
                const imports = path3.node.specifiers.map((s) => ({
                  localName: s.local.name,
                  importedName: s.type === "ImportDefaultSpecifier" ? "default" : s.imported.name
                }));
                const source = path3.node.source.value;
                const result = applyMacros({
                  path: path3,
                  imports,
                  source,
                  state,
                  babel,
                  interopRequire,
                  resolvePath,
                  options
                });
                if (!result || !result.keepImports) {
                  path3.remove();
                }
              },
              VariableDeclaration(path3) {
                const isMacros = (child) => looksLike(child, {
                  node: {
                    init: {
                      callee: {
                        type: "Identifier",
                        name: "require"
                      },
                      arguments: (args) => args.length === 1 && isMacrosName(args[0].value)
                    }
                  }
                });
                path3.get("declarations").filter(isMacros).forEach((child) => {
                  const imports = child.node.id.name ? [{
                    localName: child.node.id.name,
                    importedName: "default"
                  }] : child.node.id.properties.map((property) => ({
                    localName: property.value.name,
                    importedName: property.key.name
                  }));
                  const call3 = child.get("init");
                  const source = call3.node.arguments[0].value;
                  const result = applyMacros({
                    path: call3,
                    imports,
                    source,
                    state,
                    babel,
                    interopRequire,
                    resolvePath,
                    options
                  });
                  if (!result || !result.keepImports) {
                    child.remove();
                  }
                });
              }
            });
          }
        }
      };
    }
    function applyMacros({
      path: path3,
      imports,
      source,
      state,
      babel,
      interopRequire,
      resolvePath,
      options
    }) {
      const {
        file: {
          opts: {
            filename = ""
          }
        }
      } = state;
      let hasReferences = false;
      const referencePathsByImportName = imports.reduce((byName, {
        importedName,
        localName
      }) => {
        const binding = path3.scope.getBinding(localName);
        byName[importedName] = binding.referencePaths;
        hasReferences = hasReferences || Boolean(byName[importedName].length);
        return byName;
      }, {});
      const isRelative = source.indexOf(".") === 0;
      const requirePath = resolvePath(source, p.dirname(getFullFilename(filename)));
      const macro = interopRequire(requirePath);
      if (!macro.isBabelMacro) {
        throw new Error(`The macro imported from "${source}" must be wrapped in "createMacro" which you can get from "babel-plugin-macros". Please refer to the documentation to see how to do this properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md#writing-a-macro`);
      }
      const config = getConfig(macro, filename, source, options);
      let result;
      try {
        state.file.scope.path.traverse({
          Identifier() {
          }
        });
        result = macro({
          references: referencePathsByImportName,
          source,
          state,
          babel,
          config,
          isBabelMacrosCall: true
        });
      } catch (error) {
        if (error.name === "MacroError") {
          throw error;
        }
        error.message = `${source}: ${error.message}`;
        if (!isRelative) {
          error.message = `${error.message} Learn more: https://www.npmjs.com/package/${source.replace(
            // remove everything after package name
            // @org/package/macro -> @org/package
            // package/macro      -> package
            /^((?:@[^/]+\/)?[^/]+).*/,
            "$1"
          )}`;
        }
        throw error;
      }
      return result;
    }
    function getConfigFromFile(configName, filename) {
      try {
        const loaded = getConfigExplorer().search(filename);
        if (loaded) {
          return {
            options: loaded.config[configName],
            path: loaded.filepath
          };
        }
      } catch (e) {
        return {
          error: e
        };
      }
      return {};
    }
    function getConfigFromOptions(configName, options) {
      if (options.hasOwnProperty(configName)) {
        if (options[configName] && typeof options[configName] !== "object") {
          console.error(`The macro plugin options' ${configName} property was not an object or null.`);
        } else {
          return {
            options: options[configName]
          };
        }
      }
      return {};
    }
    function getConfig(macro, filename, source, options) {
      const {
        configName
      } = macro.options;
      if (configName) {
        const fileConfig = getConfigFromFile(configName, filename);
        const optionsConfig = getConfigFromOptions(configName, options);
        if (optionsConfig.options === void 0 && fileConfig.options === void 0 && fileConfig.error !== void 0) {
          console.error(`There was an error trying to load the config "${configName}" for the macro imported from "${source}. Please see the error thrown for more information.`);
          throw fileConfig.error;
        }
        if (fileConfig.options !== void 0 && optionsConfig.options !== void 0 && typeof fileConfig.options !== "object") {
          throw new Error(`${fileConfig.path} specified a ${configName} config of type ${typeof optionsConfig.options}, but the the macros plugin's options.${configName} did contain an object. Both configs must contain objects for their options to be mergeable.`);
        }
        return {
          ...optionsConfig.options,
          ...fileConfig.options
        };
      }
      return void 0;
    }
    function getFullFilename(filename) {
      if (p.isAbsolute(filename)) {
        return filename;
      }
      return p.join(process.cwd(), filename);
    }
    function looksLike(a, b) {
      return a && b && Object.keys(b).every((bKey) => {
        const bVal = b[bKey];
        const aVal = a[bKey];
        if (typeof bVal === "function") {
          return bVal(aVal);
        }
        return isPrimitive(bVal) ? bVal === aVal : looksLike(aVal, bVal);
      });
    }
    function isPrimitive(val) {
      return val == null || /^[sbn]/.test(typeof val);
    }
    module.exports = macrosPlugin;
    Object.assign(module.exports, {
      createMacro,
      MacroError
    });
  }
});

// node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min3 = Math.min(r, g, b);
      const max3 = Math.max(r, g, b);
      const delta = max3 - min3;
      let h;
      let s;
      if (max3 === min3) {
        h = 0;
      } else if (r === max3) {
        h = (g - b) / delta;
      } else if (g === max3) {
        h = 2 + (b - r) / delta;
      } else if (b === max3) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min3 + max3) / 2;
      if (max3 === min3) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max3 + min3);
      } else {
        s = delta / (2 - max3 - min3);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value2 = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value2);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value2 = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value2 = Math.round(value2 / 50);
      if (value2 === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value2 === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert.hex.rgb = function(args) {
      const match3 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match3) {
        return [0, 0, 0];
      }
      let colorString = match3[0];
      if (match3[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max3 = Math.max(Math.max(r, g), b);
      const min3 = Math.min(Math.min(r, g), b);
      const chroma = max3 - min3;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min3 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max3 === r) {
        hue = (g - b) / chroma % 6;
      } else if (max3 === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions2();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path3 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path3.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path3;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions2();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value2 = get();
          Object.defineProperty(object, property, {
            value: value2,
            enumerable: true,
            configurable: true
          });
          return value2;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity2, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert2();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity2, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/browser.js
var require_browser3 = __commonJS({
  "node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    module.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js
var require_util2 = __commonJS({
  "node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js"(exports, module) {
    "use strict";
    var stringReplaceAll = (string2, substring, replacer) => {
      let index = string2.indexOf(substring);
      if (index === -1) {
        return string2;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string2.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string2.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string2.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string2, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string2[index - 1] === "\r";
        returnValue += string2.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string2.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string2.substr(endIndex);
      return returnValue;
    };
    module.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js
var require_templates2 = __commonJS({
  "node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js"(exports, module) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string2 = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string2 : buildStyle(chalk, styles)(string2));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js"(exports, module) {
    "use strict";
    var ansiStyles = require_ansi_styles2();
    var { stdout: stdoutColor, stderr: stderrColor } = require_browser3();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util2();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string2) => {
      if (self2.level <= 0 || !string2) {
        return self2._isEmpty ? "" : string2;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string2;
      }
      const { openAll, closeAll } = styler;
      if (string2.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string2 = stringReplaceAll(string2, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string2.indexOf("\n");
      if (lfIndex !== -1) {
        string2 = stringEncaseCRLFWithFirstIndex(string2, closeAll, openAll, lfIndex);
      }
      return openAll + string2 + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates2();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module.exports = chalk;
  }
});

// node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/types.js
var require_types2 = __commonJS({
  "node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// browser-external:fs/promises
var require_promises = __commonJS({
  "browser-external:fs/promises"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs/promises" has been externalized for browser compatibility. Cannot access "fs/promises.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/util.js
var require_util3 = __commonJS({
  "node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeUndefinedValuesFromObject = exports.getPropertyByPath = exports.emplace = void 0;
    function emplace(map4, key, fn) {
      const cached = map4.get(key);
      if (cached !== void 0) {
        return cached;
      }
      const result = fn();
      map4.set(key, result);
      return result;
    }
    exports.emplace = emplace;
    function getPropertyByPath(source, path3) {
      if (typeof path3 === "string" && Object.prototype.hasOwnProperty.call(source, path3)) {
        return source[path3];
      }
      const parsedPath = typeof path3 === "string" ? path3.split(".") : path3;
      return parsedPath.reduce((previous, key) => {
        if (previous === void 0) {
          return previous;
        }
        return previous[key];
      }, source);
    }
    exports.getPropertyByPath = getPropertyByPath;
    function removeUndefinedValuesFromObject(options) {
      if (!options) {
        return void 0;
      }
      return Object.fromEntries(Object.entries(options).filter(([, value2]) => value2 !== void 0));
    }
    exports.removeUndefinedValuesFromObject = removeUndefinedValuesFromObject;
  }
});

// node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/ExplorerBase.js
var require_ExplorerBase2 = __commonJS({
  "node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/ExplorerBase.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getExtensionDescription = exports.ExplorerBase = void 0;
    var path_1 = __importDefault(require_path());
    var util_js_1 = require_util3();
    var _loadingMetaConfig, _validateConfig, validateConfig_fn;
    var ExplorerBase = class {
      constructor(options) {
        __privateAdd(this, _validateConfig);
        __privateAdd(this, _loadingMetaConfig, false);
        __publicField(this, "config");
        __publicField(this, "loadCache");
        __publicField(this, "searchCache");
        this.config = options;
        if (options.cache) {
          this.loadCache = /* @__PURE__ */ new Map();
          this.searchCache = /* @__PURE__ */ new Map();
        }
        __privateMethod(this, _validateConfig, validateConfig_fn).call(this);
      }
      set loadingMetaConfig(value2) {
        __privateSet(this, _loadingMetaConfig, value2);
      }
      clearLoadCache() {
        if (this.loadCache) {
          this.loadCache.clear();
        }
      }
      clearSearchCache() {
        if (this.searchCache) {
          this.searchCache.clear();
        }
      }
      clearCaches() {
        this.clearLoadCache();
        this.clearSearchCache();
      }
      toCosmiconfigResult(filepath, config) {
        if (config === null) {
          return null;
        }
        if (config === void 0) {
          return { filepath, config: void 0, isEmpty: true };
        }
        if (this.config.applyPackagePropertyPathToConfiguration || __privateGet(this, _loadingMetaConfig)) {
          config = (0, util_js_1.getPropertyByPath)(config, this.config.packageProp);
        }
        if (config === void 0) {
          return { filepath, config: void 0, isEmpty: true };
        }
        return { config, filepath };
      }
    };
    _loadingMetaConfig = new WeakMap();
    _validateConfig = new WeakSet();
    validateConfig_fn = function() {
      const config = this.config;
      for (const place of config.searchPlaces) {
        const extension = path_1.default.extname(place);
        const loader = this.config.loaders[extension || "noExt"] ?? this.config.loaders["default"];
        if (loader === void 0) {
          throw new Error(`Missing loader for ${getExtensionDescription(place)}.`);
        }
        if (typeof loader !== "function") {
          throw new Error(`Loader for ${getExtensionDescription(place)} is not a function: Received ${typeof loader}.`);
        }
      }
    };
    exports.ExplorerBase = ExplorerBase;
    function getExtensionDescription(extension) {
      return extension ? `extension "${extension}"` : "files without extensions";
    }
    exports.getExtensionDescription = getExtensionDescription;
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/common.js"(exports, module) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence3) {
      if (Array.isArray(sequence3))
        return sequence3;
      else if (isNothing(sequence3))
        return [];
      return [sequence3];
    }
    function extend(target, source) {
      var index, length4, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length4 = sourceKeys.length; index < length4; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat3(string2, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string2;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module.exports.isNothing = isNothing;
    module.exports.isObject = isObject;
    module.exports.toArray = toArray;
    module.exports.repeat = repeat3;
    module.exports.isNegativeZero = isNegativeZero;
    module.exports.extend = extend;
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/exception.js"(exports, module) {
    "use strict";
    function formatError(exception, compact) {
      var where3 = "", message = exception.reason || "(unknown reason)";
      if (!exception.mark)
        return message;
      if (exception.mark.name) {
        where3 += 'in "' + exception.mark.name + '" ';
      }
      where3 += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
      if (!compact && exception.mark.snippet) {
        where3 += "\n\n" + exception.mark.snippet;
      }
      return message + " " + where3;
    }
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString4(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    module.exports = YAMLException;
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/snippet.js"(exports, module) {
    "use strict";
    var common = require_common();
    function getLine2(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head2 = "";
      var tail2 = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head2 = " ... ";
        lineStart = position - maxHalfLength + head2.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail2 = " ...";
        lineEnd = position + maxHalfLength - tail2.length;
      }
      return {
        str: head2 + buffer.slice(lineStart, lineEnd).replace(/\t/g, "→") + tail2,
        pos: position - lineStart + head2.length
        // relative position
      };
    }
    function padStart(string2, max3) {
      return common.repeat(" ", max3 - string2.length) + string2;
    }
    function makeSnippet(mark, options) {
      options = Object.create(options || null);
      if (!mark.buffer)
        return null;
      if (!options.maxLength)
        options.maxLength = 79;
      if (typeof options.indent !== "number")
        options.indent = 1;
      if (typeof options.linesBefore !== "number")
        options.linesBefore = 3;
      if (typeof options.linesAfter !== "number")
        options.linesAfter = 2;
      var re = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match3;
      var foundLineNo = -1;
      while (match3 = re.exec(mark.buffer)) {
        lineEnds.push(match3.index);
        lineStarts.push(match3.index + match3[0].length);
        if (mark.position <= match3.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0)
        foundLineNo = lineStarts.length - 1;
      var result = "", i, line;
      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
      for (i = 1; i <= options.linesBefore; i++) {
        if (foundLineNo - i < 0)
          break;
        line = getLine2(
          mark.buffer,
          lineStarts[foundLineNo - i],
          lineEnds[foundLineNo - i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
          maxLineLength
        );
        result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine2(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i = 1; i <= options.linesAfter; i++) {
        if (foundLineNo + i >= lineEnds.length)
          break;
        line = getLine2(
          mark.buffer,
          lineStarts[foundLineNo + i],
          lineEnds[foundLineNo + i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
          maxLineLength
        );
        result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    module.exports = makeSnippet;
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type.js
var require_type = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type.js"(exports, module) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map4) {
      var result = {};
      if (map4 !== null) {
        Object.keys(map4).forEach(function(style) {
          map4[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type2(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options;
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.representName = options["representName"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.multi = options["multi"] || false;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module.exports = Type2;
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/schema.js
var require_schema = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/schema.js"(exports, module) {
    "use strict";
    var YAMLException = require_exception();
    var Type2 = require_type();
    function compileList(schema, name) {
      var result = [];
      schema[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length4;
      function collectType(type3) {
        if (type3.multi) {
          result.multi[type3.kind].push(type3);
          result.multi["fallback"].push(type3);
        } else {
          result[type3.kind][type3.tag] = result["fallback"][type3.tag] = type3;
        }
      }
      for (index = 0, length4 = arguments.length; index < length4; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema2(definition) {
      return this.extend(definition);
    }
    Schema2.prototype.extend = function extend(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof Type2) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit)
          implicit = implicit.concat(definition.implicit);
        if (definition.explicit)
          explicit = explicit.concat(definition.explicit);
      } else {
        throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type3) {
        if (!(type3 instanceof Type2)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type3.loadKind && type3.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type3.multi) {
          throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type3) {
        if (!(type3 instanceof Type2)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema2.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    module.exports = Schema2;
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/str.js"(exports, module) {
    "use strict";
    var Type2 = require_type();
    module.exports = new Type2("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/seq.js"(exports, module) {
    "use strict";
    var Type2 = require_type();
    module.exports = new Type2("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/map.js"(exports, module) {
    "use strict";
    var Type2 = require_type();
    module.exports = new Type2("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/schema/failsafe.js"(exports, module) {
    "use strict";
    var Schema2 = require_schema();
    module.exports = new Schema2({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/null.js"(exports, module) {
    "use strict";
    var Type2 = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max3 = data.length;
      return max3 === 1 && data === "~" || max3 === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module.exports = new Type2("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/bool.js"(exports, module) {
    "use strict";
    var Type2 = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max3 = data.length;
      return max3 === 4 && (data === "true" || data === "True" || data === "TRUE") || max3 === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module.exports = new Type2("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/int.js"(exports, module) {
    "use strict";
    var common = require_common();
    var Type2 = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max3 = data.length, index = 0, hasDigits = false, ch;
      if (!max3)
        return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max3)
          return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max3; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max3; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index++;
          for (; index < max3; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isOctCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_")
        return false;
      for (; index < max3; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      return true;
    }
    function constructYamlInteger(data) {
      var value2 = data, sign = 1, ch;
      if (value2.indexOf("_") !== -1) {
        value2 = value2.replace(/_/g, "");
      }
      ch = value2[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value2 = value2.slice(1);
        ch = value2[0];
      }
      if (value2 === "0")
        return 0;
      if (ch === "0") {
        if (value2[1] === "b")
          return sign * parseInt(value2.slice(2), 2);
        if (value2[1] === "x")
          return sign * parseInt(value2.slice(2), 16);
        if (value2[1] === "o")
          return sign * parseInt(value2.slice(2), 8);
      }
      return sign * parseInt(value2, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module.exports = new Type2("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/float.js"(exports, module) {
    "use strict";
    var common = require_common();
    var Type2 = require_type();
    var YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value2, sign;
      value2 = data.replace(/_/g, "").toLowerCase();
      sign = value2[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value2[0]) >= 0) {
        value2 = value2.slice(1);
      }
      if (value2 === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value2 === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value2, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module.exports = new Type2("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/schema/json.js
var require_json = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/schema/json.js"(exports, module) {
    "use strict";
    module.exports = require_failsafe().extend({
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/schema/core.js
var require_core4 = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/schema/core.js"(exports, module) {
    "use strict";
    module.exports = require_json();
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/timestamp.js"(exports, module) {
    "use strict";
    var Type2 = require_type();
    var YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match3, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match3 = YAML_DATE_REGEXP.exec(data);
      if (match3 === null)
        match3 = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match3 === null)
        throw new Error("Date resolve error");
      year = +match3[1];
      month = +match3[2] - 1;
      day = +match3[3];
      if (!match3[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match3[4];
      minute = +match3[5];
      second = +match3[6];
      if (match3[7]) {
        fraction = match3[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match3[9]) {
        tz_hour = +match3[10];
        tz_minute = +(match3[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match3[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module.exports = new Type2("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/merge.js"(exports, module) {
    "use strict";
    var Type2 = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module.exports = new Type2("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/binary.js
var require_binary = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/binary.js"(exports, module) {
    "use strict";
    var Type2 = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max3 = data.length, map4 = BASE64_MAP;
      for (idx = 0; idx < max3; idx++) {
        code = map4.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max3 = input.length, map4 = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max3; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map4.indexOf(input.charAt(idx));
      }
      tailbits = max3 % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail2, max3 = object.length, map4 = BASE64_MAP;
      for (idx = 0; idx < max3; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map4[bits >> 18 & 63];
          result += map4[bits >> 12 & 63];
          result += map4[bits >> 6 & 63];
          result += map4[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail2 = max3 % 3;
      if (tail2 === 0) {
        result += map4[bits >> 18 & 63];
        result += map4[bits >> 12 & 63];
        result += map4[bits >> 6 & 63];
        result += map4[bits & 63];
      } else if (tail2 === 2) {
        result += map4[bits >> 10 & 63];
        result += map4[bits >> 4 & 63];
        result += map4[bits << 2 & 63];
        result += map4[64];
      } else if (tail2 === 1) {
        result += map4[bits >> 2 & 63];
        result += map4[bits << 4 & 63];
        result += map4[64];
        result += map4[64];
      }
      return result;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    module.exports = new Type2("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/omap.js"(exports, module) {
    "use strict";
    var Type2 = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString2 = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index, length4, pair3, pairKey, pairHasKey, object = data;
      for (index = 0, length4 = object.length; index < length4; index += 1) {
        pair3 = object[index];
        pairHasKey = false;
        if (_toString2.call(pair3) !== "[object Object]")
          return false;
        for (pairKey in pair3) {
          if (_hasOwnProperty.call(pair3, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module.exports = new Type2("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/pairs.js"(exports, module) {
    "use strict";
    var Type2 = require_type();
    var _toString2 = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index, length4, pair3, keys4, result, object = data;
      result = new Array(object.length);
      for (index = 0, length4 = object.length; index < length4; index += 1) {
        pair3 = object[index];
        if (_toString2.call(pair3) !== "[object Object]")
          return false;
        keys4 = Object.keys(pair3);
        if (keys4.length !== 1)
          return false;
        result[index] = [keys4[0], pair3[keys4[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length4, pair3, keys4, result, object = data;
      result = new Array(object.length);
      for (index = 0, length4 = object.length; index < length4; index += 1) {
        pair3 = object[index];
        keys4 = Object.keys(pair3);
        result[index] = [keys4[0], pair3[keys4[0]]];
      }
      return result;
    }
    module.exports = new Type2("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/type/set.js"(exports, module) {
    "use strict";
    var Type2 = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module.exports = new Type2("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/schema/default.js"(exports, module) {
    "use strict";
    module.exports = require_core4().extend({
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/loader.js"(exports, module) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var makeSnippet = require_snippet();
    var DEFAULT_SCHEMA = require_default();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? " " : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode(
        (c - 65536 >> 10) + 55296,
        (c - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        // omit trailing \0
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = makeSnippet(mark);
      return new YAMLException(message, mark);
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match3, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match3 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match3 === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match3[1], 10);
        minor = parseInt(match3[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type3, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type3 = state.implicitTypes[typeIndex];
          if (type3.resolve(state.result)) {
            state.result = type3.construct(state.result);
            state.tag = type3.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type3 = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type3 = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type3 = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type3) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type3.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type3.kind + '", not "' + state.kind + '"');
        }
        if (!type3.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type3.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length4 = documents.length; index < length4; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    module.exports.loadAll = loadAll;
    module.exports.load = load;
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/lib/dumper.js"(exports, module) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_SCHEMA = require_default();
    var _toString2 = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema, map4) {
      var result, keys4, index, length4, tag, style, type3;
      if (map4 === null)
        return {};
      result = {};
      keys4 = Object.keys(map4);
      for (index = 0, length4 = keys4.length; index < length4; index += 1) {
        tag = keys4[index];
        style = String(map4[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type3 = schema.compiledTypeMap["fallback"][tag];
        if (type3 && _hasOwnProperty.call(type3.styleAliases, style)) {
          style = type3.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string2, handle, length4;
      string2 = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length4 = 2;
      } else if (character <= 65535) {
        handle = "u";
        length4 = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length4 = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length4 - string2.length) + string2;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State(options) {
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options["forceQuotes"] || false;
      this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string2, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length4 = string2.length;
      while (position < length4) {
        next = string2.indexOf("\n", position);
        if (next === -1) {
          line = string2.slice(position);
          position = length4;
        } else {
          line = string2.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length4, type3;
      for (index = 0, length4 = state.implicitTypes.length; index < length4; index += 1) {
        type3 = state.implicitTypes[index];
        if (type3.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
    }
    function isNsCharOrWhitespace(c) {
      return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
      return (
        // ns-plain-safe
        (inblock ? (
          // c = flow-in
          cIsNsCharOrWhitespace
        ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
      );
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c) {
      return !isWhitespace(c) && c !== CHAR_COLON;
    }
    function codePointAt(string2, pos) {
      var first = string2.charCodeAt(pos), second;
      if (first >= 55296 && first <= 56319 && pos + 1 < string2.length) {
        second = string2.charCodeAt(pos + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string2) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string2);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i;
      var char = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt(string2, 0)) && isPlainSafeLast(codePointAt(string2, string2.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt(string2, i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
      } else {
        for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt(string2, i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string2)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string2)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string2, level, iskey, inblock) {
      state.dump = function() {
        if (string2.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string3) {
          return testImplicitResolving(state, string3);
        }
        switch (chooseScalarStyle(
          string2,
          singleLineOnly,
          state.indent,
          lineWidth,
          testAmbiguity,
          state.quotingType,
          state.forceQuotes && !iskey,
          inblock
        )) {
          case STYLE_PLAIN:
            return string2;
          case STYLE_SINGLE:
            return "'" + string2.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(string2, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string2, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string2, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
      var clip = string2[string2.length - 1] === "\n";
      var keep = clip && (string2[string2.length - 2] === "\n" || string2 === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string2) {
      return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
    }
    function foldString(string2, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string2.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string2.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string2.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
      var moreIndented;
      var match3;
      while (match3 = lineRe.exec(string2)) {
        var prefix = match3[1], line = match3[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match3;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match3 = breakRe.exec(line)) {
        next = match3.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string2) {
      var result = "";
      var char = 0;
      var escapeSeq;
      for (var i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string2, i);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
          result += string2[i];
          if (char >= 65536)
            result += string2[i + 1];
        } else {
          result += escapeSeq || encodeHex(char);
        }
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length4, value2;
      for (index = 0, length4 = object.length; index < length4; index += 1) {
        value2 = object[index];
        if (state.replacer) {
          value2 = state.replacer.call(object, String(index), value2);
        }
        if (writeNode(state, level, value2, false, false) || typeof value2 === "undefined" && writeNode(state, level, null, false, false)) {
          if (_result !== "")
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length4, value2;
      for (index = 0, length4 = object.length; index < length4; index += 1) {
        value2 = object[index];
        if (state.replacer) {
          value2 = state.replacer.call(object, String(index), value2);
        }
        if (writeNode(state, level + 1, value2, true, true, false, true) || typeof value2 === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length4, objectKey, objectValue, pairBuffer;
      for (index = 0, length4 = objectKeyList.length; index < length4; index += 1) {
        pairBuffer = "";
        if (_result !== "")
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length4, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length4 = objectKeyList.length; index < length4; index += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length4, type3, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length4 = typeList.length; index < length4; index += 1) {
        type3 = typeList[index];
        if ((type3.instanceOf || type3.predicate) && (!type3.instanceOf || typeof object === "object" && object instanceof type3.instanceOf) && (!type3.predicate || type3.predicate(object))) {
          if (explicit) {
            if (type3.multi && type3.representName) {
              state.tag = type3.representName(object);
            } else {
              state.tag = type3.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type3.represent) {
            style = state.styleMap[type3.tag] || type3.defaultStyle;
            if (_toString2.call(type3.represent) === "[object Function]") {
              _result = type3.represent(object, style);
            } else if (_hasOwnProperty.call(type3.represent, style)) {
              _result = type3.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type3.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type3 = _toString2.call(state.dump);
      var inblock = block;
      var tagStr;
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type3 === "[object Object]" || type3 === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type3 === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type3 === "[object Array]") {
          if (block && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type3 === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey, inblock);
          }
        } else if (type3 === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type3);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(
            state.tag[0] === "!" ? state.tag.slice(1) : state.tag
          ).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length4;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length4 = duplicatesIndexes.length; index < length4; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length4);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length4;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length4 = object.length; index < length4; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length4 = objectKeyList.length; index < length4; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      var value2 = input;
      if (state.replacer) {
        value2 = state.replacer.call({ "": value2 }, "", value2);
      }
      if (writeNode(state, 0, value2, true, true))
        return state.dump + "\n";
      return "";
    }
    module.exports.dump = dump;
  }
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/index.js
var require_js_yaml = __commonJS({
  "node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/index.js"(exports, module) {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function renamed(from, to) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
      };
    }
    module.exports.Type = require_type();
    module.exports.Schema = require_schema();
    module.exports.FAILSAFE_SCHEMA = require_failsafe();
    module.exports.JSON_SCHEMA = require_json();
    module.exports.CORE_SCHEMA = require_core4();
    module.exports.DEFAULT_SCHEMA = require_default();
    module.exports.load = loader.load;
    module.exports.loadAll = loader.loadAll;
    module.exports.dump = dumper.dump;
    module.exports.YAMLException = require_exception();
    module.exports.types = {
      binary: require_binary(),
      float: require_float(),
      map: require_map(),
      null: require_null(),
      pairs: require_pairs(),
      set: require_set(),
      timestamp: require_timestamp(),
      bool: require_bool(),
      int: require_int(),
      merge: require_merge(),
      omap: require_omap(),
      seq: require_seq(),
      str: require_str()
    };
    module.exports.safeLoad = renamed("safeLoad", "load");
    module.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
    module.exports.safeDump = renamed("safeDump", "dump");
  }
});

// node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/loaders.js
var require_loaders2 = __commonJS({
  "node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/loaders.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadTs = exports.loadTsSync = exports.loadYaml = exports.loadJson = exports.loadJs = exports.loadJsSync = void 0;
    var fs_1 = require_fs();
    var promises_1 = require_promises();
    var path_1 = __importDefault(require_path());
    var url_1 = require_url();
    var importFresh;
    var loadJsSync = function loadJsSync2(filepath) {
      if (importFresh === void 0) {
        importFresh = require_import_fresh();
      }
      return importFresh(filepath);
    };
    exports.loadJsSync = loadJsSync;
    var loadJs = async function loadJs2(filepath) {
      try {
        const { href } = (0, url_1.pathToFileURL)(filepath);
        return (await import(href)).default;
      } catch (error) {
        return (0, exports.loadJsSync)(filepath, "");
      }
    };
    exports.loadJs = loadJs;
    var parseJson;
    var loadJson = function loadJson2(filepath, content) {
      if (parseJson === void 0) {
        parseJson = require_parse_json();
      }
      try {
        return parseJson(content);
      } catch (error) {
        error.message = `JSON Error in ${filepath}:
${error.message}`;
        throw error;
      }
    };
    exports.loadJson = loadJson;
    var yaml;
    var loadYaml = function loadYaml2(filepath, content) {
      if (yaml === void 0) {
        yaml = require_js_yaml();
      }
      try {
        return yaml.load(content);
      } catch (error) {
        error.message = `YAML Error in ${filepath}:
${error.message}`;
        throw error;
      }
    };
    exports.loadYaml = loadYaml;
    var typescript;
    var loadTsSync = function loadTsSync2(filepath, content) {
      if (typescript === void 0) {
        typescript = require_typescript();
      }
      const compiledFilepath = `${filepath.slice(0, -2)}cjs`;
      try {
        const config = resolveTsConfig(path_1.default.dirname(filepath)) ?? {};
        config.compilerOptions = {
          ...config.compilerOptions,
          module: typescript.ModuleKind.NodeNext,
          moduleResolution: typescript.ModuleResolutionKind.NodeNext,
          target: typescript.ScriptTarget.ES2022,
          noEmit: false
        };
        content = typescript.transpileModule(content, config).outputText;
        (0, fs_1.writeFileSync)(compiledFilepath, content);
        return (0, exports.loadJsSync)(compiledFilepath, content).default;
      } catch (error) {
        error.message = `TypeScript Error in ${filepath}:
${error.message}`;
        throw error;
      } finally {
        if ((0, fs_1.existsSync)(compiledFilepath)) {
          (0, fs_1.rmSync)(compiledFilepath);
        }
      }
    };
    exports.loadTsSync = loadTsSync;
    var loadTs = async function loadTs2(filepath, content) {
      if (typescript === void 0) {
        typescript = (await import("./typescript-TE4FOJE3.js")).default;
      }
      const compiledFilepath = `${filepath.slice(0, -2)}mjs`;
      try {
        const config = resolveTsConfig(path_1.default.dirname(filepath)) ?? {};
        config.compilerOptions = {
          ...config.compilerOptions,
          module: typescript.ModuleKind.ES2022,
          moduleResolution: typescript.ModuleResolutionKind.Bundler,
          target: typescript.ScriptTarget.ES2022,
          noEmit: false
        };
        content = typescript.transpileModule(content, config).outputText;
        await (0, promises_1.writeFile)(compiledFilepath, content);
        const { href } = (0, url_1.pathToFileURL)(compiledFilepath);
        return (await import(href)).default;
      } catch (error) {
        error.message = `TypeScript Error in ${filepath}:
${error.message}`;
        throw error;
      } finally {
        if ((0, fs_1.existsSync)(compiledFilepath)) {
          await (0, promises_1.rm)(compiledFilepath);
        }
      }
    };
    exports.loadTs = loadTs;
    function resolveTsConfig(directory) {
      const filePath = typescript.findConfigFile(directory, (fileName) => {
        return typescript.sys.fileExists(fileName);
      });
      if (filePath !== void 0) {
        const { config, error } = typescript.readConfigFile(filePath, (path3) => typescript.sys.readFile(path3));
        if (error) {
          throw new Error(`Error in ${filePath}: ${error.messageText.toString()}`);
        }
        return config;
      }
      return;
    }
  }
});

// node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/Explorer.js
var require_Explorer2 = __commonJS({
  "node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/Explorer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Explorer = void 0;
    var promises_1 = __importDefault(require_promises());
    var path_1 = __importDefault(require_path());
    var path_type_1 = require_path_type();
    var ExplorerBase_js_1 = require_ExplorerBase2();
    var loaders_js_1 = require_loaders2();
    var util_js_1 = require_util3();
    var _readConfiguration, readConfiguration_fn, _loadConfiguration, loadConfiguration_fn;
    var Explorer = class extends ExplorerBase_js_1.ExplorerBase {
      constructor() {
        super(...arguments);
        __privateAdd(this, _readConfiguration);
        __privateAdd(this, _loadConfiguration);
      }
      async load(filepath) {
        filepath = path_1.default.resolve(filepath);
        const load = async () => {
          return await this.config.transform(await __privateMethod(this, _readConfiguration, readConfiguration_fn).call(this, filepath));
        };
        if (this.loadCache) {
          return await (0, util_js_1.emplace)(this.loadCache, filepath, load);
        }
        return await load();
      }
      async search(from = "") {
        if (this.config.metaConfigFilePath) {
          this.loadingMetaConfig = true;
          const config = await this.load(this.config.metaConfigFilePath);
          this.loadingMetaConfig = false;
          if (config && !config.isEmpty) {
            return config;
          }
        }
        const stopDir = path_1.default.resolve(this.config.stopDir);
        from = path_1.default.resolve(from);
        const search = async () => {
          if (await (0, path_type_1.isDirectory)(from)) {
            for (const place of this.config.searchPlaces) {
              const filepath = path_1.default.join(from, place);
              try {
                const result = await __privateMethod(this, _readConfiguration, readConfiguration_fn).call(this, filepath);
                if (result !== null && !(result.isEmpty && this.config.ignoreEmptySearchPlaces)) {
                  return await this.config.transform(result);
                }
              } catch (error) {
                if (error.code === "ENOENT" || error.code === "EISDIR" || error.code === "ENOTDIR") {
                  continue;
                }
                throw error;
              }
            }
          }
          const dir = path_1.default.dirname(from);
          if (from !== stopDir && from !== dir) {
            from = dir;
            if (this.searchCache) {
              return await (0, util_js_1.emplace)(this.searchCache, from, search);
            }
            return await search();
          }
          return await this.config.transform(null);
        };
        if (this.searchCache) {
          return await (0, util_js_1.emplace)(this.searchCache, from, search);
        }
        return await search();
      }
    };
    _readConfiguration = new WeakSet();
    readConfiguration_fn = async function(filepath) {
      const contents = await promises_1.default.readFile(filepath, { encoding: "utf-8" });
      return this.toCosmiconfigResult(filepath, await __privateMethod(this, _loadConfiguration, loadConfiguration_fn).call(this, filepath, contents));
    };
    _loadConfiguration = new WeakSet();
    loadConfiguration_fn = async function(filepath, contents) {
      if (contents.trim() === "") {
        return;
      }
      if (path_1.default.basename(filepath) === "package.json") {
        return (0, util_js_1.getPropertyByPath)((0, loaders_js_1.loadJson)(filepath, contents), this.config.packageProp) ?? null;
      }
      const extension = path_1.default.extname(filepath);
      try {
        const loader = this.config.loaders[extension || "noExt"] ?? this.config.loaders["default"];
        if (loader !== void 0) {
          return await loader(filepath, contents);
        }
      } catch (error) {
        error.filepath = filepath;
        throw error;
      }
      throw new Error(`No loader specified for ${(0, ExplorerBase_js_1.getExtensionDescription)(extension)}`);
    };
    exports.Explorer = Explorer;
  }
});

// node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/ExplorerSync.js
var require_ExplorerSync2 = __commonJS({
  "node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/ExplorerSync.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExplorerSync = void 0;
    var fs_1 = __importDefault(require_fs());
    var path_1 = __importDefault(require_path());
    var path_type_1 = require_path_type();
    var ExplorerBase_js_1 = require_ExplorerBase2();
    var loaders_js_1 = require_loaders2();
    var util_js_1 = require_util3();
    var _readConfiguration, readConfiguration_fn, _loadConfiguration, loadConfiguration_fn;
    var ExplorerSync = class extends ExplorerBase_js_1.ExplorerBase {
      constructor() {
        super(...arguments);
        __privateAdd(this, _readConfiguration);
        __privateAdd(this, _loadConfiguration);
      }
      load(filepath) {
        filepath = path_1.default.resolve(filepath);
        const load = () => {
          return this.config.transform(__privateMethod(this, _readConfiguration, readConfiguration_fn).call(this, filepath));
        };
        if (this.loadCache) {
          return (0, util_js_1.emplace)(this.loadCache, filepath, load);
        }
        return load();
      }
      search(from = "") {
        if (this.config.metaConfigFilePath) {
          this.loadingMetaConfig = true;
          const config = this.load(this.config.metaConfigFilePath);
          this.loadingMetaConfig = false;
          if (config && !config.isEmpty) {
            return config;
          }
        }
        const stopDir = path_1.default.resolve(this.config.stopDir);
        from = path_1.default.resolve(from);
        const search = () => {
          if ((0, path_type_1.isDirectorySync)(from)) {
            for (const place of this.config.searchPlaces) {
              const filepath = path_1.default.join(from, place);
              try {
                const result = __privateMethod(this, _readConfiguration, readConfiguration_fn).call(this, filepath);
                if (result !== null && !(result.isEmpty && this.config.ignoreEmptySearchPlaces)) {
                  return this.config.transform(result);
                }
              } catch (error) {
                if (error.code === "ENOENT" || error.code === "EISDIR" || error.code === "ENOTDIR") {
                  continue;
                }
                throw error;
              }
            }
          }
          const dir = path_1.default.dirname(from);
          if (from !== stopDir && from !== dir) {
            from = dir;
            if (this.searchCache) {
              return (0, util_js_1.emplace)(this.searchCache, from, search);
            }
            return search();
          }
          return this.config.transform(null);
        };
        if (this.searchCache) {
          return (0, util_js_1.emplace)(this.searchCache, from, search);
        }
        return search();
      }
      /**
       * @deprecated Use {@link ExplorerSync.prototype.load}.
       */
      /* istanbul ignore next */
      loadSync(filepath) {
        return this.load(filepath);
      }
      /**
       * @deprecated Use {@link ExplorerSync.prototype.search}.
       */
      /* istanbul ignore next */
      searchSync(from = "") {
        return this.search(from);
      }
    };
    _readConfiguration = new WeakSet();
    readConfiguration_fn = function(filepath) {
      const contents = fs_1.default.readFileSync(filepath, "utf8");
      return this.toCosmiconfigResult(filepath, __privateMethod(this, _loadConfiguration, loadConfiguration_fn).call(this, filepath, contents));
    };
    _loadConfiguration = new WeakSet();
    loadConfiguration_fn = function(filepath, contents) {
      if (contents.trim() === "") {
        return;
      }
      if (path_1.default.basename(filepath) === "package.json") {
        return (0, util_js_1.getPropertyByPath)((0, loaders_js_1.loadJson)(filepath, contents), this.config.packageProp) ?? null;
      }
      const extension = path_1.default.extname(filepath);
      try {
        const loader = this.config.loaders[extension || "noExt"] ?? this.config.loaders["default"];
        if (loader !== void 0) {
          return loader(filepath, contents);
        }
      } catch (error) {
        error.filepath = filepath;
        throw error;
      }
      throw new Error(`No loader specified for ${(0, ExplorerBase_js_1.getExtensionDescription)(extension)}`);
    };
    exports.ExplorerSync = ExplorerSync;
  }
});

// node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/.pnpm/cosmiconfig@8.3.6_typescript@4.9.5/node_modules/cosmiconfig/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o3, k2, desc);
    } : function(o3, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o3[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cosmiconfigSync = exports.cosmiconfig = exports.defaultLoadersSync = exports.defaultLoaders = exports.metaSearchPlaces = void 0;
    __exportStar(require_types2(), exports);
    var os_1 = __importDefault(require_os());
    var Explorer_js_1 = require_Explorer2();
    var ExplorerSync_js_1 = require_ExplorerSync2();
    var loaders_js_1 = require_loaders2();
    var util_1 = require_util3();
    exports.metaSearchPlaces = [
      "package.json",
      ".config.json",
      ".config.yaml",
      ".config.yml",
      ".config.js",
      ".config.ts",
      ".config.cjs",
      ".config.mjs"
    ];
    exports.defaultLoaders = Object.freeze({
      ".mjs": loaders_js_1.loadJs,
      ".cjs": loaders_js_1.loadJs,
      ".js": loaders_js_1.loadJs,
      ".ts": loaders_js_1.loadTs,
      ".json": loaders_js_1.loadJson,
      ".yaml": loaders_js_1.loadYaml,
      ".yml": loaders_js_1.loadYaml,
      noExt: loaders_js_1.loadYaml
    });
    exports.defaultLoadersSync = Object.freeze({
      ".cjs": loaders_js_1.loadJsSync,
      ".js": loaders_js_1.loadJsSync,
      ".ts": loaders_js_1.loadTsSync,
      ".json": loaders_js_1.loadJson,
      ".yaml": loaders_js_1.loadYaml,
      ".yml": loaders_js_1.loadYaml,
      noExt: loaders_js_1.loadYaml
    });
    var identity2 = function identity3(x) {
      return x;
    };
    function getInternalOptions(moduleName, options) {
      var _a;
      const metaExplorer = new ExplorerSync_js_1.ExplorerSync({
        packageProp: "cosmiconfig",
        stopDir: process.cwd(),
        searchPlaces: exports.metaSearchPlaces,
        ignoreEmptySearchPlaces: false,
        applyPackagePropertyPathToConfiguration: true,
        loaders: exports.defaultLoaders,
        transform: identity2,
        cache: true,
        metaConfigFilePath: null
      });
      const metaConfig = metaExplorer.search();
      if (!metaConfig) {
        return options;
      }
      if ((_a = metaConfig.config) == null ? void 0 : _a.loaders) {
        throw new Error("Can not specify loaders in meta config file");
      }
      const overrideOptions = metaConfig.config ?? {};
      if (overrideOptions.searchPlaces) {
        overrideOptions.searchPlaces = overrideOptions.searchPlaces.map((path3) => path3.replace("{name}", moduleName));
      }
      overrideOptions.metaConfigFilePath = metaConfig.filepath;
      return { ...options, ...(0, util_1.removeUndefinedValuesFromObject)(overrideOptions) };
    }
    function normalizeOptions(moduleName, options) {
      const defaults = {
        packageProp: moduleName,
        searchPlaces: [
          "package.json",
          `.${moduleName}rc`,
          `.${moduleName}rc.json`,
          `.${moduleName}rc.yaml`,
          `.${moduleName}rc.yml`,
          `.${moduleName}rc.js`,
          `.${moduleName}rc.ts`,
          `.${moduleName}rc.cjs`,
          `.${moduleName}rc.mjs`,
          `.config/${moduleName}rc`,
          `.config/${moduleName}rc.json`,
          `.config/${moduleName}rc.yaml`,
          `.config/${moduleName}rc.yml`,
          `.config/${moduleName}rc.js`,
          `.config/${moduleName}rc.ts`,
          `.config/${moduleName}rc.cjs`,
          `.config/${moduleName}rc.mjs`,
          `${moduleName}.config.js`,
          `${moduleName}.config.ts`,
          `${moduleName}.config.cjs`,
          `${moduleName}.config.mjs`
        ],
        ignoreEmptySearchPlaces: true,
        stopDir: os_1.default.homedir(),
        cache: true,
        transform: identity2,
        loaders: exports.defaultLoaders,
        metaConfigFilePath: null
      };
      return {
        ...defaults,
        ...(0, util_1.removeUndefinedValuesFromObject)(options),
        loaders: {
          ...defaults.loaders,
          ...options.loaders
        }
      };
    }
    function normalizeOptionsSync(moduleName, options) {
      const defaults = {
        packageProp: moduleName,
        searchPlaces: [
          "package.json",
          `.${moduleName}rc`,
          `.${moduleName}rc.json`,
          `.${moduleName}rc.yaml`,
          `.${moduleName}rc.yml`,
          `.${moduleName}rc.js`,
          `.${moduleName}rc.ts`,
          `.${moduleName}rc.cjs`,
          `.config/${moduleName}rc`,
          `.config/${moduleName}rc.json`,
          `.config/${moduleName}rc.yaml`,
          `.config/${moduleName}rc.yml`,
          `.config/${moduleName}rc.js`,
          `.config/${moduleName}rc.ts`,
          `.config/${moduleName}rc.cjs`,
          `${moduleName}.config.js`,
          `${moduleName}.config.ts`,
          `${moduleName}.config.cjs`
        ],
        ignoreEmptySearchPlaces: true,
        stopDir: os_1.default.homedir(),
        cache: true,
        transform: identity2,
        loaders: exports.defaultLoadersSync,
        metaConfigFilePath: null
      };
      return {
        ...defaults,
        ...(0, util_1.removeUndefinedValuesFromObject)(options),
        loaders: {
          ...defaults.loaders,
          ...options.loaders
        }
      };
    }
    function cosmiconfig(moduleName, options = {}) {
      const internalOptions = getInternalOptions(moduleName, options);
      const normalizedOptions = normalizeOptions(moduleName, internalOptions);
      const explorer = new Explorer_js_1.Explorer(normalizedOptions);
      return {
        search: explorer.search.bind(explorer),
        load: explorer.load.bind(explorer),
        clearLoadCache: explorer.clearLoadCache.bind(explorer),
        clearSearchCache: explorer.clearSearchCache.bind(explorer),
        clearCaches: explorer.clearCaches.bind(explorer)
      };
    }
    exports.cosmiconfig = cosmiconfig;
    function cosmiconfigSync(moduleName, options = {}) {
      const internalOptions = getInternalOptions(moduleName, options);
      const normalizedOptions = normalizeOptionsSync(moduleName, internalOptions);
      const explorerSync = new ExplorerSync_js_1.ExplorerSync(normalizedOptions);
      return {
        search: explorerSync.search.bind(explorerSync),
        load: explorerSync.load.bind(explorerSync),
        clearLoadCache: explorerSync.clearLoadCache.bind(explorerSync),
        clearSearchCache: explorerSync.clearSearchCache.bind(explorerSync),
        clearCaches: explorerSync.clearCaches.bind(explorerSync)
      };
    }
    exports.cosmiconfigSync = cosmiconfigSync;
  }
});

// node_modules/.pnpm/leven@3.1.0/node_modules/leven/index.js
var require_leven = __commonJS({
  "node_modules/.pnpm/leven@3.1.0/node_modules/leven/index.js"(exports, module) {
    "use strict";
    var array = [];
    var charCodeCache = [];
    var leven = (left, right) => {
      if (left === right) {
        return 0;
      }
      const swap = left;
      if (left.length > right.length) {
        left = right;
        right = swap;
      }
      let leftLength = left.length;
      let rightLength = right.length;
      while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
        leftLength--;
        rightLength--;
      }
      let start = 0;
      while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
        start++;
      }
      leftLength -= start;
      rightLength -= start;
      if (leftLength === 0) {
        return rightLength;
      }
      let bCharCode;
      let result;
      let temp;
      let temp2;
      let i = 0;
      let j = 0;
      while (i < leftLength) {
        charCodeCache[i] = left.charCodeAt(start + i);
        array[i] = ++i;
      }
      while (j < rightLength) {
        bCharCode = right.charCodeAt(start + j);
        temp = j++;
        result = j;
        for (i = 0; i < leftLength; i++) {
          temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;
          temp = array[i];
          result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
        }
      }
      return result;
    };
    module.exports = leven;
    module.exports.default = leven;
  }
});

// node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/collections.js
var require_collections = __commonJS({
  "node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/collections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printIteratorEntries = printIteratorEntries;
    exports.printIteratorValues = printIteratorValues;
    exports.printListItems = printListItems;
    exports.printObjectProperties = printObjectProperties;
    var getKeysOfEnumerableProperties = (object) => {
      const keys4 = Object.keys(object).sort();
      if (Object.getOwnPropertySymbols) {
        Object.getOwnPropertySymbols(object).forEach((symbol) => {
          if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
            keys4.push(symbol);
          }
        });
      }
      return keys4;
    };
    function printIteratorEntries(iterator, config, indentation, depth, refs, printer, separator = ": ") {
      let result = "";
      let current = iterator.next();
      if (!current.done) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        while (!current.done) {
          const name = printer(
            current.value[0],
            config,
            indentationNext,
            depth,
            refs
          );
          const value2 = printer(
            current.value[1],
            config,
            indentationNext,
            depth,
            refs
          );
          result += indentationNext + name + separator + value2;
          current = iterator.next();
          if (!current.done) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
      let result = "";
      let current = iterator.next();
      if (!current.done) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        while (!current.done) {
          result += indentationNext + printer(current.value, config, indentationNext, depth, refs);
          current = iterator.next();
          if (!current.done) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    function printListItems(list, config, indentation, depth, refs, printer) {
      let result = "";
      if (list.length) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        for (let i = 0; i < list.length; i++) {
          result += indentationNext + printer(list[i], config, indentationNext, depth, refs);
          if (i < list.length - 1) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    function printObjectProperties(val, config, indentation, depth, refs, printer) {
      let result = "";
      const keys4 = getKeysOfEnumerableProperties(val);
      if (keys4.length) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        for (let i = 0; i < keys4.length; i++) {
          const key = keys4[i];
          const name = printer(key, config, indentationNext, depth, refs);
          const value2 = printer(val[key], config, indentationNext, depth, refs);
          result += indentationNext + name + ": " + value2;
          if (i < keys4.length - 1) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
  }
});

// node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/AsymmetricMatcher.js
var require_AsymmetricMatcher = __commonJS({
  "node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/AsymmetricMatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.test = exports.serialize = void 0;
    var _collections = require_collections();
    var Symbol2 = global["jest-symbol-do-not-touch"] || global.Symbol;
    var asymmetricMatcher = typeof Symbol2 === "function" && Symbol2.for ? Symbol2.for("jest.asymmetricMatcher") : 1267621;
    var SPACE = " ";
    var serialize = (val, config, indentation, depth, refs, printer) => {
      const stringedValue = val.toString();
      if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
        if (++depth > config.maxDepth) {
          return "[" + stringedValue + "]";
        }
        return stringedValue + SPACE + "[" + (0, _collections.printListItems)(
          val.sample,
          config,
          indentation,
          depth,
          refs,
          printer
        ) + "]";
      }
      if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
        if (++depth > config.maxDepth) {
          return "[" + stringedValue + "]";
        }
        return stringedValue + SPACE + "{" + (0, _collections.printObjectProperties)(
          val.sample,
          config,
          indentation,
          depth,
          refs,
          printer
        ) + "}";
      }
      if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
        return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
      }
      if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
        return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
      }
      return val.toAsymmetricMatcher();
    };
    exports.serialize = serialize;
    var test3 = (val) => val && val.$$typeof === asymmetricMatcher;
    exports.test = test3;
    var plugin = {
      serialize,
      test: test3
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js"(exports, module) {
    "use strict";
    module.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/ConvertAnsi.js
var require_ConvertAnsi = __commonJS({
  "node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/ConvertAnsi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.serialize = exports.test = void 0;
    var _ansiRegex = _interopRequireDefault(require_ansi_regex());
    var _ansiStyles = _interopRequireDefault(require_ansi_styles2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var toHumanReadableAnsi = (text) => text.replace((0, _ansiRegex.default)(), (match3) => {
      switch (match3) {
        case _ansiStyles.default.red.close:
        case _ansiStyles.default.green.close:
        case _ansiStyles.default.cyan.close:
        case _ansiStyles.default.gray.close:
        case _ansiStyles.default.white.close:
        case _ansiStyles.default.yellow.close:
        case _ansiStyles.default.bgRed.close:
        case _ansiStyles.default.bgGreen.close:
        case _ansiStyles.default.bgYellow.close:
        case _ansiStyles.default.inverse.close:
        case _ansiStyles.default.dim.close:
        case _ansiStyles.default.bold.close:
        case _ansiStyles.default.reset.open:
        case _ansiStyles.default.reset.close:
          return "</>";
        case _ansiStyles.default.red.open:
          return "<red>";
        case _ansiStyles.default.green.open:
          return "<green>";
        case _ansiStyles.default.cyan.open:
          return "<cyan>";
        case _ansiStyles.default.gray.open:
          return "<gray>";
        case _ansiStyles.default.white.open:
          return "<white>";
        case _ansiStyles.default.yellow.open:
          return "<yellow>";
        case _ansiStyles.default.bgRed.open:
          return "<bgRed>";
        case _ansiStyles.default.bgGreen.open:
          return "<bgGreen>";
        case _ansiStyles.default.bgYellow.open:
          return "<bgYellow>";
        case _ansiStyles.default.inverse.open:
          return "<inverse>";
        case _ansiStyles.default.dim.open:
          return "<dim>";
        case _ansiStyles.default.bold.open:
          return "<bold>";
        default:
          return "";
      }
    });
    var test3 = (val) => typeof val === "string" && !!val.match((0, _ansiRegex.default)());
    exports.test = test3;
    var serialize = (val, config, indentation, depth, refs, printer) => printer(toHumanReadableAnsi(val), config, indentation, depth, refs);
    exports.serialize = serialize;
    var plugin = {
      serialize,
      test: test3
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/DOMCollection.js
var require_DOMCollection = __commonJS({
  "node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/DOMCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.serialize = exports.test = void 0;
    var _collections = require_collections();
    var SPACE = " ";
    var OBJECT_NAMES = ["DOMStringMap", "NamedNodeMap"];
    var ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
    var testName = (name) => OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
    var test3 = (val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
    exports.test = test3;
    var isNamedNodeMap = (collection) => collection.constructor.name === "NamedNodeMap";
    var serialize = (collection, config, indentation, depth, refs, printer) => {
      const name = collection.constructor.name;
      if (++depth > config.maxDepth) {
        return "[" + name + "]";
      }
      return (config.min ? "" : name + SPACE) + (OBJECT_NAMES.indexOf(name) !== -1 ? "{" + (0, _collections.printObjectProperties)(
        isNamedNodeMap(collection) ? Array.from(collection).reduce((props3, attribute) => {
          props3[attribute.name] = attribute.value;
          return props3;
        }, {}) : { ...collection },
        config,
        indentation,
        depth,
        refs,
        printer
      ) + "}" : "[" + (0, _collections.printListItems)(
        Array.from(collection),
        config,
        indentation,
        depth,
        refs,
        printer
      ) + "]");
    };
    exports.serialize = serialize;
    var plugin = {
      serialize,
      test: test3
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/lib/escapeHTML.js
var require_escapeHTML = __commonJS({
  "node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/lib/escapeHTML.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = escapeHTML;
    function escapeHTML(str) {
      return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
  }
});

// node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/lib/markup.js
var require_markup = __commonJS({
  "node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/lib/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printElementAsLeaf = exports.printElement = exports.printComment = exports.printText = exports.printChildren = exports.printProps = void 0;
    var _escapeHTML = _interopRequireDefault(require_escapeHTML());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var printProps = (keys4, props3, config, indentation, depth, refs, printer) => {
      const indentationNext = indentation + config.indent;
      const colors = config.colors;
      return keys4.map((key) => {
        const value2 = props3[key];
        let printed = printer(value2, config, indentationNext, depth, refs);
        if (typeof value2 !== "string") {
          if (printed.indexOf("\n") !== -1) {
            printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
          }
          printed = "{" + printed + "}";
        }
        return config.spacingInner + indentation + colors.prop.open + key + colors.prop.close + "=" + colors.value.open + printed + colors.value.close;
      }).join("");
    };
    exports.printProps = printProps;
    var printChildren = (children, config, indentation, depth, refs, printer) => children.map(
      (child) => config.spacingOuter + indentation + (typeof child === "string" ? printText(child, config) : printer(child, config, indentation, depth, refs))
    ).join("");
    exports.printChildren = printChildren;
    var printText = (text, config) => {
      const contentColor = config.colors.content;
      return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
    };
    exports.printText = printText;
    var printComment = (comment, config) => {
      const commentColor = config.colors.comment;
      return commentColor.open + "<!--" + (0, _escapeHTML.default)(comment) + "-->" + commentColor.close;
    };
    exports.printComment = printComment;
    var printElement = (type3, printedProps, printedChildren, config, indentation) => {
      const tagColor = config.colors.tag;
      return tagColor.open + "<" + type3 + (printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config.spacingOuter + indentation + tagColor.open + "</" + type3 : (printedProps && !config.min ? "" : " ") + "/") + ">" + tagColor.close;
    };
    exports.printElement = printElement;
    var printElementAsLeaf = (type3, config) => {
      const tagColor = config.colors.tag;
      return tagColor.open + "<" + type3 + tagColor.close + " …" + tagColor.open + " />" + tagColor.close;
    };
    exports.printElementAsLeaf = printElementAsLeaf;
  }
});

// node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/DOMElement.js
var require_DOMElement = __commonJS({
  "node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/DOMElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.serialize = exports.test = void 0;
    var _markup = require_markup();
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;
    var FRAGMENT_NODE = 11;
    var ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
    var testNode = (val) => {
      var _val$hasAttribute;
      const constructorName = val.constructor.name;
      const { nodeType, tagName } = val;
      const isCustomElement = typeof tagName === "string" && tagName.includes("-") || ((_val$hasAttribute = val.hasAttribute) === null || _val$hasAttribute === void 0 ? void 0 : _val$hasAttribute.call(val, "is"));
      return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
    };
    var test3 = (val) => {
      var _val$constructor;
      return (val === null || val === void 0 ? void 0 : (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);
    };
    exports.test = test3;
    function nodeIsText(node) {
      return node.nodeType === TEXT_NODE;
    }
    function nodeIsComment(node) {
      return node.nodeType === COMMENT_NODE;
    }
    function nodeIsFragment(node) {
      return node.nodeType === FRAGMENT_NODE;
    }
    var serialize = (node, config, indentation, depth, refs, printer) => {
      if (nodeIsText(node)) {
        return (0, _markup.printText)(node.data, config);
      }
      if (nodeIsComment(node)) {
        return (0, _markup.printComment)(node.data, config);
      }
      const type3 = nodeIsFragment(node) ? `DocumentFragment` : node.tagName.toLowerCase();
      if (++depth > config.maxDepth) {
        return (0, _markup.printElementAsLeaf)(type3, config);
      }
      return (0, _markup.printElement)(
        type3,
        (0, _markup.printProps)(
          nodeIsFragment(node) ? [] : Array.from(node.attributes).map((attr) => attr.name).sort(),
          nodeIsFragment(node) ? {} : Array.from(node.attributes).reduce((props3, attribute) => {
            props3[attribute.name] = attribute.value;
            return props3;
          }, {}),
          config,
          indentation + config.indent,
          depth,
          refs,
          printer
        ),
        (0, _markup.printChildren)(
          Array.prototype.slice.call(node.childNodes || node.children),
          config,
          indentation + config.indent,
          depth,
          refs,
          printer
        ),
        config,
        indentation
      );
    };
    exports.serialize = serialize;
    var plugin = {
      serialize,
      test: test3
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/Immutable.js
var require_Immutable = __commonJS({
  "node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/Immutable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.test = exports.serialize = void 0;
    var _collections = require_collections();
    var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
    var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
    var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
    var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
    var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
    var IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
    var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
    var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
    var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
    var getImmutableName = (name) => "Immutable." + name;
    var printAsLeaf = (name) => "[" + name + "]";
    var SPACE = " ";
    var LAZY = "…";
    var printImmutableEntries = (val, config, indentation, depth, refs, printer, type3) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type3)) : getImmutableName(type3) + SPACE + "{" + (0, _collections.printIteratorEntries)(
      val.entries(),
      config,
      indentation,
      depth,
      refs,
      printer
    ) + "}";
    function getRecordEntries(val) {
      let i = 0;
      return {
        next() {
          if (i < val._keys.length) {
            const key = val._keys[i++];
            return {
              done: false,
              value: [key, val.get(key)]
            };
          }
          return {
            done: true,
            value: void 0
          };
        }
      };
    }
    var printImmutableRecord = (val, config, indentation, depth, refs, printer) => {
      const name = getImmutableName(val._name || "Record");
      return ++depth > config.maxDepth ? printAsLeaf(name) : name + SPACE + "{" + (0, _collections.printIteratorEntries)(
        getRecordEntries(val),
        config,
        indentation,
        depth,
        refs,
        printer
      ) + "}";
    };
    var printImmutableSeq = (val, config, indentation, depth, refs, printer) => {
      const name = getImmutableName("Seq");
      if (++depth > config.maxDepth) {
        return printAsLeaf(name);
      }
      if (val[IS_KEYED_SENTINEL]) {
        return name + SPACE + "{" + // from Immutable collection of entries or from ECMAScript object
        (val._iter || val._object ? (0, _collections.printIteratorEntries)(
          val.entries(),
          config,
          indentation,
          depth,
          refs,
          printer
        ) : LAZY) + "}";
      }
      return name + SPACE + "[" + (val._iter || // from Immutable collection of values
      val._array || // from ECMAScript array
      val._collection || // from ECMAScript collection in immutable v4
      val._iterable ? (0, _collections.printIteratorValues)(
        val.values(),
        config,
        indentation,
        depth,
        refs,
        printer
      ) : LAZY) + "]";
    };
    var printImmutableValues = (val, config, indentation, depth, refs, printer, type3) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type3)) : getImmutableName(type3) + SPACE + "[" + (0, _collections.printIteratorValues)(
      val.values(),
      config,
      indentation,
      depth,
      refs,
      printer
    ) + "]";
    var serialize = (val, config, indentation, depth, refs, printer) => {
      if (val[IS_MAP_SENTINEL]) {
        return printImmutableEntries(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map"
        );
      }
      if (val[IS_LIST_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          "List"
        );
      }
      if (val[IS_SET_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set"
        );
      }
      if (val[IS_STACK_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          "Stack"
        );
      }
      if (val[IS_SEQ_SENTINEL]) {
        return printImmutableSeq(val, config, indentation, depth, refs, printer);
      }
      return printImmutableRecord(val, config, indentation, depth, refs, printer);
    };
    exports.serialize = serialize;
    var test3 = (val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
    exports.test = test3;
    var plugin = {
      serialize,
      test: test3
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/.pnpm/react-is@17.0.2/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/.pnpm/react-is@17.0.2/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var enableScopeAPI = false;
        function isValidElementType(type3) {
          if (typeof type3 === "string" || typeof type3 === "function") {
            return true;
          }
          if (type3 === REACT_FRAGMENT_TYPE || type3 === REACT_PROFILER_TYPE || type3 === REACT_DEBUG_TRACING_MODE_TYPE || type3 === REACT_STRICT_MODE_TYPE || type3 === REACT_SUSPENSE_TYPE || type3 === REACT_SUSPENSE_LIST_TYPE || type3 === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type3 === "object" && type3 !== null) {
            if (type3.$$typeof === REACT_LAZY_TYPE || type3.$$typeof === REACT_MEMO_TYPE || type3.$$typeof === REACT_PROVIDER_TYPE || type3.$$typeof === REACT_CONTEXT_TYPE || type3.$$typeof === REACT_FORWARD_REF_TYPE || type3.$$typeof === REACT_FUNDAMENTAL_TYPE || type3.$$typeof === REACT_BLOCK_TYPE || type3[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type3 = object.type;
                switch (type3) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type3;
                  default:
                    var $$typeofType = type3 && type3.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/.pnpm/react-is@17.0.2/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/.pnpm/react-is@17.0.2/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/ReactElement.js
var require_ReactElement = __commonJS({
  "node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/ReactElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.test = exports.serialize = void 0;
    var ReactIs = _interopRequireWildcard(require_react_is());
    var _markup = require_markup();
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var getChildren = (arg, children = []) => {
      if (Array.isArray(arg)) {
        arg.forEach((item) => {
          getChildren(item, children);
        });
      } else if (arg != null && arg !== false) {
        children.push(arg);
      }
      return children;
    };
    var getType = (element) => {
      const type3 = element.type;
      if (typeof type3 === "string") {
        return type3;
      }
      if (typeof type3 === "function") {
        return type3.displayName || type3.name || "Unknown";
      }
      if (ReactIs.isFragment(element)) {
        return "React.Fragment";
      }
      if (ReactIs.isSuspense(element)) {
        return "React.Suspense";
      }
      if (typeof type3 === "object" && type3 !== null) {
        if (ReactIs.isContextProvider(element)) {
          return "Context.Provider";
        }
        if (ReactIs.isContextConsumer(element)) {
          return "Context.Consumer";
        }
        if (ReactIs.isForwardRef(element)) {
          if (type3.displayName) {
            return type3.displayName;
          }
          const functionName = type3.render.displayName || type3.render.name || "";
          return functionName !== "" ? "ForwardRef(" + functionName + ")" : "ForwardRef";
        }
        if (ReactIs.isMemo(element)) {
          const functionName = type3.displayName || type3.type.displayName || type3.type.name || "";
          return functionName !== "" ? "Memo(" + functionName + ")" : "Memo";
        }
      }
      return "UNDEFINED";
    };
    var getPropKeys = (element) => {
      const { props: props3 } = element;
      return Object.keys(props3).filter((key) => key !== "children" && props3[key] !== void 0).sort();
    };
    var serialize = (element, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(getType(element), config) : (0, _markup.printElement)(
      getType(element),
      (0, _markup.printProps)(
        getPropKeys(element),
        element.props,
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ),
      (0, _markup.printChildren)(
        getChildren(element.props.children),
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ),
      config,
      indentation
    );
    exports.serialize = serialize;
    var test3 = (val) => val && ReactIs.isElement(val);
    exports.test = test3;
    var plugin = {
      serialize,
      test: test3
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/ReactTestComponent.js
var require_ReactTestComponent = __commonJS({
  "node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/plugins/ReactTestComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.test = exports.serialize = void 0;
    var _markup = require_markup();
    var Symbol2 = global["jest-symbol-do-not-touch"] || global.Symbol;
    var testSymbol = typeof Symbol2 === "function" && Symbol2.for ? Symbol2.for("react.test.json") : 245830487;
    var getPropKeys = (object) => {
      const { props: props3 } = object;
      return props3 ? Object.keys(props3).filter((key) => props3[key] !== void 0).sort() : [];
    };
    var serialize = (object, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config) : (0, _markup.printElement)(
      object.type,
      object.props ? (0, _markup.printProps)(
        getPropKeys(object),
        object.props,
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ) : "",
      object.children ? (0, _markup.printChildren)(
        object.children,
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ) : "",
      config,
      indentation
    );
    exports.serialize = serialize;
    var test3 = (val) => val && val.$$typeof === testSymbol;
    exports.test = test3;
    var plugin = {
      serialize,
      test: test3
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/index.js
var require_build2 = __commonJS({
  "node_modules/.pnpm/pretty-format@26.6.2/node_modules/pretty-format/build/index.js"(exports, module) {
    "use strict";
    var _ansiStyles = _interopRequireDefault(require_ansi_styles2());
    var _collections = require_collections();
    var _AsymmetricMatcher = _interopRequireDefault(
      require_AsymmetricMatcher()
    );
    var _ConvertAnsi = _interopRequireDefault(require_ConvertAnsi());
    var _DOMCollection = _interopRequireDefault(require_DOMCollection());
    var _DOMElement = _interopRequireDefault(require_DOMElement());
    var _Immutable = _interopRequireDefault(require_Immutable());
    var _ReactElement = _interopRequireDefault(require_ReactElement());
    var _ReactTestComponent = _interopRequireDefault(
      require_ReactTestComponent()
    );
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var toString4 = Object.prototype.toString;
    var toISOString = Date.prototype.toISOString;
    var errorToString = Error.prototype.toString;
    var regExpToString = RegExp.prototype.toString;
    var getConstructorName = (val) => typeof val.constructor === "function" && val.constructor.name || "Object";
    var isWindow = (val) => typeof window !== "undefined" && val === window;
    var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
    var NEWLINE_REGEXP = /\n/gi;
    var PrettyFormatPluginError = class extends Error {
      constructor(message, stack) {
        super(message);
        this.stack = stack;
        this.name = this.constructor.name;
      }
    };
    function isToStringedArrayType(toStringed) {
      return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
    }
    function printNumber(val) {
      return Object.is(val, -0) ? "-0" : String(val);
    }
    function printBigInt(val) {
      return String(`${val}n`);
    }
    function printFunction(val, printFunctionName) {
      if (!printFunctionName) {
        return "[Function]";
      }
      return "[Function " + (val.name || "anonymous") + "]";
    }
    function printSymbol(val) {
      return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
    }
    function printError(val) {
      return "[" + errorToString.call(val) + "]";
    }
    function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
      if (val === true || val === false) {
        return "" + val;
      }
      if (val === void 0) {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      const typeOf = typeof val;
      if (typeOf === "number") {
        return printNumber(val);
      }
      if (typeOf === "bigint") {
        return printBigInt(val);
      }
      if (typeOf === "string") {
        if (escapeString) {
          return '"' + val.replace(/"|\\/g, "\\$&") + '"';
        }
        return '"' + val + '"';
      }
      if (typeOf === "function") {
        return printFunction(val, printFunctionName);
      }
      if (typeOf === "symbol") {
        return printSymbol(val);
      }
      const toStringed = toString4.call(val);
      if (toStringed === "[object WeakMap]") {
        return "WeakMap {}";
      }
      if (toStringed === "[object WeakSet]") {
        return "WeakSet {}";
      }
      if (toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]") {
        return printFunction(val, printFunctionName);
      }
      if (toStringed === "[object Symbol]") {
        return printSymbol(val);
      }
      if (toStringed === "[object Date]") {
        return isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
      }
      if (toStringed === "[object Error]") {
        return printError(val);
      }
      if (toStringed === "[object RegExp]") {
        if (escapeRegex) {
          return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        return regExpToString.call(val);
      }
      if (val instanceof Error) {
        return printError(val);
      }
      return null;
    }
    function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
      if (refs.indexOf(val) !== -1) {
        return "[Circular]";
      }
      refs = refs.slice();
      refs.push(val);
      const hitMaxDepth = ++depth > config.maxDepth;
      const min3 = config.min;
      if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === "function" && !hasCalledToJSON) {
        return printer(val.toJSON(), config, indentation, depth, refs, true);
      }
      const toStringed = toString4.call(val);
      if (toStringed === "[object Arguments]") {
        return hitMaxDepth ? "[Arguments]" : (min3 ? "" : "Arguments ") + "[" + (0, _collections.printListItems)(
          val,
          config,
          indentation,
          depth,
          refs,
          printer
        ) + "]";
      }
      if (isToStringedArrayType(toStringed)) {
        return hitMaxDepth ? "[" + val.constructor.name + "]" : (min3 ? "" : val.constructor.name + " ") + "[" + (0, _collections.printListItems)(
          val,
          config,
          indentation,
          depth,
          refs,
          printer
        ) + "]";
      }
      if (toStringed === "[object Map]") {
        return hitMaxDepth ? "[Map]" : "Map {" + (0, _collections.printIteratorEntries)(
          val.entries(),
          config,
          indentation,
          depth,
          refs,
          printer,
          " => "
        ) + "}";
      }
      if (toStringed === "[object Set]") {
        return hitMaxDepth ? "[Set]" : "Set {" + (0, _collections.printIteratorValues)(
          val.values(),
          config,
          indentation,
          depth,
          refs,
          printer
        ) + "}";
      }
      return hitMaxDepth || isWindow(val) ? "[" + getConstructorName(val) + "]" : (min3 ? "" : getConstructorName(val) + " ") + "{" + (0, _collections.printObjectProperties)(
        val,
        config,
        indentation,
        depth,
        refs,
        printer
      ) + "}";
    }
    function isNewPlugin(plugin) {
      return plugin.serialize != null;
    }
    function printPlugin(plugin, val, config, indentation, depth, refs) {
      let printed;
      try {
        printed = isNewPlugin(plugin) ? plugin.serialize(val, config, indentation, depth, refs, printer) : plugin.print(
          val,
          (valChild) => printer(valChild, config, indentation, depth, refs),
          (str) => {
            const indentationNext = indentation + config.indent;
            return indentationNext + str.replace(NEWLINE_REGEXP, "\n" + indentationNext);
          },
          {
            edgeSpacing: config.spacingOuter,
            min: config.min,
            spacing: config.spacingInner
          },
          config.colors
        );
      } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
      }
      if (typeof printed !== "string") {
        throw new Error(
          `pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`
        );
      }
      return printed;
    }
    function findPlugin(plugins, val) {
      for (let p = 0; p < plugins.length; p++) {
        try {
          if (plugins[p].test(val)) {
            return plugins[p];
          }
        } catch (error) {
          throw new PrettyFormatPluginError(error.message, error.stack);
        }
      }
      return null;
    }
    function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
      const plugin = findPlugin(config.plugins, val);
      if (plugin !== null) {
        return printPlugin(plugin, val, config, indentation, depth, refs);
      }
      const basicResult = printBasicValue(
        val,
        config.printFunctionName,
        config.escapeRegex,
        config.escapeString
      );
      if (basicResult !== null) {
        return basicResult;
      }
      return printComplexValue(
        val,
        config,
        indentation,
        depth,
        refs,
        hasCalledToJSON
      );
    }
    var DEFAULT_THEME = {
      comment: "gray",
      content: "reset",
      prop: "yellow",
      tag: "cyan",
      value: "green"
    };
    var DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
    var DEFAULT_OPTIONS = {
      callToJSON: true,
      escapeRegex: false,
      escapeString: true,
      highlight: false,
      indent: 2,
      maxDepth: Infinity,
      min: false,
      plugins: [],
      printFunctionName: true,
      theme: DEFAULT_THEME
    };
    function validateOptions(options) {
      Object.keys(options).forEach((key) => {
        if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
          throw new Error(`pretty-format: Unknown option "${key}".`);
        }
      });
      if (options.min && options.indent !== void 0 && options.indent !== 0) {
        throw new Error(
          'pretty-format: Options "min" and "indent" cannot be used together.'
        );
      }
      if (options.theme !== void 0) {
        if (options.theme === null) {
          throw new Error(`pretty-format: Option "theme" must not be null.`);
        }
        if (typeof options.theme !== "object") {
          throw new Error(
            `pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`
          );
        }
      }
    }
    var getColorsHighlight = (options) => DEFAULT_THEME_KEYS.reduce((colors, key) => {
      const value2 = options.theme && options.theme[key] !== void 0 ? options.theme[key] : DEFAULT_THEME[key];
      const color = value2 && _ansiStyles.default[value2];
      if (color && typeof color.close === "string" && typeof color.open === "string") {
        colors[key] = color;
      } else {
        throw new Error(
          `pretty-format: Option "theme" has a key "${key}" whose value "${value2}" is undefined in ansi-styles.`
        );
      }
      return colors;
    }, /* @__PURE__ */ Object.create(null));
    var getColorsEmpty = () => DEFAULT_THEME_KEYS.reduce((colors, key) => {
      colors[key] = {
        close: "",
        open: ""
      };
      return colors;
    }, /* @__PURE__ */ Object.create(null));
    var getPrintFunctionName = (options) => options && options.printFunctionName !== void 0 ? options.printFunctionName : DEFAULT_OPTIONS.printFunctionName;
    var getEscapeRegex = (options) => options && options.escapeRegex !== void 0 ? options.escapeRegex : DEFAULT_OPTIONS.escapeRegex;
    var getEscapeString = (options) => options && options.escapeString !== void 0 ? options.escapeString : DEFAULT_OPTIONS.escapeString;
    var getConfig = (options) => ({
      callToJSON: options && options.callToJSON !== void 0 ? options.callToJSON : DEFAULT_OPTIONS.callToJSON,
      colors: options && options.highlight ? getColorsHighlight(options) : getColorsEmpty(),
      escapeRegex: getEscapeRegex(options),
      escapeString: getEscapeString(options),
      indent: options && options.min ? "" : createIndent(
        options && options.indent !== void 0 ? options.indent : DEFAULT_OPTIONS.indent
      ),
      maxDepth: options && options.maxDepth !== void 0 ? options.maxDepth : DEFAULT_OPTIONS.maxDepth,
      min: options && options.min !== void 0 ? options.min : DEFAULT_OPTIONS.min,
      plugins: options && options.plugins !== void 0 ? options.plugins : DEFAULT_OPTIONS.plugins,
      printFunctionName: getPrintFunctionName(options),
      spacingInner: options && options.min ? " " : "\n",
      spacingOuter: options && options.min ? "" : "\n"
    });
    function createIndent(indent) {
      return new Array(indent + 1).join(" ");
    }
    function prettyFormat(val, options) {
      if (options) {
        validateOptions(options);
        if (options.plugins) {
          const plugin = findPlugin(options.plugins, val);
          if (plugin !== null) {
            return printPlugin(plugin, val, getConfig(options), "", 0, []);
          }
        }
      }
      const basicResult = printBasicValue(
        val,
        getPrintFunctionName(options),
        getEscapeRegex(options),
        getEscapeString(options)
      );
      if (basicResult !== null) {
        return basicResult;
      }
      return printComplexValue(val, getConfig(options), "", 0, []);
    }
    prettyFormat.plugins = {
      AsymmetricMatcher: _AsymmetricMatcher.default,
      ConvertAnsi: _ConvertAnsi.default,
      DOMCollection: _DOMCollection.default,
      DOMElement: _DOMElement.default,
      Immutable: _Immutable.default,
      ReactElement: _ReactElement.default,
      ReactTestComponent: _ReactTestComponent.default
    };
    module.exports = prettyFormat;
  }
});

// node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createDidYouMeanMessage = exports.logValidationWarning = exports.ValidationError = exports.formatPrettyObject = exports.format = exports.WARNING = exports.ERROR = exports.DEPRECATION = void 0;
    function _chalk() {
      const data = _interopRequireDefault(require_source());
      _chalk = function() {
        return data;
      };
      return data;
    }
    function _leven() {
      const data = _interopRequireDefault(require_leven());
      _leven = function() {
        return data;
      };
      return data;
    }
    function _prettyFormat() {
      const data = _interopRequireDefault(require_build2());
      _prettyFormat = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty2(obj, key, value2) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value2,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    var BULLET = _chalk().default.bold("●");
    var DEPRECATION = `${BULLET} Deprecation Warning`;
    exports.DEPRECATION = DEPRECATION;
    var ERROR = `${BULLET} Validation Error`;
    exports.ERROR = ERROR;
    var WARNING = `${BULLET} Validation Warning`;
    exports.WARNING = WARNING;
    var format = (value2) => typeof value2 === "function" ? value2.toString() : (0, _prettyFormat().default)(value2, {
      min: true
    });
    exports.format = format;
    var formatPrettyObject = (value2) => typeof value2 === "function" ? value2.toString() : JSON.stringify(value2, null, 2).split("\n").join("\n    ");
    exports.formatPrettyObject = formatPrettyObject;
    var ValidationError = class extends Error {
      constructor(name, message, comment) {
        super();
        _defineProperty2(this, "name", void 0);
        _defineProperty2(this, "message", void 0);
        comment = comment ? "\n\n" + comment : "\n";
        this.name = "";
        this.message = _chalk().default.red(
          _chalk().default.bold(name) + ":\n\n" + message + comment
        );
        Error.captureStackTrace(this, () => {
        });
      }
    };
    exports.ValidationError = ValidationError;
    var logValidationWarning = (name, message, comment) => {
      comment = comment ? "\n\n" + comment : "\n";
      console.warn(
        _chalk().default.yellow(
          _chalk().default.bold(name) + ":\n\n" + message + comment
        )
      );
    };
    exports.logValidationWarning = logValidationWarning;
    var createDidYouMeanMessage = (unrecognized, allowedOptions) => {
      const suggestion = allowedOptions.find((option) => {
        const steps = (0, _leven().default)(option, unrecognized);
        return steps < 3;
      });
      return suggestion ? `Did you mean ${_chalk().default.bold(format(suggestion))}?` : "";
    };
    exports.createDidYouMeanMessage = createDidYouMeanMessage;
  }
});

// node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/condition.js
var require_condition = __commonJS({
  "node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/condition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getValues = getValues;
    exports.validationCondition = validationCondition;
    exports.multipleValidOptions = multipleValidOptions;
    var toString4 = Object.prototype.toString;
    var MULTIPLE_VALID_OPTIONS_SYMBOL = Symbol("JEST_MULTIPLE_VALID_OPTIONS");
    function validationConditionSingle(option, validOption) {
      return option === null || option === void 0 || typeof option === "function" && typeof validOption === "function" || toString4.call(option) === toString4.call(validOption);
    }
    function getValues(validOption) {
      if (Array.isArray(validOption) && // @ts-expect-error
      validOption[MULTIPLE_VALID_OPTIONS_SYMBOL]) {
        return validOption;
      }
      return [validOption];
    }
    function validationCondition(option, validOption) {
      return getValues(validOption).some((e) => validationConditionSingle(option, e));
    }
    function multipleValidOptions(...args) {
      const options = [...args];
      options[MULTIPLE_VALID_OPTIONS_SYMBOL] = true;
      return options;
    }
  }
});

// node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/deprecated.js
var require_deprecated = __commonJS({
  "node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/deprecated.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.deprecationWarning = void 0;
    var _utils = require_utils();
    var deprecationMessage = (message, options) => {
      const comment = options.comment;
      const name = options.title && options.title.deprecation || _utils.DEPRECATION;
      (0, _utils.logValidationWarning)(name, message, comment);
    };
    var deprecationWarning = (config, option, deprecatedOptions, options) => {
      if (option in deprecatedOptions) {
        deprecationMessage(deprecatedOptions[option](config), options);
        return true;
      }
      return false;
    };
    exports.deprecationWarning = deprecationWarning;
  }
});

// node_modules/.pnpm/jest-get-type@26.3.0/node_modules/jest-get-type/build/index.js
var require_build3 = __commonJS({
  "node_modules/.pnpm/jest-get-type@26.3.0/node_modules/jest-get-type/build/index.js"(exports, module) {
    "use strict";
    function getType(value2) {
      if (value2 === void 0) {
        return "undefined";
      } else if (value2 === null) {
        return "null";
      } else if (Array.isArray(value2)) {
        return "array";
      } else if (typeof value2 === "boolean") {
        return "boolean";
      } else if (typeof value2 === "function") {
        return "function";
      } else if (typeof value2 === "number") {
        return "number";
      } else if (typeof value2 === "string") {
        return "string";
      } else if (typeof value2 === "bigint") {
        return "bigint";
      } else if (typeof value2 === "object") {
        if (value2 != null) {
          if (value2.constructor === RegExp) {
            return "regexp";
          } else if (value2.constructor === Map) {
            return "map";
          } else if (value2.constructor === Set) {
            return "set";
          } else if (value2.constructor === Date) {
            return "date";
          }
        }
        return "object";
      } else if (typeof value2 === "symbol") {
        return "symbol";
      }
      throw new Error(`value of unknown type: ${value2}`);
    }
    getType.isPrimitive = (value2) => Object(value2) !== value2;
    module.exports = getType;
  }
});

// node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.errorMessage = void 0;
    function _chalk() {
      const data = _interopRequireDefault(require_source());
      _chalk = function() {
        return data;
      };
      return data;
    }
    function _jestGetType() {
      const data = _interopRequireDefault(require_build3());
      _jestGetType = function() {
        return data;
      };
      return data;
    }
    var _condition = require_condition();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var errorMessage = (option, received, defaultValue, options, path3) => {
      const conditions = (0, _condition.getValues)(defaultValue);
      const validTypes = Array.from(
        new Set(conditions.map(_jestGetType().default))
      );
      const message = `  Option ${_chalk().default.bold(
        `"${path3 && path3.length > 0 ? path3.join(".") + "." : ""}${option}"`
      )} must be of type:
    ${validTypes.map((e) => _chalk().default.bold.green(e)).join(" or ")}
  but instead received:
    ${_chalk().default.bold.red((0, _jestGetType().default)(received))}

  Example:
${formatExamples(option, conditions)}`;
      const comment = options.comment;
      const name = options.title && options.title.error || _utils.ERROR;
      throw new _utils.ValidationError(name, message, comment);
    };
    exports.errorMessage = errorMessage;
    function formatExamples(option, examples) {
      return examples.map(
        (e) => `  {
    ${_chalk().default.bold(`"${option}"`)}: ${_chalk().default.bold(
          (0, _utils.formatPrettyObject)(e)
        )}
  }`
      ).join(`

  or

`);
    }
  }
});

// node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/warnings.js
var require_warnings = __commonJS({
  "node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/warnings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.unknownOptionWarning = void 0;
    function _chalk() {
      const data = _interopRequireDefault(require_source());
      _chalk = function() {
        return data;
      };
      return data;
    }
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var unknownOptionWarning = (config, exampleConfig, option, options, path3) => {
      const didYouMean = (0, _utils.createDidYouMeanMessage)(
        option,
        Object.keys(exampleConfig)
      );
      const message = `  Unknown option ${_chalk().default.bold(
        `"${path3 && path3.length > 0 ? path3.join(".") + "." : ""}${option}"`
      )} with value ${_chalk().default.bold(
        (0, _utils.format)(config[option])
      )} was found.` + (didYouMean && ` ${didYouMean}`) + `
  This is probably a typing mistake. Fixing it will remove this message.`;
      const comment = options.comment;
      const name = options.title && options.title.warning || _utils.WARNING;
      (0, _utils.logValidationWarning)(name, message, comment);
    };
    exports.unknownOptionWarning = unknownOptionWarning;
  }
});

// node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/defaultConfig.js
var require_defaultConfig = __commonJS({
  "node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/defaultConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _condition = require_condition();
    var _deprecated = require_deprecated();
    var _errors = require_errors();
    var _utils = require_utils();
    var _warnings = require_warnings();
    var validationOptions = {
      comment: "",
      condition: _condition.validationCondition,
      deprecate: _deprecated.deprecationWarning,
      deprecatedConfig: {},
      error: _errors.errorMessage,
      exampleConfig: {},
      recursive: true,
      // Allow NPM-sanctioned comments in package.json. Use a "//" key.
      recursiveDenylist: ["//"],
      title: {
        deprecation: _utils.DEPRECATION,
        error: _utils.ERROR,
        warning: _utils.WARNING
      },
      unknown: _warnings.unknownOptionWarning
    };
    var _default = validationOptions;
    exports.default = _default;
  }
});

// node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/validate.js
var require_validate = __commonJS({
  "node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _defaultConfig = _interopRequireDefault(require_defaultConfig());
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hasDeprecationWarnings = false;
    var shouldSkipValidationForPath = (path3, key, denylist) => denylist ? denylist.includes([...path3, key].join(".")) : false;
    var _validate = (config, exampleConfig, options, path3 = []) => {
      if (typeof config !== "object" || config == null || typeof exampleConfig !== "object" || exampleConfig == null) {
        return {
          hasDeprecationWarnings
        };
      }
      for (const key in config) {
        if (options.deprecatedConfig && key in options.deprecatedConfig && typeof options.deprecate === "function") {
          const isDeprecatedKey = options.deprecate(
            config,
            key,
            options.deprecatedConfig,
            options
          );
          hasDeprecationWarnings = hasDeprecationWarnings || isDeprecatedKey;
        } else if (allowsMultipleTypes(key)) {
          const value2 = config[key];
          if (typeof options.condition === "function" && typeof options.error === "function") {
            if (key === "maxWorkers" && !isOfTypeStringOrNumber(value2)) {
              throw new _utils.ValidationError(
                "Validation Error",
                `${key} has to be of type string or number`,
                `maxWorkers=50% or
maxWorkers=3`
              );
            }
          }
        } else if (Object.hasOwnProperty.call(exampleConfig, key)) {
          if (typeof options.condition === "function" && typeof options.error === "function" && !options.condition(config[key], exampleConfig[key])) {
            options.error(key, config[key], exampleConfig[key], options, path3);
          }
        } else if (shouldSkipValidationForPath(
          path3,
          key,
          options.recursiveDenylist || options.recursiveBlacklist
        )) {
        } else {
          options.unknown && options.unknown(config, exampleConfig, key, options, path3);
        }
        if (options.recursive && !Array.isArray(exampleConfig[key]) && (options.recursiveDenylist || options.recursiveBlacklist) && !shouldSkipValidationForPath(
          path3,
          key,
          options.recursiveDenylist || options.recursiveBlacklist
        )) {
          _validate(config[key], exampleConfig[key], options, [...path3, key]);
        }
      }
      return {
        hasDeprecationWarnings
      };
    };
    var allowsMultipleTypes = (key) => key === "maxWorkers";
    var isOfTypeStringOrNumber = (value2) => typeof value2 === "number" || typeof value2 === "string";
    var validate = (config, options) => {
      hasDeprecationWarnings = false;
      const combinedDenylist = [
        ..._defaultConfig.default.recursiveDenylist || [],
        ...options.recursiveDenylist || options.recursiveBlacklist || []
      ];
      const defaultedOptions = Object.assign({
        ..._defaultConfig.default,
        ...options,
        recursiveDenylist: combinedDenylist,
        title: options.title || _defaultConfig.default.title
      });
      const { hasDeprecationWarnings: hdw } = _validate(
        config,
        options.exampleConfig,
        defaultedOptions
      );
      return {
        hasDeprecationWarnings: hdw,
        isValid: true
      };
    };
    var _default = validate;
    exports.default = _default;
  }
});

// node_modules/.pnpm/camelcase@6.3.0/node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/.pnpm/camelcase@6.3.0/node_modules/camelcase/index.js"(exports, module) {
    "use strict";
    var UPPERCASE = /[\p{Lu}]/u;
    var LOWERCASE = /[\p{Ll}]/u;
    var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    var SEPARATORS = /[_.\- ]+/;
    var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    var preserveCamelCase = (string2, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string2.length; i++) {
        const character = string2[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string2 = string2.slice(0, i) + "-" + string2.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string2 = string2.slice(0, i - 1) + "-" + string2.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string2;
    };
    var preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    var postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    var camelCase = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options.locale === false ? (string2) => string2.toLowerCase() : (string2) => string2.toLocaleLowerCase(options.locale);
      const toUpperCase = options.locale === false ? (string2) => string2.toUpperCase() : (string2) => string2.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    module.exports = camelCase;
    module.exports.default = camelCase;
  }
});

// node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/validateCLIOptions.js
var require_validateCLIOptions = __commonJS({
  "node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/validateCLIOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = validateCLIOptions;
    exports.DOCUMENTATION_NOTE = void 0;
    function _camelcase() {
      const data = _interopRequireDefault(require_camelcase());
      _camelcase = function() {
        return data;
      };
      return data;
    }
    function _chalk() {
      const data = _interopRequireDefault(require_source());
      _chalk = function() {
        return data;
      };
      return data;
    }
    var _defaultConfig = _interopRequireDefault(require_defaultConfig());
    var _deprecated = require_deprecated();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var BULLET = _chalk().default.bold("●");
    var DOCUMENTATION_NOTE = `  ${_chalk().default.bold(
      "CLI Options Documentation:"
    )}
  https://jestjs.io/docs/en/cli.html
`;
    exports.DOCUMENTATION_NOTE = DOCUMENTATION_NOTE;
    var createCLIValidationError = (unrecognizedOptions, allowedOptions) => {
      let title = `${BULLET} Unrecognized CLI Parameter`;
      let message;
      const comment = `  ${_chalk().default.bold("CLI Options Documentation")}:
  https://jestjs.io/docs/en/cli.html
`;
      if (unrecognizedOptions.length === 1) {
        const unrecognized = unrecognizedOptions[0];
        const didYouMeanMessage = unrecognized.length > 1 ? (0, _utils.createDidYouMeanMessage)(
          unrecognized,
          Array.from(allowedOptions)
        ) : "";
        message = `  Unrecognized option ${_chalk().default.bold(
          (0, _utils.format)(unrecognized)
        )}.` + (didYouMeanMessage ? ` ${didYouMeanMessage}` : "");
      } else {
        title += "s";
        message = `  Following options were not recognized:
  ${_chalk().default.bold((0, _utils.format)(unrecognizedOptions))}`;
      }
      return new _utils.ValidationError(title, message, comment);
    };
    var logDeprecatedOptions = (deprecatedOptions, deprecationEntries, argv) => {
      deprecatedOptions.forEach((opt) => {
        (0, _deprecated.deprecationWarning)(argv, opt, deprecationEntries, {
          ..._defaultConfig.default,
          comment: DOCUMENTATION_NOTE
        });
      });
    };
    function validateCLIOptions(argv, options, rawArgv = []) {
      const yargsSpecialOptions = ["$0", "_", "help", "h"];
      const deprecationEntries = options.deprecationEntries || {};
      const allowedOptions = Object.keys(options).reduce(
        (acc, option) => acc.add(option).add(options[option].alias || option),
        new Set(yargsSpecialOptions)
      );
      const unrecognizedOptions = Object.keys(argv).filter(
        (arg) => !allowedOptions.has((0, _camelcase().default)(arg)) && !allowedOptions.has(arg) && (!rawArgv.length || rawArgv.includes(arg)),
        []
      );
      if (unrecognizedOptions.length) {
        throw createCLIValidationError(unrecognizedOptions, allowedOptions);
      }
      const CLIDeprecations = Object.keys(deprecationEntries).reduce(
        (acc, entry) => {
          if (options[entry]) {
            acc[entry] = deprecationEntries[entry];
            const alias = options[entry].alias;
            if (alias) {
              acc[alias] = deprecationEntries[entry];
            }
          }
          return acc;
        },
        {}
      );
      const deprecations = new Set(Object.keys(CLIDeprecations));
      const deprecatedOptions = Object.keys(argv).filter(
        (arg) => deprecations.has(arg) && argv[arg] != null
      );
      if (deprecatedOptions.length) {
        logDeprecatedOptions(deprecatedOptions, CLIDeprecations, argv);
      }
      return true;
    }
  }
});

// node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/index.js
var require_build4 = __commonJS({
  "node_modules/.pnpm/jest-validate@26.6.2/node_modules/jest-validate/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ValidationError", {
      enumerable: true,
      get: function() {
        return _utils.ValidationError;
      }
    });
    Object.defineProperty(exports, "createDidYouMeanMessage", {
      enumerable: true,
      get: function() {
        return _utils.createDidYouMeanMessage;
      }
    });
    Object.defineProperty(exports, "format", {
      enumerable: true,
      get: function() {
        return _utils.format;
      }
    });
    Object.defineProperty(exports, "logValidationWarning", {
      enumerable: true,
      get: function() {
        return _utils.logValidationWarning;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "validateCLIOptions", {
      enumerable: true,
      get: function() {
        return _validateCLIOptions.default;
      }
    });
    Object.defineProperty(exports, "multipleValidOptions", {
      enumerable: true,
      get: function() {
        return _condition.multipleValidOptions;
      }
    });
    var _utils = require_utils();
    var _validate = _interopRequireDefault(require_validate());
    var _validateCLIOptions = _interopRequireDefault(
      require_validateCLIOptions()
    );
    var _condition = require_condition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/.pnpm/make-error@1.3.6/node_modules/make-error/index.js
var require_make_error = __commonJS({
  "node_modules/.pnpm/make-error@1.3.6/node_modules/make-error/index.js"(exports, module) {
    "use strict";
    var construct3 = typeof Reflect !== "undefined" ? Reflect.construct : void 0;
    var defineProperty = Object.defineProperty;
    var captureStackTrace = Error.captureStackTrace;
    if (captureStackTrace === void 0) {
      captureStackTrace = function captureStackTrace2(error) {
        var container = new Error();
        defineProperty(error, "stack", {
          configurable: true,
          get: function getStack() {
            var stack = container.stack;
            defineProperty(this, "stack", {
              configurable: true,
              value: stack,
              writable: true
            });
            return stack;
          },
          set: function setStack(stack) {
            defineProperty(error, "stack", {
              configurable: true,
              value: stack,
              writable: true
            });
          }
        });
      };
    }
    function BaseError(message) {
      if (message !== void 0) {
        defineProperty(this, "message", {
          configurable: true,
          value: message,
          writable: true
        });
      }
      var cname = this.constructor.name;
      if (cname !== void 0 && cname !== this.name) {
        defineProperty(this, "name", {
          configurable: true,
          value: cname,
          writable: true
        });
      }
      captureStackTrace(this, this.constructor);
    }
    BaseError.prototype = Object.create(Error.prototype, {
      // See: https://github.com/JsCommunity/make-error/issues/4
      constructor: {
        configurable: true,
        value: BaseError,
        writable: true
      }
    });
    var setFunctionName = function() {
      function setFunctionName2(fn, name) {
        return defineProperty(fn, "name", {
          configurable: true,
          value: name
        });
      }
      try {
        var f = function() {
        };
        setFunctionName2(f, "foo");
        if (f.name === "foo") {
          return setFunctionName2;
        }
      } catch (_) {
      }
    }();
    function makeError(constructor, super_) {
      if (super_ == null || super_ === Error) {
        super_ = BaseError;
      } else if (typeof super_ !== "function") {
        throw new TypeError("super_ should be a function");
      }
      var name;
      if (typeof constructor === "string") {
        name = constructor;
        constructor = construct3 !== void 0 ? function() {
          return construct3(super_, arguments, this.constructor);
        } : function() {
          super_.apply(this, arguments);
        };
        if (setFunctionName !== void 0) {
          setFunctionName(constructor, name);
          name = void 0;
        }
      } else if (typeof constructor !== "function") {
        throw new TypeError("constructor should be either a string or a function");
      }
      constructor.super_ = constructor["super"] = super_;
      var properties = {
        constructor: {
          configurable: true,
          value: constructor,
          writable: true
        }
      };
      if (name !== void 0) {
        properties.name = {
          configurable: true,
          value: name,
          writable: true
        };
      }
      constructor.prototype = Object.create(super_.prototype, properties);
      return constructor;
    }
    exports = module.exports = makeError;
    exports.BaseError = BaseError;
  }
});

// node_modules/.pnpm/yn@3.1.1/node_modules/yn/lenient.js
var require_lenient = __commonJS({
  "node_modules/.pnpm/yn@3.1.1/node_modules/yn/lenient.js"(exports, module) {
    "use strict";
    var YES_MATCH_SCORE_THRESHOLD = 2;
    var NO_MATCH_SCORE_THRESHOLD = 1.25;
    var yMatch = /* @__PURE__ */ new Map([
      [5, 0.25],
      [6, 0.25],
      [7, 0.25],
      ["t", 0.75],
      ["y", 1],
      ["u", 0.75],
      ["g", 0.25],
      ["h", 0.25],
      ["j", 0.25]
    ]);
    var eMatch = /* @__PURE__ */ new Map([
      [2, 0.25],
      [3, 0.25],
      [4, 0.25],
      ["w", 0.75],
      ["e", 1],
      ["r", 0.75],
      ["s", 0.25],
      ["d", 0.25],
      ["f", 0.25]
    ]);
    var sMatch = /* @__PURE__ */ new Map([
      ["q", 0.25],
      ["w", 0.25],
      ["e", 0.25],
      ["a", 0.75],
      ["s", 1],
      ["d", 0.75],
      ["z", 0.25],
      ["x", 0.25],
      ["c", 0.25]
    ]);
    var nMatch = /* @__PURE__ */ new Map([
      ["h", 0.25],
      ["j", 0.25],
      ["k", 0.25],
      ["b", 0.75],
      ["n", 1],
      ["m", 0.75]
    ]);
    var oMatch = /* @__PURE__ */ new Map([
      [9, 0.25],
      [0, 0.25],
      ["i", 0.75],
      ["o", 1],
      ["p", 0.75],
      ["k", 0.25],
      ["l", 0.25]
    ]);
    function getYesMatchScore(value2) {
      const [y, e, s] = value2;
      let score = 0;
      if (yMatch.has(y)) {
        score += yMatch.get(y);
      }
      if (eMatch.has(e)) {
        score += eMatch.get(e);
      }
      if (sMatch.has(s)) {
        score += sMatch.get(s);
      }
      return score;
    }
    function getNoMatchScore(value2) {
      const [n, o3] = value2;
      let score = 0;
      if (nMatch.has(n)) {
        score += nMatch.get(n);
      }
      if (oMatch.has(o3)) {
        score += oMatch.get(o3);
      }
      return score;
    }
    module.exports = (input, options) => {
      if (getYesMatchScore(input) >= YES_MATCH_SCORE_THRESHOLD) {
        return true;
      }
      if (getNoMatchScore(input) >= NO_MATCH_SCORE_THRESHOLD) {
        return false;
      }
      return options.default;
    };
  }
});

// node_modules/.pnpm/yn@3.1.1/node_modules/yn/index.js
var require_yn = __commonJS({
  "node_modules/.pnpm/yn@3.1.1/node_modules/yn/index.js"(exports, module) {
    "use strict";
    var lenient = require_lenient();
    var yn = (input, options) => {
      input = String(input).trim();
      options = Object.assign({
        lenient: false,
        default: null
      }, options);
      if (options.default !== null && typeof options.default !== "boolean") {
        throw new TypeError(`Expected the \`default\` option to be of type \`boolean\`, got \`${typeof options.default}\``);
      }
      if (/^(?:y|yes|true|1)$/i.test(input)) {
        return true;
      }
      if (/^(?:n|no|false|0)$/i.test(input)) {
        return false;
      }
      if (options.lenient === true) {
        return lenient(input, options);
      }
      return options.default;
    };
    module.exports = yn;
    module.exports.default = yn;
  }
});

// node_modules/.pnpm/create-require@1.1.1/node_modules/create-require/create-require.js
var require_create_require = __commonJS({
  "node_modules/.pnpm/create-require@1.1.1/node_modules/create-require/create-require.js"(exports, module) {
    var nativeModule = require_module();
    var path3 = require_path();
    var fs = require_fs();
    function createRequire(filename) {
      if (!filename) {
        filename = process.cwd();
      }
      if (isDir(filename)) {
        filename = path3.join(filename, "index.js");
      }
      if (nativeModule.createRequire) {
        return nativeModule.createRequire(filename);
      }
      if (nativeModule.createRequireFromPath) {
        return nativeModule.createRequireFromPath(filename);
      }
      return _createRequire(filename);
    }
    function _createRequire(filename) {
      const mod = new nativeModule.Module(filename, null);
      mod.filename = filename;
      mod.paths = nativeModule.Module._nodeModulePaths(path3.dirname(filename));
      mod._compile("module.exports = require;", filename);
      return mod.exports;
    }
    function isDir(path4) {
      try {
        const stat = fs.lstatSync(path4);
        return stat.isDirectory();
      } catch (e) {
        return false;
      }
    }
    module.exports = createRequire;
  }
});

// browser-external:vm
var require_vm = __commonJS({
  "browser-external:vm"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "vm" has been externalized for browser compatibility. Cannot access "vm.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/v8-compile-cache-lib@3.0.1/node_modules/v8-compile-cache-lib/v8-compile-cache.js
var require_v8_compile_cache = __commonJS({
  "node_modules/.pnpm/v8-compile-cache-lib@3.0.1/node_modules/v8-compile-cache-lib/v8-compile-cache.js"(exports, module) {
    "use strict";
    var Module = require_module();
    var crypto = require_crypto();
    var fs = require_fs();
    var path3 = require_path();
    var vm = require_vm();
    var os = require_os();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var FileSystemBlobStore = class {
      constructor(directory, prefix) {
        const name = prefix ? slashEscape(prefix + ".") : "";
        this._blobFilename = path3.join(directory, name + "BLOB");
        this._mapFilename = path3.join(directory, name + "MAP");
        this._lockFilename = path3.join(directory, name + "LOCK");
        this._directory = directory;
        this._load();
      }
      has(key, invalidationKey) {
        if (hasOwnProperty.call(this._memoryBlobs, key)) {
          return this._invalidationKeys[key] === invalidationKey;
        } else if (hasOwnProperty.call(this._storedMap, key)) {
          return this._storedMap[key][0] === invalidationKey;
        }
        return false;
      }
      get(key, invalidationKey) {
        if (hasOwnProperty.call(this._memoryBlobs, key)) {
          if (this._invalidationKeys[key] === invalidationKey) {
            return this._memoryBlobs[key];
          }
        } else if (hasOwnProperty.call(this._storedMap, key)) {
          const mapping = this._storedMap[key];
          if (mapping[0] === invalidationKey) {
            return this._storedBlob.slice(mapping[1], mapping[2]);
          }
        }
      }
      set(key, invalidationKey, buffer) {
        this._invalidationKeys[key] = invalidationKey;
        this._memoryBlobs[key] = buffer;
        this._dirty = true;
      }
      delete(key) {
        if (hasOwnProperty.call(this._memoryBlobs, key)) {
          this._dirty = true;
          delete this._memoryBlobs[key];
        }
        if (hasOwnProperty.call(this._invalidationKeys, key)) {
          this._dirty = true;
          delete this._invalidationKeys[key];
        }
        if (hasOwnProperty.call(this._storedMap, key)) {
          this._dirty = true;
          delete this._storedMap[key];
        }
      }
      isDirty() {
        return this._dirty;
      }
      save() {
        const dump = this._getDump();
        const blobToStore = Buffer.concat(dump[0]);
        const mapToStore = JSON.stringify(dump[1]);
        try {
          mkdirpSync(this._directory);
          fs.writeFileSync(this._lockFilename, "LOCK", { flag: "wx" });
        } catch (error) {
          return false;
        }
        try {
          fs.writeFileSync(this._blobFilename, blobToStore);
          fs.writeFileSync(this._mapFilename, mapToStore);
        } finally {
          fs.unlinkSync(this._lockFilename);
        }
        return true;
      }
      _load() {
        try {
          this._storedBlob = fs.readFileSync(this._blobFilename);
          this._storedMap = JSON.parse(fs.readFileSync(this._mapFilename));
        } catch (e) {
          this._storedBlob = Buffer.alloc(0);
          this._storedMap = {};
        }
        this._dirty = false;
        this._memoryBlobs = {};
        this._invalidationKeys = {};
      }
      _getDump() {
        const buffers = [];
        const newMap = {};
        let offset = 0;
        function push(key, invalidationKey, buffer) {
          buffers.push(buffer);
          newMap[key] = [invalidationKey, offset, offset + buffer.length];
          offset += buffer.length;
        }
        for (const key of Object.keys(this._memoryBlobs)) {
          const buffer = this._memoryBlobs[key];
          const invalidationKey = this._invalidationKeys[key];
          push(key, invalidationKey, buffer);
        }
        for (const key of Object.keys(this._storedMap)) {
          if (hasOwnProperty.call(newMap, key))
            continue;
          const mapping = this._storedMap[key];
          const buffer = this._storedBlob.slice(mapping[1], mapping[2]);
          push(key, mapping[0], buffer);
        }
        return [buffers, newMap];
      }
    };
    var NativeCompileCache = class {
      constructor() {
        this._cacheStore = null;
        this._previousModuleCompile = null;
      }
      setCacheStore(cacheStore) {
        this._cacheStore = cacheStore;
      }
      install() {
        const self2 = this;
        const hasRequireResolvePaths = typeof __require.resolve.paths === "function";
        this._previousModuleCompile = Module.prototype._compile;
        Module.prototype._compile = this._ownModuleCompile = _ownModuleCompile;
        self2.enabled = true;
        function _ownModuleCompile(content, filename) {
          if (!self2.enabled)
            return this._previousModuleCompile.apply(this, arguments);
          const mod = this;
          function require2(id) {
            return mod.require(id);
          }
          function resolve27(request, options) {
            return Module._resolveFilename(request, mod, false, options);
          }
          require2.resolve = resolve27;
          if (hasRequireResolvePaths) {
            resolve27.paths = function paths3(request) {
              return Module._resolveLookupPaths(request, mod, true);
            };
          }
          require2.main = process.mainModule;
          require2.extensions = Module._extensions;
          require2.cache = Module._cache;
          const dirname = path3.dirname(filename);
          const compiledWrapper = self2._moduleCompile(filename, content);
          const args = [mod.exports, require2, mod, filename, dirname, process, global, Buffer];
          return compiledWrapper.apply(mod.exports, args);
        }
      }
      uninstall() {
        this.enabled = false;
        if (Module.prototype._compile === this._ownModuleCompile) {
          Module.prototype._compile = this._previousModuleCompile;
        }
      }
      _moduleCompile(filename, content) {
        var contLen = content.length;
        if (contLen >= 2) {
          if (content.charCodeAt(0) === 35 && content.charCodeAt(1) === 33) {
            if (contLen === 2) {
              content = "";
            } else {
              var i = 2;
              for (; i < contLen; ++i) {
                var code = content.charCodeAt(i);
                if (code === 10 || code === 13)
                  break;
              }
              if (i === contLen) {
                content = "";
              } else {
                content = content.slice(i);
              }
            }
          }
        }
        var wrapper = Module.wrap(content);
        var invalidationKey = crypto.createHash("sha1").update(content, "utf8").digest("hex");
        var buffer = this._cacheStore.get(filename, invalidationKey);
        var script = new vm.Script(wrapper, {
          filename,
          lineOffset: 0,
          displayErrors: true,
          cachedData: buffer,
          produceCachedData: true
        });
        if (script.cachedDataProduced) {
          this._cacheStore.set(filename, invalidationKey, script.cachedData);
        } else if (script.cachedDataRejected) {
          this._cacheStore.delete(filename);
        }
        var compiledWrapper = script.runInThisContext({
          filename,
          lineOffset: 0,
          columnOffset: 0,
          displayErrors: true
        });
        return compiledWrapper;
      }
    };
    function mkdirpSync(p_) {
      _mkdirpSync(path3.resolve(p_), 511);
    }
    function _mkdirpSync(p, mode) {
      try {
        fs.mkdirSync(p, mode);
      } catch (err0) {
        if (err0.code === "ENOENT") {
          _mkdirpSync(path3.dirname(p));
          _mkdirpSync(p);
        } else {
          try {
            const stat = fs.statSync(p);
            if (!stat.isDirectory()) {
              throw err0;
            }
          } catch (err1) {
            throw err0;
          }
        }
      }
    }
    function slashEscape(str) {
      const ESCAPE_LOOKUP = {
        "\\": "zB",
        ":": "zC",
        "/": "zS",
        "\0": "z0",
        "z": "zZ"
      };
      const ESCAPE_REGEX = /[\\:/\x00z]/g;
      return str.replace(ESCAPE_REGEX, (match3) => ESCAPE_LOOKUP[match3]);
    }
    function supportsCachedData() {
      const script = new vm.Script('""', { produceCachedData: true });
      return script.cachedDataProduced === true;
    }
    function getCacheDir() {
      const v8_compile_cache_cache_dir = process.env.V8_COMPILE_CACHE_CACHE_DIR;
      if (v8_compile_cache_cache_dir) {
        return v8_compile_cache_cache_dir;
      }
      const dirname = typeof process.getuid === "function" ? "v8-compile-cache-" + process.getuid() : "v8-compile-cache";
      const version = typeof process.versions.v8 === "string" ? process.versions.v8 : typeof process.versions.chakracore === "string" ? "chakracore-" + process.versions.chakracore : "node-" + process.version;
      const cacheDir = path3.join(os.tmpdir(), dirname, version);
      return cacheDir;
    }
    function getMainName() {
      const mainName = __require.main && typeof __require.main.filename === "string" ? __require.main.filename : process.cwd();
      return mainName;
    }
    function install(opts) {
      if (!process.env.DISABLE_V8_COMPILE_CACHE && supportsCachedData()) {
        if (typeof opts === "undefined")
          opts = {};
        let cacheDir = opts.cacheDir;
        if (typeof cacheDir === "undefined")
          cacheDir = getCacheDir();
        let prefix = opts.prefix;
        if (typeof prefix === "undefined")
          prefix = getMainName();
        const blobStore = new FileSystemBlobStore(cacheDir, prefix);
        const nativeCompileCache = new NativeCompileCache();
        nativeCompileCache.setCacheStore(blobStore);
        nativeCompileCache.install();
        let uninstalled = false;
        const uninstall = () => {
          if (uninstalled)
            return;
          uninstalled = true;
          process.removeListener("exit", uninstall);
          if (blobStore.isDirty()) {
            blobStore.save();
          }
          nativeCompileCache.uninstall();
        };
        process.once("exit", uninstall);
        return { uninstall };
      }
    }
    module.exports.install = install;
    module.exports.__TEST__ = {
      FileSystemBlobStore,
      NativeCompileCache,
      mkdirpSync,
      slashEscape,
      supportsCachedData,
      getCacheDir,
      getMainName
    };
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/util.js
var require_util4 = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/util.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.versionGteLt = exports.once = exports.getBasePathForProjectLocalDependencyResolution = exports.createProjectLocalResolveHelper = exports.attemptRequireWithV8CompileCache = exports.cachedLookup = exports.hasOwnProperty = exports.normalizeSlashes = exports.parse = exports.split = exports.assign = exports.yn = exports.createRequire = void 0;
    var module_1 = require_module();
    var ynModule = require_yn();
    var path_1 = require_path();
    exports.createRequire = (_a = module_1.createRequire !== null && module_1.createRequire !== void 0 ? module_1.createRequire : module_1.createRequireFromPath) !== null && _a !== void 0 ? _a : require_create_require();
    function yn(value2) {
      var _a2;
      return (_a2 = ynModule(value2)) !== null && _a2 !== void 0 ? _a2 : void 0;
    }
    exports.yn = yn;
    function assign(initialValue, ...sources) {
      for (const source of sources) {
        for (const key of Object.keys(source)) {
          const value2 = source[key];
          if (value2 !== void 0)
            initialValue[key] = value2;
        }
      }
      return initialValue;
    }
    exports.assign = assign;
    function split2(value2) {
      return typeof value2 === "string" ? value2.split(/ *, */g).filter((v) => v !== "") : void 0;
    }
    exports.split = split2;
    function parse3(value2) {
      return typeof value2 === "string" ? JSON.parse(value2) : void 0;
    }
    exports.parse = parse3;
    var directorySeparator = "/";
    var backslashRegExp = /\\/g;
    function normalizeSlashes(value2) {
      return value2.replace(backslashRegExp, directorySeparator);
    }
    exports.normalizeSlashes = normalizeSlashes;
    function hasOwnProperty(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    }
    exports.hasOwnProperty = hasOwnProperty;
    function cachedLookup(fn) {
      const cache = /* @__PURE__ */ new Map();
      return (arg) => {
        if (!cache.has(arg)) {
          const v = fn(arg);
          cache.set(arg, v);
          return v;
        }
        return cache.get(arg);
      };
    }
    exports.cachedLookup = cachedLookup;
    function attemptRequireWithV8CompileCache(requireFn, specifier) {
      try {
        const v8CC = require_v8_compile_cache().install();
        try {
          return requireFn(specifier);
        } finally {
          v8CC === null || v8CC === void 0 ? void 0 : v8CC.uninstall();
        }
      } catch (e) {
        return requireFn(specifier);
      }
    }
    exports.attemptRequireWithV8CompileCache = attemptRequireWithV8CompileCache;
    function createProjectLocalResolveHelper(localDirectory) {
      return function projectLocalResolveHelper(specifier, fallbackToTsNodeRelative) {
        return __require.resolve(specifier, {
          paths: fallbackToTsNodeRelative ? [localDirectory, __dirname] : [localDirectory]
        });
      };
    }
    exports.createProjectLocalResolveHelper = createProjectLocalResolveHelper;
    function getBasePathForProjectLocalDependencyResolution(configFilePath, projectSearchDirOption, projectOption, cwdOption) {
      var _a2;
      if (configFilePath != null)
        return (0, path_1.dirname)(configFilePath);
      return (_a2 = projectSearchDirOption !== null && projectSearchDirOption !== void 0 ? projectSearchDirOption : projectOption) !== null && _a2 !== void 0 ? _a2 : cwdOption;
    }
    exports.getBasePathForProjectLocalDependencyResolution = getBasePathForProjectLocalDependencyResolution;
    function once3(fn) {
      let value2;
      let ran = false;
      function onceFn(...args) {
        if (ran)
          return value2;
        value2 = fn(...args);
        ran = true;
        return value2;
      }
      return onceFn;
    }
    exports.once = once3;
    function versionGteLt(version, gteRequirement, ltRequirement) {
      const [major, minor, patch, extra] = parse4(version);
      const [gteMajor, gteMinor, gtePatch] = parse4(gteRequirement);
      const isGte = major > gteMajor || major === gteMajor && (minor > gteMinor || minor === gteMinor && patch >= gtePatch);
      let isLt = true;
      if (ltRequirement) {
        const [ltMajor, ltMinor, ltPatch] = parse4(ltRequirement);
        isLt = major < ltMajor || major === ltMajor && (minor < ltMinor || minor === ltMinor && patch < ltPatch);
      }
      return isGte && isLt;
      function parse4(requirement) {
        return requirement.split(/[\.-]/).map((s) => parseInt(s, 10));
      }
    }
    exports.versionGteLt = versionGteLt;
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/ts-internals.js
var require_ts_internals = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/ts-internals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPatternFromSpec = exports.createTsInternals = void 0;
    var path_1 = require_path();
    var util_1 = require_util4();
    exports.createTsInternals = (0, util_1.cachedLookup)(createTsInternalsUncached);
    function createTsInternalsUncached(_ts) {
      const ts = _ts;
      function getExtendsConfigPath(extendedConfig, host, basePath, errors, createDiagnostic) {
        extendedConfig = (0, util_1.normalizeSlashes)(extendedConfig);
        if (isRootedDiskPath(extendedConfig) || startsWith2(extendedConfig, "./") || startsWith2(extendedConfig, "../")) {
          let extendedConfigPath = getNormalizedAbsolutePath(extendedConfig, basePath);
          if (!host.fileExists(extendedConfigPath) && !endsWith2(extendedConfigPath, ts.Extension.Json)) {
            extendedConfigPath = `${extendedConfigPath}.json`;
            if (!host.fileExists(extendedConfigPath)) {
              errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));
              return void 0;
            }
          }
          return extendedConfigPath;
        }
        const resolved = ts.nodeModuleNameResolver(
          extendedConfig,
          combinePaths(basePath, "tsconfig.json"),
          { moduleResolution: ts.ModuleResolutionKind.NodeJs },
          host,
          /*cache*/
          void 0,
          /*projectRefs*/
          void 0,
          /*lookupConfig*/
          true
        );
        if (resolved.resolvedModule) {
          return resolved.resolvedModule.resolvedFileName;
        }
        errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));
        return void 0;
      }
      return { getExtendsConfigPath };
    }
    function isRootedDiskPath(path3) {
      return (0, path_1.isAbsolute)(path3);
    }
    function combinePaths(path3, ...paths3) {
      return (0, util_1.normalizeSlashes)((0, path_1.resolve)(path3, ...paths3.filter((path4) => path4)));
    }
    function getNormalizedAbsolutePath(fileName, currentDirectory) {
      return (0, util_1.normalizeSlashes)(currentDirectory != null ? (0, path_1.resolve)(currentDirectory, fileName) : (0, path_1.resolve)(fileName));
    }
    function startsWith2(str, prefix) {
      return str.lastIndexOf(prefix, 0) === 0;
    }
    function endsWith2(str, suffix) {
      const expectedPos = str.length - suffix.length;
      return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;
    }
    var reservedCharacterPattern = /[^\w\s\/]/g;
    function getPatternFromSpec(spec, basePath) {
      const pattern = spec && getSubPatternFromSpec(spec, basePath, excludeMatcher);
      return pattern && `^(${pattern})${"($|/)"}`;
    }
    exports.getPatternFromSpec = getPatternFromSpec;
    function getSubPatternFromSpec(spec, basePath, { singleAsteriskRegexFragment, doubleAsteriskRegexFragment, replaceWildcardCharacter: replaceWildcardCharacter2 }) {
      let subpattern = "";
      let hasWrittenComponent = false;
      const components = getNormalizedPathComponents(spec, basePath);
      const lastComponent = last2(components);
      components[0] = removeTrailingDirectorySeparator(components[0]);
      if (isImplicitGlob(lastComponent)) {
        components.push("**", "*");
      }
      let optionalCount = 0;
      for (let component of components) {
        if (component === "**") {
          subpattern += doubleAsteriskRegexFragment;
        } else {
          if (hasWrittenComponent) {
            subpattern += directorySeparator;
          }
          subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter2);
        }
        hasWrittenComponent = true;
      }
      while (optionalCount > 0) {
        subpattern += ")?";
        optionalCount--;
      }
      return subpattern;
    }
    var excludeMatcher = {
      singleAsteriskRegexFragment: "[^/]*",
      doubleAsteriskRegexFragment: "(/.+?)?",
      replaceWildcardCharacter: (match3) => replaceWildcardCharacter(match3, excludeMatcher.singleAsteriskRegexFragment)
    };
    function getNormalizedPathComponents(path3, currentDirectory) {
      return reducePathComponents(getPathComponents(path3, currentDirectory));
    }
    function getPathComponents(path3, currentDirectory = "") {
      path3 = combinePaths(currentDirectory, path3);
      return pathComponents(path3, getRootLength(path3));
    }
    function reducePathComponents(components) {
      if (!some(components))
        return [];
      const reduced2 = [components[0]];
      for (let i = 1; i < components.length; i++) {
        const component = components[i];
        if (!component)
          continue;
        if (component === ".")
          continue;
        if (component === "..") {
          if (reduced2.length > 1) {
            if (reduced2[reduced2.length - 1] !== "..") {
              reduced2.pop();
              continue;
            }
          } else if (reduced2[0])
            continue;
        }
        reduced2.push(component);
      }
      return reduced2;
    }
    function getRootLength(path3) {
      const rootLength = getEncodedRootLength(path3);
      return rootLength < 0 ? ~rootLength : rootLength;
    }
    function getEncodedRootLength(path3) {
      if (!path3)
        return 0;
      const ch0 = path3.charCodeAt(0);
      if (ch0 === 47 || ch0 === 92) {
        if (path3.charCodeAt(1) !== ch0)
          return 1;
        const p1 = path3.indexOf(ch0 === 47 ? directorySeparator : altDirectorySeparator, 2);
        if (p1 < 0)
          return path3.length;
        return p1 + 1;
      }
      if (isVolumeCharacter(ch0) && path3.charCodeAt(1) === 58) {
        const ch2 = path3.charCodeAt(2);
        if (ch2 === 47 || ch2 === 92)
          return 3;
        if (path3.length === 2)
          return 2;
      }
      const schemeEnd = path3.indexOf(urlSchemeSeparator);
      if (schemeEnd !== -1) {
        const authorityStart = schemeEnd + urlSchemeSeparator.length;
        const authorityEnd = path3.indexOf(directorySeparator, authorityStart);
        if (authorityEnd !== -1) {
          const scheme = path3.slice(0, schemeEnd);
          const authority = path3.slice(authorityStart, authorityEnd);
          if (scheme === "file" && (authority === "" || authority === "localhost") && isVolumeCharacter(path3.charCodeAt(authorityEnd + 1))) {
            const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path3, authorityEnd + 2);
            if (volumeSeparatorEnd !== -1) {
              if (path3.charCodeAt(volumeSeparatorEnd) === 47) {
                return ~(volumeSeparatorEnd + 1);
              }
              if (volumeSeparatorEnd === path3.length) {
                return ~volumeSeparatorEnd;
              }
            }
          }
          return ~(authorityEnd + 1);
        }
        return ~path3.length;
      }
      return 0;
    }
    function hasTrailingDirectorySeparator(path3) {
      return path3.length > 0 && isAnyDirectorySeparator(path3.charCodeAt(path3.length - 1));
    }
    function isAnyDirectorySeparator(charCode) {
      return charCode === 47 || charCode === 92;
    }
    function removeTrailingDirectorySeparator(path3) {
      if (hasTrailingDirectorySeparator(path3)) {
        return path3.substr(0, path3.length - 1);
      }
      return path3;
    }
    var directorySeparator = "/";
    var altDirectorySeparator = "\\";
    var urlSchemeSeparator = "://";
    function isVolumeCharacter(charCode) {
      return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90;
    }
    function getFileUrlVolumeSeparatorEnd(url, start) {
      const ch0 = url.charCodeAt(start);
      if (ch0 === 58)
        return start + 1;
      if (ch0 === 37 && url.charCodeAt(start + 1) === 51) {
        const ch2 = url.charCodeAt(start + 2);
        if (ch2 === 97 || ch2 === 65)
          return start + 3;
      }
      return -1;
    }
    function some(array, predicate) {
      if (array) {
        if (predicate) {
          for (const v of array) {
            if (predicate(v)) {
              return true;
            }
          }
        } else {
          return array.length > 0;
        }
      }
      return false;
    }
    function pathComponents(path3, rootLength) {
      const root = path3.substring(0, rootLength);
      const rest = path3.substring(rootLength).split(directorySeparator);
      if (rest.length && !lastOrUndefined(rest))
        rest.pop();
      return [root, ...rest];
    }
    function lastOrUndefined(array) {
      return array.length === 0 ? void 0 : array[array.length - 1];
    }
    function last2(array) {
      return array[array.length - 1];
    }
    function replaceWildcardCharacter(match3, singleAsteriskRegexFragment) {
      return match3 === "*" ? singleAsteriskRegexFragment : match3 === "?" ? "[^/]" : "\\" + match3;
    }
    function isImplicitGlob(lastPathComponent) {
      return !/[.*?]/.test(lastPathComponent);
    }
  }
});

// node_modules/.pnpm/@tsconfig+node16@1.0.4/node_modules/@tsconfig/node16/tsconfig.json
var require_tsconfig = __commonJS({
  "node_modules/.pnpm/@tsconfig+node16@1.0.4/node_modules/@tsconfig/node16/tsconfig.json"(exports, module) {
    module.exports = {
      $schema: "https://json.schemastore.org/tsconfig",
      display: "Node 16",
      compilerOptions: {
        lib: ["es2021"],
        module: "Node16",
        target: "es2021",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        moduleResolution: "node"
      }
    };
  }
});

// node_modules/.pnpm/@tsconfig+node14@1.0.3/node_modules/@tsconfig/node14/tsconfig.json
var require_tsconfig2 = __commonJS({
  "node_modules/.pnpm/@tsconfig+node14@1.0.3/node_modules/@tsconfig/node14/tsconfig.json"(exports, module) {
    module.exports = {
      $schema: "https://json.schemastore.org/tsconfig",
      display: "Node 14",
      compilerOptions: {
        lib: ["es2020"],
        module: "commonjs",
        target: "es2020",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        moduleResolution: "node"
      }
    };
  }
});

// node_modules/.pnpm/@tsconfig+node12@1.0.11/node_modules/@tsconfig/node12/tsconfig.json
var require_tsconfig3 = __commonJS({
  "node_modules/.pnpm/@tsconfig+node12@1.0.11/node_modules/@tsconfig/node12/tsconfig.json"(exports, module) {
    module.exports = {
      $schema: "https://json.schemastore.org/tsconfig",
      display: "Node 12",
      compilerOptions: {
        lib: ["es2019", "es2020.promise", "es2020.bigint", "es2020.string"],
        module: "commonjs",
        target: "es2019",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        moduleResolution: "node"
      }
    };
  }
});

// node_modules/.pnpm/@tsconfig+node10@1.0.9/node_modules/@tsconfig/node10/tsconfig.json
var require_tsconfig4 = __commonJS({
  "node_modules/.pnpm/@tsconfig+node10@1.0.9/node_modules/@tsconfig/node10/tsconfig.json"(exports, module) {
    module.exports = {
      $schema: "https://json.schemastore.org/tsconfig",
      display: "Node 10",
      compilerOptions: {
        lib: ["es2018"],
        module: "commonjs",
        target: "es2018",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        moduleResolution: "node"
      }
    };
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/tsconfigs.js
var require_tsconfigs = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/tsconfigs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDefaultTsconfigJsonForNodeVersion = void 0;
    var nodeMajor = parseInt(process.versions.node.split(".")[0], 10);
    function getDefaultTsconfigJsonForNodeVersion(ts) {
      const tsInternal = ts;
      if (nodeMajor >= 16) {
        const config = require_tsconfig();
        if (configCompatible(config))
          return config;
      }
      if (nodeMajor >= 14) {
        const config = require_tsconfig2();
        if (configCompatible(config))
          return config;
      }
      if (nodeMajor >= 12) {
        const config = require_tsconfig3();
        if (configCompatible(config))
          return config;
      }
      return require_tsconfig4();
      function configCompatible(config) {
        return typeof ts.ScriptTarget[config.compilerOptions.target.toUpperCase()] === "number" && tsInternal.libs && config.compilerOptions.lib.every((lib) => tsInternal.libs.includes(lib));
      }
    }
    exports.getDefaultTsconfigJsonForNodeVersion = getDefaultTsconfigJsonForNodeVersion;
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/configuration.js
var require_configuration = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTsConfigDefaults = exports.ComputeAsCommonRootOfFiles = exports.loadCompiler = exports.resolveAndLoadCompiler = exports.readConfig = exports.findAndReadConfig = void 0;
    var path_1 = require_path();
    var index_1 = require_dist4();
    var ts_internals_1 = require_ts_internals();
    var tsconfigs_1 = require_tsconfigs();
    var util_1 = require_util4();
    var TS_NODE_COMPILER_OPTIONS = {
      sourceMap: true,
      inlineSourceMap: false,
      inlineSources: true,
      declaration: false,
      noEmit: false,
      outDir: ".ts-node"
    };
    function fixConfig(ts, config) {
      delete config.options.out;
      delete config.options.outFile;
      delete config.options.composite;
      delete config.options.declarationDir;
      delete config.options.declarationMap;
      delete config.options.emitDeclarationOnly;
      if (config.options.target === void 0) {
        config.options.target = ts.ScriptTarget.ES5;
      }
      if (config.options.module === void 0) {
        config.options.module = ts.ModuleKind.CommonJS;
      }
      return config;
    }
    function findAndReadConfig(rawOptions) {
      var _a, _b, _c, _d, _e;
      const cwd = (0, path_1.resolve)((_c = (_b = (_a = rawOptions.cwd) !== null && _a !== void 0 ? _a : rawOptions.dir) !== null && _b !== void 0 ? _b : index_1.DEFAULTS.cwd) !== null && _c !== void 0 ? _c : process.cwd());
      const compilerName = (_d = rawOptions.compiler) !== null && _d !== void 0 ? _d : index_1.DEFAULTS.compiler;
      let projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(void 0, rawOptions.projectSearchDir, rawOptions.project, cwd);
      let { compiler, ts } = resolveAndLoadCompiler(compilerName, projectLocalResolveDir);
      const { configFilePath, config, tsNodeOptionsFromTsconfig, optionBasePaths } = readConfig(cwd, ts, rawOptions);
      const options = (0, util_1.assign)({}, index_1.DEFAULTS, tsNodeOptionsFromTsconfig || {}, { optionBasePaths }, rawOptions);
      options.require = [
        ...tsNodeOptionsFromTsconfig.require || [],
        ...rawOptions.require || []
      ];
      if (configFilePath) {
        projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(configFilePath, rawOptions.projectSearchDir, rawOptions.project, cwd);
        ({ compiler } = resolveCompiler(options.compiler, (_e = optionBasePaths.compiler) !== null && _e !== void 0 ? _e : projectLocalResolveDir));
      }
      return {
        options,
        config,
        projectLocalResolveDir,
        optionBasePaths,
        configFilePath,
        cwd,
        compiler
      };
    }
    exports.findAndReadConfig = findAndReadConfig;
    function readConfig(cwd, ts, rawApiOptions) {
      var _a, _b, _c;
      const configChain = [];
      let config = { compilerOptions: {} };
      let basePath = cwd;
      let configFilePath = void 0;
      const projectSearchDir = (0, path_1.resolve)(cwd, (_a = rawApiOptions.projectSearchDir) !== null && _a !== void 0 ? _a : cwd);
      const { fileExists = ts.sys.fileExists, readFile = ts.sys.readFile, skipProject = index_1.DEFAULTS.skipProject, project: project2 = index_1.DEFAULTS.project, tsTrace = index_1.DEFAULTS.tsTrace } = rawApiOptions;
      if (!skipProject) {
        if (project2) {
          const resolved = (0, path_1.resolve)(cwd, project2);
          const nested = (0, path_1.join)(resolved, "tsconfig.json");
          configFilePath = fileExists(nested) ? nested : resolved;
        } else {
          configFilePath = ts.findConfigFile(projectSearchDir, fileExists);
        }
        if (configFilePath) {
          let pathToNextConfigInChain = configFilePath;
          const tsInternals = (0, ts_internals_1.createTsInternals)(ts);
          const errors = [];
          while (true) {
            const result = ts.readConfigFile(pathToNextConfigInChain, readFile);
            if (result.error) {
              return {
                configFilePath,
                config: { errors: [result.error], fileNames: [], options: {} },
                tsNodeOptionsFromTsconfig: {},
                optionBasePaths: {}
              };
            }
            const c = result.config;
            const bp = (0, path_1.dirname)(pathToNextConfigInChain);
            configChain.push({
              config: c,
              basePath: bp,
              configPath: pathToNextConfigInChain
            });
            if (c.extends == null)
              break;
            const resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(c.extends, {
              fileExists,
              readDirectory: ts.sys.readDirectory,
              readFile,
              useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,
              trace: tsTrace
            }, bp, errors, ts.createCompilerDiagnostic);
            if (errors.length) {
              return {
                configFilePath,
                config: { errors, fileNames: [], options: {} },
                tsNodeOptionsFromTsconfig: {},
                optionBasePaths: {}
              };
            }
            if (resolvedExtendedConfigPath == null)
              break;
            pathToNextConfigInChain = resolvedExtendedConfigPath;
          }
          ({ config, basePath } = configChain[0]);
        }
      }
      const tsNodeOptionsFromTsconfig = {};
      const optionBasePaths = {};
      for (let i = configChain.length - 1; i >= 0; i--) {
        const { config: config2, basePath: basePath2, configPath } = configChain[i];
        const options = filterRecognizedTsConfigTsNodeOptions(config2["ts-node"]).recognized;
        if (options.require) {
          const tsconfigRelativeResolver = (0, util_1.createProjectLocalResolveHelper)((0, path_1.dirname)(configPath));
          options.require = options.require.map((path3) => tsconfigRelativeResolver(path3, false));
        }
        if (options.scopeDir) {
          options.scopeDir = (0, path_1.resolve)(basePath2, options.scopeDir);
        }
        if (options.moduleTypes) {
          optionBasePaths.moduleTypes = basePath2;
        }
        if (options.transpiler != null) {
          optionBasePaths.transpiler = basePath2;
        }
        if (options.compiler != null) {
          optionBasePaths.compiler = basePath2;
        }
        if (options.swc != null) {
          optionBasePaths.swc = basePath2;
        }
        (0, util_1.assign)(tsNodeOptionsFromTsconfig, options);
      }
      const files = (_c = (_b = rawApiOptions.files) !== null && _b !== void 0 ? _b : tsNodeOptionsFromTsconfig.files) !== null && _c !== void 0 ? _c : index_1.DEFAULTS.files;
      const skipDefaultCompilerOptions = configFilePath != null;
      const defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions ? void 0 : {
        ...(0, tsconfigs_1.getDefaultTsconfigJsonForNodeVersion)(ts).compilerOptions,
        types: ["node"]
      };
      config.compilerOptions = Object.assign(
        {},
        // automatically-applied options from @tsconfig/bases
        defaultCompilerOptionsForNodeVersion,
        // tsconfig.json "compilerOptions"
        config.compilerOptions,
        // from env var
        index_1.DEFAULTS.compilerOptions,
        // tsconfig.json "ts-node": "compilerOptions"
        tsNodeOptionsFromTsconfig.compilerOptions,
        // passed programmatically
        rawApiOptions.compilerOptions,
        // overrides required by ts-node, cannot be changed
        TS_NODE_COMPILER_OPTIONS
      );
      const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {
        fileExists,
        readFile,
        // Only used for globbing "files", "include", "exclude"
        // When `files` option disabled, we want to avoid the fs calls
        readDirectory: files ? ts.sys.readDirectory : () => [],
        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames
      }, basePath, void 0, configFilePath));
      return {
        configFilePath,
        config: fixedConfig,
        tsNodeOptionsFromTsconfig,
        optionBasePaths
      };
    }
    exports.readConfig = readConfig;
    function resolveAndLoadCompiler(name, relativeToPath) {
      const { compiler } = resolveCompiler(name, relativeToPath);
      const ts = loadCompiler(compiler);
      return { compiler, ts };
    }
    exports.resolveAndLoadCompiler = resolveAndLoadCompiler;
    function resolveCompiler(name, relativeToPath) {
      const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(relativeToPath);
      const compiler = projectLocalResolveHelper(name || "typescript", true);
      return { compiler };
    }
    function loadCompiler(compiler) {
      return (0, util_1.attemptRequireWithV8CompileCache)(__require, compiler);
    }
    exports.loadCompiler = loadCompiler;
    function filterRecognizedTsConfigTsNodeOptions(jsonObject) {
      if (jsonObject == null)
        return { recognized: {}, unrecognized: {} };
      const { compiler, compilerHost, compilerOptions, emit, files, ignore, ignoreDiagnostics, logError, preferTsExts, pretty, require: require2, skipIgnore, transpileOnly, typeCheck, transpiler, scope, scopeDir, moduleTypes, experimentalReplAwait, swc, experimentalResolver, esm, experimentalSpecifierResolution, experimentalTsImportSpecifiers, ...unrecognized } = jsonObject;
      const filteredTsConfigOptions = {
        compiler,
        compilerHost,
        compilerOptions,
        emit,
        experimentalReplAwait,
        files,
        ignore,
        ignoreDiagnostics,
        logError,
        preferTsExts,
        pretty,
        require: require2,
        skipIgnore,
        transpileOnly,
        typeCheck,
        transpiler,
        scope,
        scopeDir,
        moduleTypes,
        swc,
        experimentalResolver,
        esm,
        experimentalSpecifierResolution,
        experimentalTsImportSpecifiers
      };
      const catchExtraneousProps = null;
      const catchMissingProps = null;
      return { recognized: filteredTsConfigOptions, unrecognized };
    }
    exports.ComputeAsCommonRootOfFiles = Symbol();
    function getTsConfigDefaults(config, basePath, _files, _include, _exclude) {
      const { composite = false } = config.options;
      let rootDir = config.options.rootDir;
      if (rootDir == null) {
        if (composite)
          rootDir = basePath;
        else
          rootDir = exports.ComputeAsCommonRootOfFiles;
      }
      const { outDir = rootDir } = config.options;
      const include = _files ? [] : ["**/*"];
      const files = _files !== null && _files !== void 0 ? _files : [];
      const exclude = _exclude !== null && _exclude !== void 0 ? _exclude : [outDir];
      return { rootDir, outDir, include, files, exclude, composite };
    }
    exports.getTsConfigDefaults = getTsConfigDefaults;
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/module-type-classifier.js
var require_module_type_classifier = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/module-type-classifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createModuleTypeClassifier = void 0;
    var ts_internals_1 = require_ts_internals();
    var util_1 = require_util4();
    function createModuleTypeClassifier(options) {
      const { patterns, basePath: _basePath } = options;
      const basePath = _basePath !== void 0 ? (0, util_1.normalizeSlashes)(_basePath).replace(/\/$/, "") : void 0;
      const patternTypePairs = Object.entries(patterns !== null && patterns !== void 0 ? patterns : []).map(([_pattern, type3]) => {
        const pattern = (0, util_1.normalizeSlashes)(_pattern);
        return { pattern: parsePattern(basePath, pattern), type: type3 };
      });
      const classifications = {
        package: {
          moduleType: "auto"
        },
        cjs: {
          moduleType: "cjs"
        },
        esm: {
          moduleType: "esm"
        }
      };
      const auto = classifications.package;
      function classifyModuleNonCached(path3) {
        const matched = matchPatterns(patternTypePairs, (_) => _.pattern, path3);
        if (matched)
          return classifications[matched.type];
        return auto;
      }
      const classifyModule = (0, util_1.cachedLookup)(classifyModuleNonCached);
      function classifyModuleAuto(path3) {
        return auto;
      }
      return {
        classifyModuleByModuleTypeOverrides: patternTypePairs.length ? classifyModule : classifyModuleAuto
      };
    }
    exports.createModuleTypeClassifier = createModuleTypeClassifier;
    function parsePattern(basePath, patternString) {
      const pattern = (0, ts_internals_1.getPatternFromSpec)(patternString, basePath);
      return pattern !== void 0 ? new RegExp(pattern) : /(?:)/;
    }
    function matchPatterns(objects, getPattern, candidate) {
      for (let i = objects.length - 1; i >= 0; i--) {
        const object = objects[i];
        const pattern = getPattern(object);
        if (pattern === null || pattern === void 0 ? void 0 : pattern.test(candidate)) {
          return object;
        }
      }
    }
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/resolver-functions.js
var require_resolver_functions = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/resolver-functions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createResolverFunctions = void 0;
    var path_1 = require_path();
    function createResolverFunctions(kwargs) {
      const { host, ts, config, cwd, getCanonicalFileName, projectLocalResolveHelper, options, extensions } = kwargs;
      const moduleResolutionCache = ts.createModuleResolutionCache(cwd, getCanonicalFileName, config.options);
      const knownInternalFilenames = /* @__PURE__ */ new Set();
      const internalBuckets = /* @__PURE__ */ new Set();
      const moduleBucketRe = /.*\/node_modules\/(?:@[^\/]+\/)?[^\/]+\//;
      function getModuleBucket(filename) {
        const find3 = moduleBucketRe.exec(filename);
        if (find3)
          return find3[0];
        return "";
      }
      function markBucketOfFilenameInternal(filename) {
        internalBuckets.add(getModuleBucket(filename));
      }
      function isFileInInternalBucket(filename) {
        return internalBuckets.has(getModuleBucket(filename));
      }
      function isFileKnownToBeInternal(filename) {
        return knownInternalFilenames.has(filename);
      }
      const fixupResolvedModule = (resolvedModule) => {
        const { resolvedFileName } = resolvedModule;
        if (resolvedFileName === void 0)
          return;
        if (resolvedModule.isExternalLibraryImport && (resolvedFileName.endsWith(".ts") && !resolvedFileName.endsWith(".d.ts") || resolvedFileName.endsWith(".cts") && !resolvedFileName.endsWith(".d.cts") || resolvedFileName.endsWith(".mts") && !resolvedFileName.endsWith(".d.mts") || isFileKnownToBeInternal(resolvedFileName) || isFileInInternalBucket(resolvedFileName))) {
          resolvedModule.isExternalLibraryImport = false;
        }
        if (!resolvedModule.isExternalLibraryImport) {
          knownInternalFilenames.add(resolvedFileName);
        }
      };
      const resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, optionsOnlyWithNewerTsVersions, containingSourceFile) => {
        return moduleNames.map((moduleName, i) => {
          var _a, _b;
          const mode = containingSourceFile ? (_b = (_a = ts).getModeForResolutionAtIndex) === null || _b === void 0 ? void 0 : _b.call(_a, containingSourceFile, i) : void 0;
          let { resolvedModule } = ts.resolveModuleName(moduleName, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode);
          if (!resolvedModule && options.experimentalTsImportSpecifiers) {
            const lastDotIndex = moduleName.lastIndexOf(".");
            const ext = lastDotIndex >= 0 ? moduleName.slice(lastDotIndex) : "";
            if (ext) {
              const replacements = extensions.tsResolverEquivalents.get(ext);
              for (const replacementExt of replacements !== null && replacements !== void 0 ? replacements : []) {
                ({ resolvedModule } = ts.resolveModuleName(moduleName.slice(0, -ext.length) + replacementExt, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode));
                if (resolvedModule)
                  break;
              }
            }
          }
          if (resolvedModule) {
            fixupResolvedModule(resolvedModule);
          }
          return resolvedModule;
        });
      };
      const getResolvedModuleWithFailedLookupLocationsFromCache = (moduleName, containingFile, resolutionMode) => {
        const ret = ts.resolveModuleNameFromCache(moduleName, containingFile, moduleResolutionCache, resolutionMode);
        if (ret && ret.resolvedModule) {
          fixupResolvedModule(ret.resolvedModule);
        }
        return ret;
      };
      const resolveTypeReferenceDirectives = (typeDirectiveNames, containingFile, redirectedReference, options2, containingFileMode) => {
        return typeDirectiveNames.map((typeDirectiveName) => {
          const nameIsString = typeof typeDirectiveName === "string";
          const mode = nameIsString ? void 0 : ts.getModeForFileReference(typeDirectiveName, containingFileMode);
          const strName = nameIsString ? typeDirectiveName : typeDirectiveName.fileName.toLowerCase();
          let { resolvedTypeReferenceDirective } = ts.resolveTypeReferenceDirective(strName, containingFile, config.options, host, redirectedReference, void 0, mode);
          if (typeDirectiveName === "node" && !resolvedTypeReferenceDirective) {
            let typesNodePackageJsonPath;
            try {
              typesNodePackageJsonPath = projectLocalResolveHelper("@types/node/package.json", true);
            } catch {
            }
            if (typesNodePackageJsonPath) {
              const typeRoots = [(0, path_1.resolve)(typesNodePackageJsonPath, "../..")];
              ({ resolvedTypeReferenceDirective } = ts.resolveTypeReferenceDirective(typeDirectiveName, containingFile, {
                ...config.options,
                typeRoots
              }, host, redirectedReference));
            }
          }
          if (resolvedTypeReferenceDirective) {
            fixupResolvedModule(resolvedTypeReferenceDirective);
          }
          return resolvedTypeReferenceDirective;
        });
      };
      return {
        resolveModuleNames,
        getResolvedModuleWithFailedLookupLocationsFromCache,
        resolveTypeReferenceDirectives,
        isFileKnownToBeInternal,
        markBucketOfFilenameInternal
      };
    }
    exports.createResolverFunctions = createResolverFunctions;
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/cjs-resolve-hooks.js
var require_cjs_resolve_hooks = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/cjs-resolve-hooks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.installCommonjsResolveHooksIfNecessary = void 0;
    function installCommonjsResolveHooksIfNecessary(tsNodeService) {
      const Module = require_module();
      const originalResolveFilename = Module._resolveFilename;
      const originalFindPath = Module._findPath;
      const shouldInstallHook = tsNodeService.options.experimentalResolver;
      if (shouldInstallHook) {
        let _resolveFilename = function(request, parent, isMain, options, ...rest) {
          if (!tsNodeService.enabled())
            return originalResolveFilename.call(this, request, parent, isMain, options, ...rest);
          return Module_resolveFilename.call(this, request, parent, isMain, options, ...rest);
        }, _findPath = function() {
          if (!tsNodeService.enabled())
            return originalFindPath.apply(this, arguments);
          return Module_findPath.apply(this, arguments);
        };
        const { Module_findPath, Module_resolveFilename } = tsNodeService.getNodeCjsLoader();
        Module._resolveFilename = _resolveFilename;
        Module._findPath = _findPath;
      }
    }
    exports.installCommonjsResolveHooksIfNecessary = installCommonjsResolveHooksIfNecessary;
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-primordials.js
var require_node_primordials = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-primordials.js"(exports, module) {
    module.exports = {
      ArrayFrom: Array.from,
      ArrayIsArray: Array.isArray,
      ArrayPrototypeShift: (obj) => Array.prototype.shift.call(obj),
      ArrayPrototypeForEach: (arr, ...rest) => Array.prototype.forEach.apply(arr, rest),
      ArrayPrototypeIncludes: (arr, ...rest) => Array.prototype.includes.apply(arr, rest),
      ArrayPrototypeJoin: (arr, ...rest) => Array.prototype.join.apply(arr, rest),
      ArrayPrototypePop: (arr, ...rest) => Array.prototype.pop.apply(arr, rest),
      ArrayPrototypePush: (arr, ...rest) => Array.prototype.push.apply(arr, rest),
      FunctionPrototype: Function.prototype,
      JSONParse: JSON.parse,
      JSONStringify: JSON.stringify,
      ObjectFreeze: Object.freeze,
      ObjectKeys: Object.keys,
      ObjectGetOwnPropertyNames: Object.getOwnPropertyNames,
      ObjectDefineProperty: Object.defineProperty,
      ObjectPrototypeHasOwnProperty: (obj, prop3) => Object.prototype.hasOwnProperty.call(obj, prop3),
      RegExpPrototypeExec: (obj, string2) => RegExp.prototype.exec.call(obj, string2),
      RegExpPrototypeTest: (obj, string2) => RegExp.prototype.test.call(obj, string2),
      RegExpPrototypeSymbolReplace: (obj, ...rest) => RegExp.prototype[Symbol.replace].apply(obj, rest),
      SafeMap: Map,
      SafeSet: Set,
      SafeWeakMap: WeakMap,
      StringPrototypeEndsWith: (str, ...rest) => String.prototype.endsWith.apply(str, rest),
      StringPrototypeIncludes: (str, ...rest) => String.prototype.includes.apply(str, rest),
      StringPrototypeLastIndexOf: (str, ...rest) => String.prototype.lastIndexOf.apply(str, rest),
      StringPrototypeIndexOf: (str, ...rest) => String.prototype.indexOf.apply(str, rest),
      StringPrototypeRepeat: (str, ...rest) => String.prototype.repeat.apply(str, rest),
      StringPrototypeReplace: (str, ...rest) => String.prototype.replace.apply(str, rest),
      StringPrototypeSlice: (str, ...rest) => String.prototype.slice.apply(str, rest),
      StringPrototypeSplit: (str, ...rest) => String.prototype.split.apply(str, rest),
      StringPrototypeStartsWith: (str, ...rest) => String.prototype.startsWith.apply(str, rest),
      StringPrototypeSubstr: (str, ...rest) => String.prototype.substr.apply(str, rest),
      StringPrototypeCharCodeAt: (str, ...rest) => String.prototype.charCodeAt.apply(str, rest),
      StringPrototypeMatch: (str, ...rest) => String.prototype.match.apply(str, rest),
      SyntaxError
    };
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-nativemodule.js
var require_node_nativemodule = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-nativemodule.js"(exports) {
    var Module = require_module();
    var NativeModule = {
      canBeRequiredByUsers(specifier) {
        return Module.builtinModules.includes(specifier);
      }
    };
    exports.NativeModule = NativeModule;
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internalBinding-fs.js
var require_node_internalBinding_fs = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internalBinding-fs.js"(exports, module) {
    var fs = require_fs();
    var { versionGteLt } = require_util4();
    function internalModuleReadJSON(path3) {
      let string2;
      try {
        string2 = fs.readFileSync(path3, "utf8");
      } catch (e) {
        if (e.code === "ENOENT")
          return [];
        throw e;
      }
      const containsKeys = true;
      return [string2, containsKeys];
    }
    function internalModuleStat(path3) {
      const stat = fs.statSync(path3, { throwIfNoEntry: false });
      if (!stat)
        return -1;
      if (stat.isFile())
        return 0;
      if (stat.isDirectory())
        return 1;
    }
    function internalModuleStatInefficient(path3) {
      try {
        const stat = fs.statSync(path3);
        if (stat.isFile())
          return 0;
        if (stat.isDirectory())
          return 1;
      } catch (e) {
        return -e.errno || -1;
      }
    }
    var statSupportsThrowIfNoEntry = versionGteLt(process.versions.node, "15.3.0") || versionGteLt(process.versions.node, "14.17.0", "15.0.0");
    module.exports = {
      internalModuleReadJSON,
      internalModuleStat: statSupportsThrowIfNoEntry ? internalModuleStat : internalModuleStatInefficient
    };
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-modules-package_json_reader.js
var require_node_internal_modules_package_json_reader = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-modules-package_json_reader.js"(exports, module) {
    "use strict";
    var { SafeMap } = require_node_primordials();
    var { internalModuleReadJSON } = require_node_internalBinding_fs();
    var { pathToFileURL } = require_url();
    var { toNamespacedPath } = require_path();
    var cache = new SafeMap();
    var manifest;
    function read(jsonPath) {
      if (cache.has(jsonPath)) {
        return cache.get(jsonPath);
      }
      const [string2, containsKeys] = internalModuleReadJSON(
        toNamespacedPath(jsonPath)
      );
      const result = { string: string2, containsKeys };
      if (string2 !== void 0) {
        if (manifest === void 0) {
          manifest = null;
        }
        if (manifest !== null) {
          const jsonURL = pathToFileURL(jsonPath);
          manifest.assertIntegrity(jsonURL, string2);
        }
      }
      cache.set(jsonPath, result);
      return result;
    }
    module.exports = { read };
  }
});

// node_modules/.pnpm/arg@4.1.3/node_modules/arg/index.js
var require_arg = __commonJS({
  "node_modules/.pnpm/arg@4.1.3/node_modules/arg/index.js"(exports, module) {
    var flagSymbol = Symbol("arg flag");
    function arg(opts, { argv = process.argv.slice(2), permissive = false, stopAtPositional = false } = {}) {
      if (!opts) {
        throw new Error("Argument specification object is required");
      }
      const result = { _: [] };
      const aliases = {};
      const handlers = {};
      for (const key of Object.keys(opts)) {
        if (!key) {
          throw new TypeError("Argument key cannot be an empty string");
        }
        if (key[0] !== "-") {
          throw new TypeError(`Argument key must start with '-' but found: '${key}'`);
        }
        if (key.length === 1) {
          throw new TypeError(`Argument key must have a name; singular '-' keys are not allowed: ${key}`);
        }
        if (typeof opts[key] === "string") {
          aliases[key] = opts[key];
          continue;
        }
        let type3 = opts[key];
        let isFlag = false;
        if (Array.isArray(type3) && type3.length === 1 && typeof type3[0] === "function") {
          const [fn] = type3;
          type3 = (value2, name, prev = []) => {
            prev.push(fn(value2, name, prev[prev.length - 1]));
            return prev;
          };
          isFlag = fn === Boolean || fn[flagSymbol] === true;
        } else if (typeof type3 === "function") {
          isFlag = type3 === Boolean || type3[flagSymbol] === true;
        } else {
          throw new TypeError(`Type missing or not a function or valid array type: ${key}`);
        }
        if (key[1] !== "-" && key.length > 2) {
          throw new TypeError(`Short argument keys (with a single hyphen) must have only one character: ${key}`);
        }
        handlers[key] = [type3, isFlag];
      }
      for (let i = 0, len = argv.length; i < len; i++) {
        const wholeArg = argv[i];
        if (stopAtPositional && result._.length > 0) {
          result._ = result._.concat(argv.slice(i));
          break;
        }
        if (wholeArg === "--") {
          result._ = result._.concat(argv.slice(i + 1));
          break;
        }
        if (wholeArg.length > 1 && wholeArg[0] === "-") {
          const separatedArguments = wholeArg[1] === "-" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split("").map((a) => `-${a}`);
          for (let j = 0; j < separatedArguments.length; j++) {
            const arg2 = separatedArguments[j];
            const [originalArgName, argStr] = arg2[1] === "-" ? arg2.split(/=(.*)/, 2) : [arg2, void 0];
            let argName = originalArgName;
            while (argName in aliases) {
              argName = aliases[argName];
            }
            if (!(argName in handlers)) {
              if (permissive) {
                result._.push(arg2);
                continue;
              } else {
                const err = new Error(`Unknown or unexpected option: ${originalArgName}`);
                err.code = "ARG_UNKNOWN_OPTION";
                throw err;
              }
            }
            const [type3, isFlag] = handlers[argName];
            if (!isFlag && j + 1 < separatedArguments.length) {
              throw new TypeError(`Option requires argument (but was followed by another short argument): ${originalArgName}`);
            }
            if (isFlag) {
              result[argName] = type3(true, argName, result[argName]);
            } else if (argStr === void 0) {
              if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === "-" && !(argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (type3 === Number || // eslint-disable-next-line no-undef
              typeof BigInt !== "undefined" && type3 === BigInt))) {
                const extended = originalArgName === argName ? "" : ` (alias for ${argName})`;
                throw new Error(`Option requires argument: ${originalArgName}${extended}`);
              }
              result[argName] = type3(argv[i + 1], argName, result[argName]);
              ++i;
            } else {
              result[argName] = type3(argStr, argName, result[argName]);
            }
          }
        } else {
          result._.push(wholeArg);
        }
      }
      return result;
    }
    arg.flag = (fn) => {
      fn[flagSymbol] = true;
      return fn;
    };
    arg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);
    module.exports = arg;
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-options.js
var require_node_options = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-options.js"(exports) {
    exports.getOptionValue = getOptionValue;
    function getOptionValue(opt) {
      parseOptions();
      return options[opt];
    }
    var options;
    function parseOptions() {
      if (!options) {
        options = {
          "--preserve-symlinks": false,
          "--preserve-symlinks-main": false,
          "--input-type": void 0,
          "--experimental-specifier-resolution": "explicit",
          "--experimental-policy": void 0,
          "--conditions": [],
          "--pending-deprecation": false,
          ...parseArgv(getNodeOptionsEnvArgv()),
          ...parseArgv(process.execArgv),
          ...getOptionValuesFromOtherEnvVars()
        };
      }
    }
    function parseArgv(argv) {
      return require_arg()({
        "--preserve-symlinks": Boolean,
        "--preserve-symlinks-main": Boolean,
        "--input-type": String,
        "--experimental-specifier-resolution": String,
        // Legacy alias for node versions prior to 12.16
        "--es-module-specifier-resolution": "--experimental-specifier-resolution",
        "--experimental-policy": String,
        "--conditions": [String],
        "--pending-deprecation": Boolean,
        "--experimental-json-modules": Boolean,
        "--experimental-wasm-modules": Boolean
      }, {
        argv,
        permissive: true
      });
    }
    function getNodeOptionsEnvArgv() {
      const errors = [];
      const envArgv = ParseNodeOptionsEnvVar(process.env.NODE_OPTIONS || "", errors);
      if (errors.length !== 0) {
      }
      return envArgv;
    }
    function ParseNodeOptionsEnvVar(node_options, errors) {
      const env_argv = [];
      let is_in_string = false;
      let will_start_new_arg = true;
      for (let index = 0; index < node_options.length; ++index) {
        let c = node_options[index];
        if (c === "\\" && is_in_string) {
          if (index + 1 === node_options.length) {
            errors.push("invalid value for NODE_OPTIONS (invalid escape)\n");
            return env_argv;
          } else {
            c = node_options[++index];
          }
        } else if (c === " " && !is_in_string) {
          will_start_new_arg = true;
          continue;
        } else if (c === '"') {
          is_in_string = !is_in_string;
          continue;
        }
        if (will_start_new_arg) {
          env_argv.push(c);
          will_start_new_arg = false;
        } else {
          env_argv[env_argv.length - 1] += c;
        }
      }
      if (is_in_string) {
        errors.push("invalid value for NODE_OPTIONS (unterminated string)\n");
      }
      return env_argv;
    }
    function getOptionValuesFromOtherEnvVars() {
      const options2 = {};
      if (process.env.NODE_PENDING_DEPRECATION === "1") {
        options2["--pending-deprecation"] = true;
      }
      return options2;
    }
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-modules-cjs-helpers.js
var require_node_internal_modules_cjs_helpers = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-modules-cjs-helpers.js"(exports) {
    "use strict";
    var {
      ArrayPrototypeForEach,
      ObjectDefineProperty,
      ObjectPrototypeHasOwnProperty,
      SafeSet,
      StringPrototypeIncludes,
      StringPrototypeStartsWith
    } = require_node_primordials();
    var { getOptionValue } = require_node_options();
    var userConditions = getOptionValue("--conditions");
    var noAddons = getOptionValue("--no-addons");
    var addonConditions = noAddons ? [] : ["node-addons"];
    var cjsConditions = new SafeSet([
      "require",
      "node",
      ...addonConditions,
      ...userConditions
    ]);
    function addBuiltinLibsToObject(object, dummyModuleName) {
      const Module = require_module().Module;
      const { builtinModules } = Module;
      const dummyModule = new Module(dummyModuleName);
      ArrayPrototypeForEach(builtinModules, (name) => {
        if (StringPrototypeStartsWith(name, "_") || StringPrototypeIncludes(name, "/") || ObjectPrototypeHasOwnProperty(object, name)) {
          return;
        }
        const setReal = (val) => {
          delete object[name];
          object[name] = val;
        };
        ObjectDefineProperty(object, name, {
          get: () => {
            const lib = (dummyModule.require || __require)(name);
            delete object[name];
            ObjectDefineProperty(object, name, {
              get: () => lib,
              set: setReal,
              configurable: true,
              enumerable: false
            });
            return lib;
          },
          set: setReal,
          configurable: true,
          enumerable: false
        });
      });
    }
    exports.addBuiltinLibsToObject = addBuiltinLibsToObject;
    exports.cjsConditions = cjsConditions;
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-errors.js
var require_node_internal_errors = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-errors.js"(exports) {
    "use strict";
    var path3 = require_path();
    exports.codes = {
      ERR_INPUT_TYPE_NOT_ALLOWED: createErrorCtor(joinArgs("ERR_INPUT_TYPE_NOT_ALLOWED")),
      ERR_INVALID_ARG_VALUE: createErrorCtor(joinArgs("ERR_INVALID_ARG_VALUE")),
      ERR_INVALID_MODULE_SPECIFIER: createErrorCtor(joinArgs("ERR_INVALID_MODULE_SPECIFIER")),
      ERR_INVALID_PACKAGE_CONFIG: createErrorCtor(joinArgs("ERR_INVALID_PACKAGE_CONFIG")),
      ERR_INVALID_PACKAGE_TARGET: createErrorCtor(joinArgs("ERR_INVALID_PACKAGE_TARGET")),
      ERR_MANIFEST_DEPENDENCY_MISSING: createErrorCtor(joinArgs("ERR_MANIFEST_DEPENDENCY_MISSING")),
      ERR_MODULE_NOT_FOUND: createErrorCtor((path4, base, type3 = "package") => {
        return `Cannot find ${type3} '${path4}' imported from ${base}`;
      }),
      ERR_PACKAGE_IMPORT_NOT_DEFINED: createErrorCtor(joinArgs("ERR_PACKAGE_IMPORT_NOT_DEFINED")),
      ERR_PACKAGE_PATH_NOT_EXPORTED: createErrorCtor(joinArgs("ERR_PACKAGE_PATH_NOT_EXPORTED")),
      ERR_UNSUPPORTED_DIR_IMPORT: createErrorCtor(joinArgs("ERR_UNSUPPORTED_DIR_IMPORT")),
      ERR_UNSUPPORTED_ESM_URL_SCHEME: createErrorCtor(joinArgs("ERR_UNSUPPORTED_ESM_URL_SCHEME")),
      ERR_UNKNOWN_FILE_EXTENSION: createErrorCtor(joinArgs("ERR_UNKNOWN_FILE_EXTENSION"))
    };
    function joinArgs(name) {
      return (...args) => {
        return [name, ...args].join(" ");
      };
    }
    function createErrorCtor(errorMessageCreator) {
      return class CustomError extends Error {
        constructor(...args) {
          super(errorMessageCreator(...args));
        }
      };
    }
    exports.createErrRequireEsm = createErrRequireEsm;
    function createErrRequireEsm(filename, parentPath, packageJsonPath) {
      const code = "ERR_REQUIRE_ESM";
      const err = new Error(getErrRequireEsmMessage(filename, parentPath, packageJsonPath));
      err.name = `Error [${code}]`;
      err.stack;
      Object.defineProperty(err, "name", {
        value: "Error",
        enumerable: false,
        writable: true,
        configurable: true
      });
      err.code = code;
      return err;
    }
    function getErrRequireEsmMessage(filename, parentPath = null, packageJsonPath = null) {
      const ext = path3.extname(filename);
      let msg = `Must use import to load ES Module: ${filename}`;
      if (parentPath && packageJsonPath) {
        const path4 = require_path();
        const basename = path4.basename(filename) === path4.basename(parentPath) ? filename : path4.basename(filename);
        msg += `
require() of ES modules is not supported.
require() of ${filename} ${parentPath ? `from ${parentPath} ` : ""}is an ES module file as it is a ${ext} file whose nearest parent package.json contains "type": "module" which defines all ${ext} files in that package scope as ES modules.
Instead change the requiring code to use import(), or remove "type": "module" from ${packageJsonPath}.
`;
        return msg;
      }
      return msg;
    }
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-constants.js
var require_node_internal_constants = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-constants.js"(exports, module) {
    module.exports = {
      CHAR_FORWARD_SLASH: 47
      /* / */
    };
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-modules-cjs-loader.js
var require_node_internal_modules_cjs_loader = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-modules-cjs-loader.js"(exports, module) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypePush,
      JSONParse,
      ObjectKeys,
      RegExpPrototypeTest,
      SafeMap,
      SafeWeakMap,
      StringPrototypeCharCodeAt,
      StringPrototypeEndsWith,
      StringPrototypeLastIndexOf,
      StringPrototypeIndexOf,
      StringPrototypeMatch,
      StringPrototypeSlice,
      StringPrototypeStartsWith
    } = require_node_primordials();
    var { NativeModule } = require_node_nativemodule();
    var { pathToFileURL, fileURLToPath } = require_url();
    var fs = require_fs();
    var path3 = require_path();
    var { sep } = path3;
    var { internalModuleStat } = require_node_internalBinding_fs();
    var packageJsonReader = require_node_internal_modules_package_json_reader();
    var {
      cjsConditions
    } = require_node_internal_modules_cjs_helpers();
    var { getOptionValue } = require_node_options();
    var preserveSymlinks = getOptionValue("--preserve-symlinks");
    var preserveSymlinksMain = getOptionValue("--preserve-symlinks-main");
    var { normalizeSlashes } = require_util4();
    var { createErrRequireEsm } = require_node_internal_errors();
    var {
      codes: {
        ERR_INVALID_MODULE_SPECIFIER
      }
    } = require_node_internal_errors();
    var {
      CHAR_FORWARD_SLASH
    } = require_node_internal_constants();
    var Module = require_module();
    var isWindows = process.platform === "win32";
    var statCache = null;
    function stat(filename) {
      filename = path3.toNamespacedPath(filename);
      if (statCache !== null) {
        const result2 = statCache.get(filename);
        if (result2 !== void 0)
          return result2;
      }
      const result = internalModuleStat(filename);
      if (statCache !== null && result >= 0) {
        statCache.set(filename, result);
      }
      return result;
    }
    var moduleParentCache = new SafeWeakMap();
    var packageJsonCache = new SafeMap();
    function readPackage(requestPath) {
      const jsonPath = path3.resolve(requestPath, "package.json");
      const existing = packageJsonCache.get(jsonPath);
      if (existing !== void 0)
        return existing;
      const result = packageJsonReader.read(jsonPath);
      const json2 = result.containsKeys === false ? "{}" : result.string;
      if (json2 === void 0) {
        packageJsonCache.set(jsonPath, false);
        return false;
      }
      try {
        const parsed = JSONParse(json2);
        const filtered = {
          name: parsed.name,
          main: parsed.main,
          exports: parsed.exports,
          imports: parsed.imports,
          type: parsed.type
        };
        packageJsonCache.set(jsonPath, filtered);
        return filtered;
      } catch (e) {
        e.path = jsonPath;
        e.message = "Error parsing " + jsonPath + ": " + e.message;
        throw e;
      }
    }
    function readPackageScope(checkPath) {
      const rootSeparatorIndex = StringPrototypeIndexOf(checkPath, sep);
      let separatorIndex;
      do {
        separatorIndex = StringPrototypeLastIndexOf(checkPath, sep);
        checkPath = StringPrototypeSlice(checkPath, 0, separatorIndex);
        if (StringPrototypeEndsWith(checkPath, sep + "node_modules"))
          return false;
        const pjson = readPackage(checkPath + sep);
        if (pjson)
          return {
            data: pjson,
            path: checkPath
          };
      } while (separatorIndex > rootSeparatorIndex);
      return false;
    }
    function createCjsLoader(opts) {
      const { nodeEsmResolver, preferTsExts } = opts;
      const { replacementsForCjs, replacementsForJs, replacementsForMjs, replacementsForJsx } = opts.extensions;
      const {
        encodedSepRegEx,
        packageExportsResolve,
        packageImportsResolve
      } = nodeEsmResolver;
      function tryPackage(requestPath, exts, isMain, originalPath) {
        const tmp = readPackage(requestPath);
        const pkg = tmp != null ? tmp.main : void 0;
        if (!pkg) {
          return tryExtensions(path3.resolve(requestPath, "index"), exts, isMain);
        }
        const filename = path3.resolve(requestPath, pkg);
        let actual = tryReplacementExtensions(filename, isMain) || tryFile(filename, isMain) || tryExtensions(filename, exts, isMain) || tryExtensions(path3.resolve(filename, "index"), exts, isMain);
        if (actual === false) {
          actual = tryExtensions(path3.resolve(requestPath, "index"), exts, isMain);
          if (!actual) {
            const err = new Error(
              `Cannot find module '${filename}'. Please verify that the package.json has a valid "main" entry`
            );
            err.code = "MODULE_NOT_FOUND";
            err.path = path3.resolve(requestPath, "package.json");
            err.requestPath = originalPath;
            throw err;
          } else {
            const jsonPath = path3.resolve(requestPath, "package.json");
            process.emitWarning(
              `Invalid 'main' field in '${jsonPath}' of '${pkg}'. Please either fix that or report it to the module author`,
              "DeprecationWarning",
              "DEP0128"
            );
          }
        }
        return actual;
      }
      const realpathCache = new SafeMap();
      function tryFile(requestPath, isMain) {
        const rc = stat(requestPath);
        if (rc !== 0)
          return;
        if (preserveSymlinks && !isMain) {
          return path3.resolve(requestPath);
        }
        return toRealPath(requestPath);
      }
      function toRealPath(requestPath) {
        return fs.realpathSync(requestPath, {
          // [internalFS.realpathCacheKey]: realpathCache
        });
      }
      function statReplacementExtensions(p) {
        const lastDotIndex = p.lastIndexOf(".");
        if (lastDotIndex >= 0) {
          const ext = p.slice(lastDotIndex);
          if (ext === ".js" || ext === ".jsx" || ext === ".mjs" || ext === ".cjs") {
            const pathnameWithoutExtension = p.slice(0, lastDotIndex);
            const replacementExts = ext === ".js" ? replacementsForJs : ext === ".jsx" ? replacementsForJsx : ext === ".mjs" ? replacementsForMjs : replacementsForCjs;
            for (let i = 0; i < replacementExts.length; i++) {
              const filename = pathnameWithoutExtension + replacementExts[i];
              const rc = stat(filename);
              if (rc === 0) {
                return [rc, filename];
              }
            }
          }
        }
        return [stat(p), p];
      }
      function tryReplacementExtensions(p, isMain) {
        const lastDotIndex = p.lastIndexOf(".");
        if (lastDotIndex >= 0) {
          const ext = p.slice(lastDotIndex);
          if (ext === ".js" || ext === ".jsx" || ext === ".mjs" || ext === ".cjs") {
            const pathnameWithoutExtension = p.slice(0, lastDotIndex);
            const replacementExts = ext === ".js" ? replacementsForJs : ext === ".jsx" ? replacementsForJsx : ext === ".mjs" ? replacementsForMjs : replacementsForCjs;
            for (let i = 0; i < replacementExts.length; i++) {
              const filename = tryFile(pathnameWithoutExtension + replacementExts[i], isMain);
              if (filename) {
                return filename;
              }
            }
          }
        }
        return false;
      }
      function tryExtensions(p, exts, isMain) {
        for (let i = 0; i < exts.length; i++) {
          const filename = tryFile(p + exts[i], isMain);
          if (filename) {
            return filename;
          }
        }
        return false;
      }
      function trySelfParentPath(parent) {
        if (!parent)
          return false;
        if (parent.filename) {
          return parent.filename;
        } else if (parent.id === "<repl>" || parent.id === "internal/preload") {
          try {
            return process.cwd() + path3.sep;
          } catch {
            return false;
          }
        }
      }
      function trySelf(parentPath, request) {
        if (!parentPath)
          return false;
        const { data: pkg, path: pkgPath } = readPackageScope(parentPath) || {};
        if (!pkg || pkg.exports === void 0)
          return false;
        if (typeof pkg.name !== "string")
          return false;
        let expansion;
        if (request === pkg.name) {
          expansion = ".";
        } else if (StringPrototypeStartsWith(request, `${pkg.name}/`)) {
          expansion = "." + StringPrototypeSlice(request, pkg.name.length);
        } else {
          return false;
        }
        try {
          return finalizeEsmResolution(packageExportsResolve(
            pathToFileURL(pkgPath + "/package.json"),
            expansion,
            pkg,
            pathToFileURL(parentPath),
            cjsConditions
          ).resolved, parentPath, pkgPath);
        } catch (e) {
          if (e.code === "ERR_MODULE_NOT_FOUND")
            throw createEsmNotFoundErr(request, pkgPath + "/package.json");
          throw e;
        }
      }
      const EXPORTS_PATTERN = /^((?:@[^/\\%]+\/)?[^./\\%][^/\\%]*)(\/.*)?$/;
      function resolveExports(nmPath, request) {
        const { 1: name, 2: expansion = "" } = StringPrototypeMatch(request, EXPORTS_PATTERN) || [];
        if (!name)
          return;
        const pkgPath = path3.resolve(nmPath, name);
        const pkg = readPackage(pkgPath);
        if (pkg != null && pkg.exports != null) {
          try {
            return finalizeEsmResolution(packageExportsResolve(
              pathToFileURL(pkgPath + "/package.json"),
              "." + expansion,
              pkg,
              null,
              cjsConditions
            ).resolved, null, pkgPath);
          } catch (e) {
            if (e.code === "ERR_MODULE_NOT_FOUND")
              throw createEsmNotFoundErr(request, pkgPath + "/package.json");
            throw e;
          }
        }
      }
      const hasModulePathCache = !!require_module()._pathCache;
      const Module_pathCache = /* @__PURE__ */ Object.create(null);
      const Module_pathCache_get = hasModulePathCache ? (cacheKey) => Module._pathCache[cacheKey] : (cacheKey) => Module_pathCache[cacheKey];
      const Module_pathCache_set = hasModulePathCache ? (cacheKey, value2) => Module._pathCache[cacheKey] = value2 : (cacheKey) => Module_pathCache[cacheKey] = value;
      const trailingSlashRegex = /(?:^|\/)\.?\.$/;
      const Module_findPath = function _findPath(request, paths3, isMain) {
        const absoluteRequest = path3.isAbsolute(request);
        if (absoluteRequest) {
          paths3 = [""];
        } else if (!paths3 || paths3.length === 0) {
          return false;
        }
        const cacheKey = request + "\0" + ArrayPrototypeJoin(paths3, "\0");
        const entry = Module_pathCache_get(cacheKey);
        if (entry)
          return entry;
        let exts;
        let trailingSlash = request.length > 0 && StringPrototypeCharCodeAt(request, request.length - 1) === CHAR_FORWARD_SLASH;
        if (!trailingSlash) {
          trailingSlash = RegExpPrototypeTest(trailingSlashRegex, request);
        }
        for (let i = 0; i < paths3.length; i++) {
          const curPath = paths3[i];
          if (curPath && stat(curPath) < 1)
            continue;
          if (!absoluteRequest) {
            const exportsResolved = resolveExports(curPath, request);
            if (exportsResolved)
              return exportsResolved;
          }
          const _basePath = path3.resolve(curPath, request);
          let filename;
          const [rc, basePath] = statReplacementExtensions(_basePath);
          if (!trailingSlash) {
            if (rc === 0) {
              if (!isMain) {
                if (preserveSymlinks) {
                  filename = path3.resolve(basePath);
                } else {
                  filename = toRealPath(basePath);
                }
              } else if (preserveSymlinksMain) {
                filename = path3.resolve(basePath);
              } else {
                filename = toRealPath(basePath);
              }
            }
            if (!filename) {
              if (exts === void 0)
                exts = ObjectKeys(Module._extensions);
              filename = tryExtensions(basePath, exts, isMain);
            }
          }
          if (!filename && rc === 1) {
            if (exts === void 0)
              exts = ObjectKeys(Module._extensions);
            filename = tryPackage(basePath, exts, isMain, request);
          }
          if (filename) {
            Module_pathCache_set(cacheKey, filename);
            return filename;
          }
        }
        return false;
      };
      const Module_resolveFilename = function _resolveFilename(request, parent, isMain, options) {
        if (StringPrototypeStartsWith(request, "node:") || NativeModule.canBeRequiredByUsers(request)) {
          return request;
        }
        let paths3;
        if (typeof options === "object" && options !== null) {
          if (ArrayIsArray(options.paths)) {
            const isRelative = StringPrototypeStartsWith(request, "./") || StringPrototypeStartsWith(request, "../") || (isWindows && StringPrototypeStartsWith(request, ".\\") || StringPrototypeStartsWith(request, "..\\"));
            if (isRelative) {
              paths3 = options.paths;
            } else {
              const fakeParent = new Module("", null);
              paths3 = [];
              for (let i = 0; i < options.paths.length; i++) {
                const path4 = options.paths[i];
                fakeParent.paths = Module._nodeModulePaths(path4);
                const lookupPaths = Module._resolveLookupPaths(request, fakeParent);
                for (let j = 0; j < lookupPaths.length; j++) {
                  if (!ArrayPrototypeIncludes(paths3, lookupPaths[j]))
                    ArrayPrototypePush(paths3, lookupPaths[j]);
                }
              }
            }
          } else if (options.paths === void 0) {
            paths3 = Module._resolveLookupPaths(request, parent);
          } else {
            throw new ERR_INVALID_ARG_VALUE("options.paths", options.paths);
          }
        } else {
          paths3 = Module._resolveLookupPaths(request, parent);
        }
        if (parent != null && parent.filename) {
          if (request[0] === "#") {
            const pkg = readPackageScope(parent.filename) || {};
            if (pkg.data != null && pkg.data.imports != null) {
              try {
                return finalizeEsmResolution(
                  packageImportsResolve(
                    request,
                    pathToFileURL(parent.filename),
                    cjsConditions
                  ),
                  parent.filename,
                  pkg.path
                );
              } catch (e) {
                if (e.code === "ERR_MODULE_NOT_FOUND")
                  throw createEsmNotFoundErr(request);
                throw e;
              }
            }
          }
        }
        const parentPath = trySelfParentPath(parent);
        const selfResolved = trySelf(parentPath, request);
        if (selfResolved) {
          const cacheKey = request + "\0" + (paths3.length === 1 ? paths3[0] : ArrayPrototypeJoin(paths3, "\0"));
          Module._pathCache[cacheKey] = selfResolved;
          return selfResolved;
        }
        const filename = Module._findPath(request, paths3, isMain, false);
        if (filename)
          return filename;
        const requireStack = [];
        for (let cursor = parent; cursor; cursor = moduleParentCache.get(cursor)) {
          ArrayPrototypePush(requireStack, cursor.filename || cursor.id);
        }
        let message = `Cannot find module '${request}'`;
        if (requireStack.length > 0) {
          message = message + "\nRequire stack:\n- " + ArrayPrototypeJoin(requireStack, "\n- ");
        }
        const err = new Error(message);
        err.code = "MODULE_NOT_FOUND";
        err.requireStack = requireStack;
        throw err;
      };
      function finalizeEsmResolution(resolved, parentPath, pkgPath) {
        if (RegExpPrototypeTest(encodedSepRegEx, resolved))
          throw new ERR_INVALID_MODULE_SPECIFIER(
            resolved,
            'must not include encoded "/" or "\\" characters',
            parentPath
          );
        const filename = fileURLToPath(resolved);
        const actual = tryReplacementExtensions(filename) || tryFile(filename);
        if (actual)
          return actual;
        const err = createEsmNotFoundErr(
          filename,
          path3.resolve(pkgPath, "package.json")
        );
        throw err;
      }
      function createEsmNotFoundErr(request, path4) {
        const err = new Error(`Cannot find module '${request}'`);
        err.code = "MODULE_NOT_FOUND";
        if (path4)
          err.path = path4;
        return err;
      }
      return {
        Module_findPath,
        Module_resolveFilename
      };
    }
    function assertScriptCanLoadAsCJSImpl(service, module2, filename) {
      const pkg = readPackageScope(filename);
      const tsNodeClassification = service.moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizeSlashes(filename));
      if (tsNodeClassification.moduleType === "cjs")
        return;
      const lastDotIndex = filename.lastIndexOf(".");
      const ext = lastDotIndex >= 0 ? filename.slice(lastDotIndex) : "";
      if ((ext === ".cts" || ext === ".cjs") && tsNodeClassification.moduleType === "auto")
        return;
      if (ext === ".mts" || ext === ".mjs" || tsNodeClassification.moduleType === "esm" || pkg && pkg.data && pkg.data.type === "module") {
        const parentPath = module2.parent && module2.parent.filename;
        const packageJsonPath = pkg ? path3.resolve(pkg.path, "package.json") : null;
        throw createErrRequireEsm(filename, parentPath, packageJsonPath);
      }
    }
    module.exports = {
      createCjsLoader,
      assertScriptCanLoadAsCJSImpl,
      readPackageScope
    };
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/node-module-type-classifier.js
var require_node_module_type_classifier = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/node-module-type-classifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.classifyModule = void 0;
    var node_internal_modules_cjs_loader_1 = require_node_internal_modules_cjs_loader();
    function classifyModule(nativeFilename, isNodeModuleType) {
      const lastDotIndex = nativeFilename.lastIndexOf(".");
      const ext = lastDotIndex >= 0 ? nativeFilename.slice(lastDotIndex) : "";
      switch (ext) {
        case ".cjs":
        case ".cts":
          return isNodeModuleType ? "nodecjs" : "cjs";
        case ".mjs":
        case ".mts":
          return isNodeModuleType ? "nodeesm" : "esm";
      }
      if (isNodeModuleType) {
        const packageScope = (0, node_internal_modules_cjs_loader_1.readPackageScope)(nativeFilename);
        if (packageScope && packageScope.data.type === "module")
          return "nodeesm";
        return "nodecjs";
      }
      return void 0;
    }
    exports.classifyModule = classifyModule;
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/file-extensions.js
var require_file_extensions = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/file-extensions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getExtensions = void 0;
    var util_1 = require_util4();
    var nodeEquivalents = /* @__PURE__ */ new Map([
      [".ts", ".js"],
      [".tsx", ".js"],
      [".jsx", ".js"],
      [".mts", ".mjs"],
      [".cts", ".cjs"]
    ]);
    var tsResolverEquivalents = /* @__PURE__ */ new Map([
      [".ts", [".js"]],
      [".tsx", [".js", ".jsx"]],
      [".mts", [".mjs"]],
      [".cts", [".cjs"]]
    ]);
    var vanillaNodeExtensions = [
      ".js",
      ".json",
      ".node",
      ".mjs",
      ".cjs"
    ];
    var nodeDoesNotUnderstand = [
      ".ts",
      ".tsx",
      ".jsx",
      ".cts",
      ".mts"
    ];
    function getExtensions(config, options, tsVersion) {
      const tsSupportsMtsCtsExts = (0, util_1.versionGteLt)(tsVersion, "4.5.0");
      const requiresHigherTypescriptVersion = [];
      if (!tsSupportsMtsCtsExts)
        requiresHigherTypescriptVersion.push(".cts", ".cjs", ".mts", ".mjs");
      const allPossibleExtensionsSortedByPreference = Array.from(/* @__PURE__ */ new Set([
        ...options.preferTsExts ? nodeDoesNotUnderstand : [],
        ...vanillaNodeExtensions,
        ...nodeDoesNotUnderstand
      ]));
      const compiledJsUnsorted = [".ts"];
      const compiledJsxUnsorted = [];
      if (config.options.jsx)
        compiledJsxUnsorted.push(".tsx");
      if (tsSupportsMtsCtsExts)
        compiledJsUnsorted.push(".mts", ".cts");
      if (config.options.allowJs) {
        compiledJsUnsorted.push(".js");
        if (config.options.jsx)
          compiledJsxUnsorted.push(".jsx");
        if (tsSupportsMtsCtsExts)
          compiledJsUnsorted.push(".mjs", ".cjs");
      }
      const compiledUnsorted = [...compiledJsUnsorted, ...compiledJsxUnsorted];
      const compiled = allPossibleExtensionsSortedByPreference.filter((ext) => compiledUnsorted.includes(ext));
      const compiledNodeDoesNotUnderstand = nodeDoesNotUnderstand.filter((ext) => compiled.includes(ext));
      const r = allPossibleExtensionsSortedByPreference.filter((ext) => [...compiledUnsorted, ".js", ".mjs", ".cjs", ".mts", ".cts"].includes(ext));
      const replacementsForJs = r.filter((ext) => [".js", ".jsx", ".ts", ".tsx"].includes(ext));
      const replacementsForJsx = r.filter((ext) => [".jsx", ".tsx"].includes(ext));
      const replacementsForMjs = r.filter((ext) => [".mjs", ".mts"].includes(ext));
      const replacementsForCjs = r.filter((ext) => [".cjs", ".cts"].includes(ext));
      const replacementsForJsOrMjs = r.filter((ext) => [".js", ".jsx", ".ts", ".tsx", ".mjs", ".mts"].includes(ext));
      const experimentalSpecifierResolutionAddsIfOmitted = Array.from(/* @__PURE__ */ new Set([...replacementsForJsOrMjs, ".json", ".node"]));
      const legacyMainResolveAddsIfOmitted = Array.from(/* @__PURE__ */ new Set([...replacementsForJs, ".json", ".node"]));
      return {
        /** All file extensions we transform, ordered by resolution preference according to preferTsExts */
        compiled,
        /** Resolved extensions that vanilla node will not understand; we should handle them */
        nodeDoesNotUnderstand,
        /** Like the above, but only the ones we're compiling */
        compiledNodeDoesNotUnderstand,
        /**
         * Mapping from extensions understood by tsc to the equivalent for node,
         * as far as getFormat is concerned.
         */
        nodeEquivalents,
        /**
         * Mapping from extensions rejected by TSC in import specifiers, to the
         * possible alternatives that TS's resolver will accept.
         *
         * When we allow users to opt-in to .ts extensions in import specifiers, TS's
         * resolver requires us to replace the .ts extensions with .js alternatives.
         * Otherwise, resolution fails.
         *
         * Note TS's resolver is only used by, and only required for, typechecking.
         * This is separate from node's resolver, which we hook separately and which
         * does not require this mapping.
         */
        tsResolverEquivalents,
        /**
         * Extensions that we can support if the user upgrades their typescript version.
         * Used when raising hints.
         */
        requiresHigherTypescriptVersion,
        /**
         * --experimental-specifier-resolution=node will add these extensions.
         */
        experimentalSpecifierResolutionAddsIfOmitted,
        /**
         * ESM loader will add these extensions to package.json "main" field
         */
        legacyMainResolveAddsIfOmitted,
        replacementsForMjs,
        replacementsForCjs,
        replacementsForJsx,
        replacementsForJs
      };
    }
    exports.getExtensions = getExtensions;
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/ts-transpile-module.js
var require_ts_transpile_module = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/ts-transpile-module.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTsTranspileModule = void 0;
    function createTsTranspileModule(ts, transpileOptions) {
      const { createProgram, createSourceFile, getDefaultCompilerOptions, getImpliedNodeFormatForFile, fixupCompilerOptions, transpileOptionValueCompilerOptions, getNewLineCharacter, fileExtensionIs, normalizePath, Debug, toPath, getSetExternalModuleIndicator, getEntries, addRange, hasProperty, getEmitScriptTarget, getDirectoryPath } = ts;
      const compilerOptionsDiagnostics = [];
      const options = transpileOptions.compilerOptions ? fixupCompilerOptions(transpileOptions.compilerOptions, compilerOptionsDiagnostics) : {};
      const defaultOptions2 = getDefaultCompilerOptions();
      for (const key in defaultOptions2) {
        if (hasProperty(defaultOptions2, key) && options[key] === void 0) {
          options[key] = defaultOptions2[key];
        }
      }
      for (const option of transpileOptionValueCompilerOptions) {
        options[option.name] = option.transpileOptionValue;
      }
      options.suppressOutputPathCheck = true;
      options.allowNonTsExtensions = true;
      const newLine = getNewLineCharacter(options);
      const compilerHost = {
        getSourceFile: (fileName) => fileName === normalizePath(inputFileName) ? sourceFile : void 0,
        writeFile: (name, text) => {
          if (fileExtensionIs(name, ".map")) {
            Debug.assertEqual(sourceMapText, void 0, "Unexpected multiple source map outputs, file:", name);
            sourceMapText = text;
          } else {
            Debug.assertEqual(outputText, void 0, "Unexpected multiple outputs, file:", name);
            outputText = text;
          }
        },
        getDefaultLibFileName: () => "lib.d.ts",
        useCaseSensitiveFileNames: () => true,
        getCanonicalFileName: (fileName) => fileName,
        getCurrentDirectory: () => "",
        getNewLine: () => newLine,
        fileExists: (fileName) => fileName === inputFileName || fileName === packageJsonFileName,
        readFile: (fileName) => fileName === packageJsonFileName ? `{"type": "${_packageJsonType}"}` : "",
        directoryExists: () => true,
        getDirectories: () => []
      };
      let inputFileName;
      let packageJsonFileName;
      let _packageJsonType;
      let sourceFile;
      let outputText;
      let sourceMapText;
      return transpileModule;
      function transpileModule(input, transpileOptions2, packageJsonType = "commonjs") {
        inputFileName = transpileOptions2.fileName || (transpileOptions.compilerOptions && transpileOptions.compilerOptions.jsx ? "module.tsx" : "module.ts");
        packageJsonFileName = getDirectoryPath(inputFileName) + "/package.json";
        _packageJsonType = packageJsonType;
        sourceFile = createSourceFile(inputFileName, input, {
          languageVersion: getEmitScriptTarget(options),
          impliedNodeFormat: getImpliedNodeFormatForFile(
            toPath(inputFileName, "", compilerHost.getCanonicalFileName),
            /*cache*/
            void 0,
            compilerHost,
            options
          ),
          setExternalModuleIndicator: getSetExternalModuleIndicator(options)
        });
        if (transpileOptions2.moduleName) {
          sourceFile.moduleName = transpileOptions2.moduleName;
        }
        if (transpileOptions2.renamedDependencies) {
          sourceFile.renamedDependencies = new Map(getEntries(transpileOptions2.renamedDependencies));
        }
        outputText = void 0;
        sourceMapText = void 0;
        const program = createProgram([inputFileName], options, compilerHost);
        const diagnostics = compilerOptionsDiagnostics.slice();
        if (transpileOptions.reportDiagnostics) {
          addRange(
            /*to*/
            diagnostics,
            /*from*/
            program.getSyntacticDiagnostics(sourceFile)
          );
          addRange(
            /*to*/
            diagnostics,
            /*from*/
            program.getOptionsDiagnostics()
          );
        }
        program.emit(
          /*targetSourceFile*/
          void 0,
          /*writeFile*/
          void 0,
          /*cancellationToken*/
          void 0,
          /*emitOnlyDtsFiles*/
          void 0,
          transpileOptions.transformers
        );
        if (outputText === void 0)
          return Debug.fail("Output generation failed");
        return { outputText, diagnostics, sourceMapText };
      }
    }
    exports.createTsTranspileModule = createTsTranspileModule;
  }
});

// browser-external:repl
var require_repl = __commonJS({
  "browser-external:repl"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "repl" has been externalized for browser compatibility. Cannot access "repl.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/console@0.7.2/node_modules/console/es/index.js
var es_exports = {};
__export(es_exports, {
  default: () => es_default
});
var method, noop, methods, length, es_default;
var init_es = __esm({
  "node_modules/.pnpm/console@0.7.2/node_modules/console/es/index.js"() {
    method = void 0;
    noop = function noop2() {
    };
    methods = ["assert", "clear", "count", "debug", "dir", "dirxml", "error", "exception", "group", "groupCollapsed", "groupEnd", "info", "log", "markTimeline", "profile", "profileEnd", "table", "time", "timeEnd", "timeStamp", "trace", "warn"];
    length = methods.length;
    while (length--) {
      method = methods[length];
      if (!console[method]) {
        console[method] = noop;
      }
    }
    es_default = console;
  }
});

// node_modules/.pnpm/acorn@8.11.2/node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "node_modules/.pnpm/acorn@8.11.2/node_modules/acorn/dist/acorn.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
    })(exports, function(exports2) {
      "use strict";
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
      var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      function isInAstralSet(code, set4) {
        var pos = 65536;
        for (var i2 = 0; i2 < set4.length; i2 += 2) {
          pos += set4[i2];
          if (pos > code) {
            return false;
          }
          pos += set4[i2 + 1];
          if (pos >= code) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType2(label, conf) {
        if (conf === void 0)
          conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords = {};
      function kw(name, options) {
        if (options === void 0)
          options = {};
        options.keyword = name;
        return keywords[name] = new TokenType(name, options);
      }
      var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        // Punctuation token types.
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        // Keyword token types.
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        return code === 10 || code === 13 || code === 8232 || code === 8233;
      }
      function nextLineBreak(code, from, end) {
        if (end === void 0)
          end = code.length;
        for (var i2 = from; i2 < end; i2++) {
          var next = code.charCodeAt(i2);
          if (isNewLine(next)) {
            return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString4 = ref.toString;
      var hasOwn = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      };
      var isArray = Array.isArray || function(obj) {
        return toString4.call(obj) === "[object Array]";
      };
      var regexpCache = /* @__PURE__ */ Object.create(null);
      function wordsRegexp(words) {
        return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
      }
      function codePointToString(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position = function Position2(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
      };
      var SourceLocation = function SourceLocation2(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak(input, cur, offset);
          if (nextBreak < 0) {
            return new Position(line, offset - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions2 = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions2) {
          options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions2[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start,
            end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [start, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser2(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$1.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser.prototype.parse = function parse4() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.canAwait.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
            return false;
          }
          if (scope.flags & SCOPE_FUNCTION) {
            return (scope.flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
      };
      prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i2 = 0; i2 < plugins.length; i2++) {
          cls = plugins[i2](cls);
        }
        return cls;
      };
      Parser.parse = function parse4(input, options) {
        return new this(options, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt2(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser.tokenizer = function tokenizer2(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp$9 = Parser.prototype;
      var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match3 = literal.exec(this.input.slice(start));
          if (!match3) {
            return false;
          }
          if ((match3[1] || match3[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match3[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match3[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$9.eat = function(type3) {
        if (this.type === type3) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$9.isContextual = function(name) {
        return this.type === types$1.name && this.value === name && !this.containsEsc;
      };
      pp$9.eatContextual = function(name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$9.expectContextual = function(name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$9.expect = function(type3) {
        this.eat(type3) || this.unexpected();
      };
      pp$9.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors = function DestructuringErrors2() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$8 = Parser.prototype;
      pp$8.parseTopLevel = function(node) {
        var exports3 = /* @__PURE__ */ Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types$1.eof) {
          var stmt = this.parseStatement(null, true, exports3);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
            var name = list2[i2];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$8.parseStatement = function(context, topLevel, exports3) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
          case types$1._break:
          case types$1._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types$1._debugger:
            return this.parseDebuggerStatement(node);
          case types$1._do:
            return this.parseDoStatement(node);
          case types$1._for:
            return this.parseForStatement(node);
          case types$1._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node, false, !context);
          case types$1._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node, true);
          case types$1._if:
            return this.parseIfStatement(node);
          case types$1._return:
            return this.parseReturnStatement(node);
          case types$1._switch:
            return this.parseSwitchStatement(node);
          case types$1._throw:
            return this.parseThrowStatement(node);
          case types$1._try:
            return this.parseTryStatement(node);
          case types$1._const:
          case types$1._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node, kind);
          case types$1._while:
            return this.parseWhileStatement(node);
          case types$1._with:
            return this.parseWithStatement(node);
          case types$1.braceL:
            return this.parseBlock(true, node);
          case types$1.semi:
            return this.parseEmptyStatement(node);
          case types$1._export:
          case types$1._import:
            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports3);
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node, expr);
            }
        }
      };
      pp$8.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types$1.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i2 = 0;
        for (; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i2 === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$8.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$8.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$1.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$8.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types$1._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var refDestructuringErrors = new DestructuringErrors();
        var init2 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init2, false, refDestructuringErrors);
          this.checkLValPattern(init2);
          return this.parseForIn(node, init2);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init2);
      };
      pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$8.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$8.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$8.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$1.braceR; ) {
          if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$1.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$8.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty$1 = [];
      pp$8.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
      };
      pp$8.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$1.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$8.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$8.parseWithStatement = function(node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$8.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
          var label = list2[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$8.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0)
          createNewLexicalScope = true;
        if (node === void 0)
          node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$8.parseFor = function(node, init2) {
        node.init = init2;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$8.parseForIn = function(node, init2) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
          this.raise(
            init2.start,
            (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
          );
        }
        node.left = init2;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$1.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$1.comma)) {
            break;
          }
        }
        return node;
      };
      pp$8.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types$1.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$8.parseFunctionParams = function(node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$8.parseClass = function(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while (this.type !== types$1.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types$1.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
      };
      pp$8.parseClassElementName = function(element) {
        if (this.type === types$1.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$8.parseClassMethod = function(method2, isGenerator, isAsync, allowsDirectSuper) {
        var key = method2.key;
        if (method2.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method2.static && checkKeyName(method2, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value2 = method2.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method2.kind === "get" && value2.params.length !== 0) {
          this.raiseRecoverable(value2.start, "getter should have no params");
        }
        if (method2.kind === "set" && value2.params.length !== 1) {
          this.raiseRecoverable(value2.start, "setter should have exactly one param");
        }
        if (method2.kind === "set" && value2.params[0].type === "RestElement") {
          this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method2, "MethodDefinition");
      };
      pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$1.eq)) {
          var scope = this.currentThisScope();
          var inClassFieldInit = scope.inClassFieldInit;
          scope.inClassFieldInit = true;
          field.value = this.parseMaybeAssign();
          scope.inClassFieldInit = inClassFieldInit;
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$8.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$8.parseClassId = function(node, isStatement) {
        if (this.type === types$1.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$8.parseClassSuper = function(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$8.enterClassBody = function() {
        var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$8.exitClassBody = function() {
        var ref2 = this.privateNameStack.pop();
        var declared = ref2.declared;
        var used = ref2.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i2 = 0; i2 < used.length; ++i2) {
          var id = used[i2];
          if (!hasOwn(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
      }
      pp$8.parseExportAllDeclaration = function(node, exports3) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports3, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      };
      pp$8.parseExport = function(node, exports3) {
        this.next();
        if (this.eat(types$1.star)) {
          return this.parseExportAllDeclaration(node, exports3);
        }
        if (this.eat(types$1._default)) {
          this.checkExport(exports3, "default", this.lastTokStart);
          node.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseExportDeclaration(node);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports3, node.declaration.declarations);
          } else {
            this.checkExport(exports3, node.declaration.id, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports3);
          if (this.eatContextual("from")) {
            if (this.type !== types$1.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
          } else {
            for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
              var spec = list2[i2];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$8.parseExportDeclaration = function(node) {
        return this.parseStatement(null);
      };
      pp$8.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$8.checkExport = function(exports3, name, pos) {
        if (!exports3) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        if (hasOwn(exports3, name)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports3[name] = true;
      };
      pp$8.checkPatternExport = function(exports3, pat) {
        var type3 = pat.type;
        if (type3 === "Identifier") {
          this.checkExport(exports3, pat, pat.start);
        } else if (type3 === "ObjectPattern") {
          for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
            var prop3 = list2[i2];
            this.checkPatternExport(exports3, prop3);
          }
        } else if (type3 === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports3, elt);
            }
          }
        } else if (type3 === "Property") {
          this.checkPatternExport(exports3, pat.value);
        } else if (type3 === "AssignmentPattern") {
          this.checkPatternExport(exports3, pat.left);
        } else if (type3 === "RestElement") {
          this.checkPatternExport(exports3, pat.argument);
        }
      };
      pp$8.checkVariableExport = function(exports3, decls) {
        if (!exports3) {
          return;
        }
        for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
          var decl = list2[i2];
          this.checkPatternExport(exports3, decl.id);
        }
      };
      pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$8.parseExportSpecifier = function(exports3) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(
          exports3,
          node.exported,
          node.exported.start
        );
        return this.finishNode(node, "ExportSpecifier");
      };
      pp$8.parseExportSpecifiers = function(exports3) {
        var nodes = [], first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports3));
        }
        return nodes;
      };
      pp$8.parseImport = function(node) {
        this.next();
        if (this.type === types$1.string) {
          node.specifiers = empty$1;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$8.parseImportSpecifier = function() {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node.local = this.parseIdent();
        } else {
          this.checkUnreserved(node.imported);
          node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportSpecifier");
      };
      pp$8.parseImportDefaultSpecifier = function() {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportDefaultSpecifier");
      };
      pp$8.parseImportNamespaceSpecifier = function() {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportNamespaceSpecifier");
      };
      pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$1.comma)) {
            return nodes;
          }
        }
        if (this.type === types$1.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$8.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }
      };
      pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$7 = Parser.prototype;
      pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
              if (this.inAsync && node.name === "await") {
                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
                var prop3 = list2[i2];
                this.toAssignable(prop3, isBinding);
                if (prop3.type === "RestElement" && (prop3.argument.type === "ArrayPattern" || prop3.argument.type === "ObjectPattern")) {
                  this.raise(prop3.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node.kind !== "init") {
                this.raise(node.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern") {
                this.raise(node.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last2 = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last2 && last2.type === "RestElement" && last2.argument.type !== "Identifier") {
            this.unexpected(last2.argument.start);
          }
        }
        return exprList;
      };
      pp$7.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$7.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$1.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types$1.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");
            case types$1.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
          }
          if (allowEmpty && this.type === types$1.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$1.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$7.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$7.parseBindingListItem = function(param) {
        return param;
      };
      pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
              var prop3 = list2[i2];
              this.checkLValInnerPattern(prop3, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$6 = Parser.prototype;
      pp$6.initialContext = function() {
        return [types.b_stat];
      };
      pp$6.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) {
          return true;
        }
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
          return true;
        }
        if (prevType === types$1.braceL) {
          return parent === types.b_stat;
        }
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$6.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$6.updateContext = function(prevType) {
        var update3, type3 = this.type;
        if (type3.keyword && prevType === types$1.dot) {
          this.exprAllowed = false;
        } else if (update3 = type3.updateContext) {
          update3.call(this, prevType);
        } else {
          this.exprAllowed = type3.beforeExpr;
        }
      };
      pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
      };
      types$1.dollarBraceL.updateContext = function() {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
      };
      types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
      };
      types$1.incDec.updateContext = function() {
      };
      types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
          this.context.push(types.f_expr);
        } else {
          this.context.push(types.f_stat);
        }
        this.exprAllowed = false;
      };
      types$1.colon.updateContext = function() {
        if (this.curContext().token === "function") {
          this.context.pop();
        }
        this.exprAllowed = true;
      };
      types$1.backQuote.updateContext = function() {
        if (this.curContext() === types.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types.f_expr) {
            this.context[index] = types.f_expr_gen;
          } else {
            this.context[index] = types.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$5 = Parser.prototype;
      pp$5.checkPropClash = function(prop3, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop3.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop3.computed || prop3.method || prop3.shorthand)) {
          return;
        }
        var key = prop3.key;
        var name;
        switch (key.type) {
          case "Identifier":
            name = key.name;
            break;
          case "Literal":
            name = String(key.value);
            break;
          default:
            return;
        }
        var kind = prop3.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types$1.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$1.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$1.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types$1.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
            var coalesce = this.type === types$1.coalesce;
            if (coalesce) {
              prec = types$1.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update3 = this.type === types$1.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update3, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update3) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update3 ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$1._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$1.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
      }
      pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base = element;
        }
      };
      pp$5.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
      };
      pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types$1.bracketR);
          } else if (this.type === types$1.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$1.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$1._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node = this.startNode();
            this.next();
            if (this.type === types$1.parenL && !this.allowDirectSuper) {
              this.raise(node.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
              this.unexpected();
            }
            return this.finishNode(node, "Super");
          case types$1._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types$1.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
              this.overrideContext(types.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$1.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$1.regexp:
            var value2 = this.value;
            node = this.parseLiteral(value2.value);
            node.regex = { pattern: value2.pattern, flags: value2.flags };
            return node;
          case types$1.num:
          case types$1.string:
            return this.parseLiteral(this.value);
          case types$1._null:
          case types$1._true:
          case types$1._false:
            node = this.startNode();
            node.value = this.type === types$1._null ? null : this.type === types$1._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
          case types$1.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types$1.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
          case types$1.braceL:
            this.overrideContext(types.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$1._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
          case types$1._class:
            return this.parseClass(this.startNode(), false);
          case types$1._new:
            return this.parseNew();
          case types$1.backQuote:
            return this.parseTemplate();
          case types$1._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$5.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$5.parseExprImport = function(forNew) {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        var meta = this.parseIdent(true);
        if (this.type === types$1.parenL && !forNew) {
          return this.parseDynamicImport(node);
        } else if (this.type === types$1.dot) {
          node.meta = meta;
          return this.parseImportMeta(node);
        } else {
          this.unexpected();
        }
      };
      pp$5.parseDynamicImport = function(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          var errorPos = this.start;
          if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$5.parseImportMeta = function(node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$5.parseLiteral = function(value2) {
        var node = this.startNode();
        node.value = value2;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
      };
      pp$5.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$1.parenR) {
            first ? first = false : this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$1.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$1.comma) {
                this.raiseRecoverable(
                  this.start,
                  "Comma is not permitted after the rest element"
                );
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$1.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$5.parseParenItem = function(item) {
        return item;
      };
      pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty3 = [];
      pp$5.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.startLoc);
          meta.name = "new";
          node.meta = this.finishNode(meta, "Identifier");
          this.next();
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) {
          node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty3;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$5.parseTemplateElement = function(ref2) {
        var isTagged = ref2.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$5.parseTemplate = function(ref2) {
        if (ref2 === void 0)
          ref2 = {};
        var isTagged = ref2.isTagged;
        if (isTagged === void 0)
          isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$1.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$1.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types$1.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$5.isAsyncProp = function(prop3) {
        return !prop3.computed && prop3.key.type === "Identifier" && prop3.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop3 = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop3, propHash, refDestructuringErrors);
          }
          node.properties.push(prop3);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop3 = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
          if (isPattern) {
            prop3.argument = this.parseIdent(false);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop3, "RestElement");
          }
          prop3.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop3, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop3.method = false;
          prop3.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$1.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop3);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop3)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
          this.parsePropertyName(prop3);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop3, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop3, "Property");
      };
      pp$5.parseGetterSetter = function(prop3) {
        prop3.kind = prop3.key.name;
        this.parsePropertyName(prop3);
        prop3.value = this.parseMethod(false);
        var paramCount = prop3.kind === "get" ? 0 : 1;
        if (prop3.value.params.length !== paramCount) {
          var start = prop3.value.start;
          if (prop3.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop3.kind === "set" && prop3.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop3.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$5.parsePropertyValue = function(prop3, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) {
          this.unexpected();
        }
        if (this.eat(types$1.colon)) {
          prop3.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop3.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop3.kind = "init";
          prop3.method = true;
          prop3.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop3.computed && prop3.key.type === "Identifier" && (prop3.key.name === "get" || prop3.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop3);
        } else if (this.options.ecmaVersion >= 6 && !prop3.computed && prop3.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop3.key);
          if (prop3.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop3.kind = "init";
          if (isPattern) {
            prop3.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop3.key));
          } else if (this.type === types$1.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop3.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop3.key));
          } else {
            prop3.value = this.copyNode(prop3.key);
          }
          prop3.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$5.parsePropertyName = function(prop3) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$1.bracketL)) {
            prop3.computed = true;
            prop3.key = this.parseMaybeAssign();
            this.expect(types$1.bracketR);
            return prop3.key;
          } else {
            prop3.computed = false;
          }
        }
        return prop3.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$5.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$5.isSimpleParamList = function(params) {
        for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$5.checkParams = function(node, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$1.comma) {
            elt = null;
          } else if (this.type === types$1.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$5.checkUnreserved = function(ref2) {
        var start = ref2.start;
        var end = ref2.end;
        var name = ref2.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.currentThisScope().inClassFieldInit && name === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
          this.raise(start, "Cannot use " + name + " in class static initialization block");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$5.parseIdent = function(liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$5.parseIdentNode = function() {
        var node = this.startNode();
        if (this.type === types$1.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
          this.type = types$1.name;
        } else {
          this.unexpected();
        }
        return node;
      };
      pp$5.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$1.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
          }
        }
        return node;
      };
      pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types$1.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$4 = Parser.prototype;
      pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function() {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$3 = Parser.prototype;
      var Scope = function Scope2(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
        this.inClassFieldInit = false;
      };
      pp$3.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$3.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$3.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$3.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$3.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & SCOPE_VAR) {
            return scope;
          }
        }
      };
      pp$3.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node4 = function Node5(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$2 = Parser.prototype;
      pp$2.startNode = function() {
        return new Node4(this, this.start, this.startLoc);
      };
      pp$2.startNodeAt = function(pos, loc) {
        return new Node4(this, pos, loc);
      };
      function finishNodeAt(node, type3, pos, loc) {
        node.type = type3;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$2.finishNode = function(node, type3) {
        return finishNodeAt.call(this, node, type3, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$2.finishNodeAt = function(node, type3, pos, loc) {
        return finishNodeAt.call(this, node, type3, pos, loc);
      };
      pp$2.copyNode = function(node) {
        var newNode = new Node4(this, node.start, this.startLoc);
        for (var prop3 in node) {
          newNode[prop3] = node[prop3];
        }
        return newNode;
      };
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties = ecma12BinaryProperties;
      var ecma14BinaryProperties = ecma13BinaryProperties;
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
      };
      var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion2) {
        var d = data[ecmaVersion2] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
          binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
        var ecmaVersion = list[i];
        buildUnicodeData(ecmaVersion);
      }
      var pp$1 = Parser.prototype;
      var RegExpValidationState = function RegExpValidationState2(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return -1;
        }
        var c = s.charCodeAt(i2);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return l;
        }
        var c = s.charCodeAt(i2), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
          return i2 + 1;
        }
        return i2 + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0)
          forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0)
          forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0)
          forceU = false;
        var pos = this.pos;
        for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
          var ch = list2[i2];
          var current = this.at(pos, forceU);
          if (current === -1 || current !== ch) {
            return false;
          }
          pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
      };
      pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for (var i2 = 0; i2 < flags.length; i2++) {
          var flag = flags.charAt(i2);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i2 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u = true;
          }
          if (flag === "v") {
            v = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(
            41
            /* ) */
          )) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(
            93
            /* ] */
          ) || state.eat(
            125
            /* } */
          )) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
          var name = list2[i2];
          if (state.groupNames.indexOf(name) === -1) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$1.regexp_disjunction = function(state) {
        this.regexp_alternative(state);
        while (state.eat(
          124
          /* | */
        )) {
          this.regexp_alternative(state);
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(
          123
          /* { */
        )) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$1.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(
          94
          /* ^ */
        ) || state.eat(
          36
          /* $ */
        )) {
          return true;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          if (state.eat(
            66
            /* B */
          ) || state.eat(
            98
            /* b */
          )) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(
          40
          /* ( */
        ) && state.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(
              60
              /* < */
            );
          }
          if (state.eat(
            61
            /* = */
          ) || state.eat(
            33
            /* ! */
          )) {
            this.regexp_disjunction(state);
            if (!state.eat(
              41
              /* ) */
            )) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0)
          noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(
            63
            /* ? */
          );
          return true;
        }
        return false;
      };
      pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(
          42
          /* * */
        ) || state.eat(
          43
          /* + */
        ) || state.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(
          123
          /* { */
        )) {
          var min3 = 0, max3 = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min3 = state.lastIntValue;
            if (state.eat(
              44
              /* , */
            ) && this.regexp_eatDecimalDigits(state)) {
              max3 = state.lastIntValue;
            }
            if (state.eat(
              125
              /* } */
            )) {
              if (max3 !== -1 && max3 < min3 && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(
          40
          /* ( */
        )) {
          if (state.eat(
            63
            /* ? */
          ) && state.eat(
            58
            /* : */
          )) {
            this.regexp_disjunction(state);
            if (state.eat(
              41
              /* ) */
            )) {
              return true;
            }
            state.raise("Unterminated group");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(
          63
          /* ? */
        )) {
          if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
              state.raise("Duplicate capture group name");
            }
            state.groupNames.push(state.lastStringValue);
            return;
          }
          state.raise("Invalid group");
        }
      };
      pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
            62
            /* > */
          )) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0)
          forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(
                92
                /* \ */
              ) && state.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state) && state.eat(
            125
            /* } */
          ) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(
            47
            /* / */
          )) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone = 0;
      var CharSetOk = 1;
      var CharSetString = 2;
      pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk;
        }
        var negate3 = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate3 = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(
            123
            /* { */
          ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
            125
            /* } */
          )) {
            if (negate3 && result === CharSetString) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(
          61
          /* = */
        )) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value2 = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value2);
            return CharSetOk;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
      };
      pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value2) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value2)) {
          state.raise("Invalid property value");
        }
      };
      pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString;
        }
        state.raise("Invalid property name");
      };
      pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(
          91
          /* [ */
        )) {
          var negate3 = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (!state.eat(
            93
            /* ] */
          )) {
            state.raise("Unterminated character class");
          }
          if (negate3 && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_classContents = function(state) {
        if (state.current() === 93) {
          return CharSetOk;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
      };
      pp$1.regexp_nonEmptyClassRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          98
          /* b */
        )) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(
          45
          /* - */
        )) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$1.regexp_classSetExpression = function(state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state))
          ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString) {
            result = CharSetString;
          }
          var start = state.pos;
          while (state.eatChars(
            [38, 38]
            /* && */
          )) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString) {
                result = CharSetOk;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
          while (state.eatChars(
            [45, 45]
            /* -- */
          )) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString) {
            result = CharSetString;
          }
        }
      };
      pp$1.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$1.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(
          91
          /* [ */
        )) {
          var negate3 = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (state.eat(
            93
            /* ] */
          )) {
            if (negate3 && result === CharSetString) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (state.eat(
            123
            /* { */
          )) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(
              125
              /* } */
            )) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (this.regexp_classString(state) === CharSetString) {
            result = CharSetString;
          }
        }
        return result;
      };
      pp$1.regexp_classString = function(state) {
        var count = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count++;
        }
        return count === 1 ? CharSetOk : CharSetString;
      };
      pp$1.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(
            98
            /* b */
          )) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$1.regexp_eatFixedHexDigits = function(state, length4) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i2 = 0; i2 < length4; ++i2) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token2(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp = Parser.prototype;
      pp.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp.getToken = function() {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$1.eof,
                value: token
              };
            }
          };
        };
      }
      pp.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$1.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp.readToken = function(code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start + 2, end),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(
            false,
            this.input.slice(start + startSkip, this.pos),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipSpace = function() {
        loop:
          while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.pos + 1) === 10) {
                  ++this.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.pos;
                if (this.options.locations) {
                  ++this.curLine;
                  this.lineStart = this.pos;
                }
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break loop;
                }
                break;
              default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                  ++this.pos;
                } else {
                  break loop;
                }
            }
          }
      };
      pp.finishToken = function(type3, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type3;
        this.value = val;
        this.updateContext(prevType);
      };
      pp.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$1.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$1.dot);
        }
      };
      pp.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.slash, 1);
      };
      pp.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types$1.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
      };
      pp.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.bitwiseXOR, 1);
      };
      pp.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.plusMin, 1);
      };
      pp.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$1.relational, size);
      };
      pp.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
      };
      pp.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$1.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(types$1.coalesce, 2);
          }
        }
        return this.finishOp(types$1.question, 1);
      };
      pp.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart(code, true) || code === 92) {
            return this.finishToken(types$1.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.getTokenFromCode = function(code) {
        switch (code) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++this.pos;
            return this.finishToken(types$1.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$1.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$1.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$1.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$1.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$1.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$1.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$1.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$1.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$1.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.finishOp = function(type3, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type3, str);
      };
      pp.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value2 = null;
        try {
          value2 = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types$1.regexp, { pattern, flags, value: value2 });
      };
      pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i2 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val);
      };
      pp.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
      };
      pp.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      pp.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$1.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$1.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$1.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            case "`":
              return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return codePointToString(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(
                this.pos - 1,
                "Invalid escape sequence"
              );
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp.readWord = function() {
        var word = this.readWord1();
        var type3 = types$1.name;
        if (this.keywords.test(word)) {
          type3 = keywords[word];
        }
        return this.finishToken(type3, word);
      };
      var version = "8.11.2";
      Parser.acorn = {
        Parser,
        version,
        defaultOptions: defaultOptions2,
        Position,
        SourceLocation,
        getLineInfo,
        Node: Node4,
        TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext,
        tokContexts: types,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse3(input, options) {
        return Parser.parse(input, options);
      }
      function parseExpressionAt(input, pos, options) {
        return Parser.parseExpressionAt(input, pos, options);
      }
      function tokenizer(input, options) {
        return Parser.tokenizer(input, options);
      }
      exports2.Node = Node4;
      exports2.Parser = Parser;
      exports2.Position = Position;
      exports2.SourceLocation = SourceLocation;
      exports2.TokContext = TokContext;
      exports2.Token = Token;
      exports2.TokenType = TokenType;
      exports2.defaultOptions = defaultOptions2;
      exports2.getLineInfo = getLineInfo;
      exports2.isIdentifierChar = isIdentifierChar;
      exports2.isIdentifierStart = isIdentifierStart;
      exports2.isNewLine = isNewLine;
      exports2.keywordTypes = keywords;
      exports2.lineBreak = lineBreak;
      exports2.lineBreakG = lineBreakG;
      exports2.nonASCIIwhitespace = nonASCIIwhitespace;
      exports2.parse = parse3;
      exports2.parseExpressionAt = parseExpressionAt;
      exports2.tokContexts = types;
      exports2.tokTypes = types$1;
      exports2.tokenizer = tokenizer;
      exports2.version = version;
    });
  }
});

// node_modules/.pnpm/acorn-walk@8.3.0/node_modules/acorn-walk/dist/walk.js
var require_walk = __commonJS({
  "node_modules/.pnpm/acorn-walk@8.3.0/node_modules/acorn-walk/dist/walk.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory((global2.acorn = global2.acorn || {}, global2.acorn.walk = {})));
    })(exports, function(exports2) {
      "use strict";
      function simple(node, visitors, baseVisitor, state, override) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        (function c(node2, st, override2) {
          var type3 = override2 || node2.type, found = visitors[type3];
          baseVisitor[type3](node2, st, c);
          if (found) {
            found(node2, st);
          }
        })(node, state, override);
      }
      function ancestor(node, visitors, baseVisitor, state, override) {
        var ancestors = [];
        if (!baseVisitor) {
          baseVisitor = base;
        }
        (function c(node2, st, override2) {
          var type3 = override2 || node2.type, found = visitors[type3];
          var isNew = node2 !== ancestors[ancestors.length - 1];
          if (isNew) {
            ancestors.push(node2);
          }
          baseVisitor[type3](node2, st, c);
          if (found) {
            found(node2, st || ancestors, ancestors);
          }
          if (isNew) {
            ancestors.pop();
          }
        })(node, state, override);
      }
      function recursive(node, state, funcs, baseVisitor, override) {
        var visitor = funcs ? make(funcs, baseVisitor || void 0) : baseVisitor;
        (function c(node2, st, override2) {
          visitor[override2 || node2.type](node2, st, c);
        })(node, state, override);
      }
      function makeTest(test3) {
        if (typeof test3 === "string") {
          return function(type3) {
            return type3 === test3;
          };
        } else if (!test3) {
          return function() {
            return true;
          };
        } else {
          return test3;
        }
      }
      var Found = function Found2(node, state) {
        this.node = node;
        this.state = state;
      };
      function full(node, callback, baseVisitor, state, override) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var last2;
        (function c(node2, st, override2) {
          var type3 = override2 || node2.type;
          baseVisitor[type3](node2, st, c);
          if (last2 !== node2) {
            callback(node2, st, type3);
            last2 = node2;
          }
        })(node, state, override);
      }
      function fullAncestor(node, callback, baseVisitor, state) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var ancestors = [], last2;
        (function c(node2, st, override) {
          var type3 = override || node2.type;
          var isNew = node2 !== ancestors[ancestors.length - 1];
          if (isNew) {
            ancestors.push(node2);
          }
          baseVisitor[type3](node2, st, c);
          if (last2 !== node2) {
            callback(node2, st || ancestors, ancestors, type3);
            last2 = node2;
          }
          if (isNew) {
            ancestors.pop();
          }
        })(node, state);
      }
      function findNodeAt(node, start, end, test3, baseVisitor, state) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        test3 = makeTest(test3);
        try {
          (function c(node2, st, override) {
            var type3 = override || node2.type;
            if ((start == null || node2.start <= start) && (end == null || node2.end >= end)) {
              baseVisitor[type3](node2, st, c);
            }
            if ((start == null || node2.start === start) && (end == null || node2.end === end) && test3(type3, node2)) {
              throw new Found(node2, st);
            }
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeAround(node, pos, test3, baseVisitor, state) {
        test3 = makeTest(test3);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        try {
          (function c(node2, st, override) {
            var type3 = override || node2.type;
            if (node2.start > pos || node2.end < pos) {
              return;
            }
            baseVisitor[type3](node2, st, c);
            if (test3(type3, node2)) {
              throw new Found(node2, st);
            }
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeAfter(node, pos, test3, baseVisitor, state) {
        test3 = makeTest(test3);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        try {
          (function c(node2, st, override) {
            if (node2.end < pos) {
              return;
            }
            var type3 = override || node2.type;
            if (node2.start >= pos && test3(type3, node2)) {
              throw new Found(node2, st);
            }
            baseVisitor[type3](node2, st, c);
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeBefore(node, pos, test3, baseVisitor, state) {
        test3 = makeTest(test3);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var max3;
        (function c(node2, st, override) {
          if (node2.start > pos) {
            return;
          }
          var type3 = override || node2.type;
          if (node2.end <= pos && (!max3 || max3.node.end < node2.end) && test3(type3, node2)) {
            max3 = new Found(node2, st);
          }
          baseVisitor[type3](node2, st, c);
        })(node, state);
        return max3;
      }
      function make(funcs, baseVisitor) {
        var visitor = Object.create(baseVisitor || base);
        for (var type3 in funcs) {
          visitor[type3] = funcs[type3];
        }
        return visitor;
      }
      function skipThrough(node, st, c) {
        c(node, st);
      }
      function ignore(_node, _st, _c) {
      }
      var base = {};
      base.Program = base.BlockStatement = base.StaticBlock = function(node, st, c) {
        for (var i = 0, list = node.body; i < list.length; i += 1) {
          var stmt = list[i];
          c(stmt, st, "Statement");
        }
      };
      base.Statement = skipThrough;
      base.EmptyStatement = ignore;
      base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c) {
        return c(node.expression, st, "Expression");
      };
      base.IfStatement = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Statement");
        if (node.alternate) {
          c(node.alternate, st, "Statement");
        }
      };
      base.LabeledStatement = function(node, st, c) {
        return c(node.body, st, "Statement");
      };
      base.BreakStatement = base.ContinueStatement = ignore;
      base.WithStatement = function(node, st, c) {
        c(node.object, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.SwitchStatement = function(node, st, c) {
        c(node.discriminant, st, "Expression");
        for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
          var cs = list$1[i$1];
          if (cs.test) {
            c(cs.test, st, "Expression");
          }
          for (var i = 0, list = cs.consequent; i < list.length; i += 1) {
            var cons = list[i];
            c(cons, st, "Statement");
          }
        }
      };
      base.SwitchCase = function(node, st, c) {
        if (node.test) {
          c(node.test, st, "Expression");
        }
        for (var i = 0, list = node.consequent; i < list.length; i += 1) {
          var cons = list[i];
          c(cons, st, "Statement");
        }
      };
      base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c) {
        if (node.argument) {
          c(node.argument, st, "Expression");
        }
      };
      base.ThrowStatement = base.SpreadElement = function(node, st, c) {
        return c(node.argument, st, "Expression");
      };
      base.TryStatement = function(node, st, c) {
        c(node.block, st, "Statement");
        if (node.handler) {
          c(node.handler, st);
        }
        if (node.finalizer) {
          c(node.finalizer, st, "Statement");
        }
      };
      base.CatchClause = function(node, st, c) {
        if (node.param) {
          c(node.param, st, "Pattern");
        }
        c(node.body, st, "Statement");
      };
      base.WhileStatement = base.DoWhileStatement = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.ForStatement = function(node, st, c) {
        if (node.init) {
          c(node.init, st, "ForInit");
        }
        if (node.test) {
          c(node.test, st, "Expression");
        }
        if (node.update) {
          c(node.update, st, "Expression");
        }
        c(node.body, st, "Statement");
      };
      base.ForInStatement = base.ForOfStatement = function(node, st, c) {
        c(node.left, st, "ForInit");
        c(node.right, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.ForInit = function(node, st, c) {
        if (node.type === "VariableDeclaration") {
          c(node, st);
        } else {
          c(node, st, "Expression");
        }
      };
      base.DebuggerStatement = ignore;
      base.FunctionDeclaration = function(node, st, c) {
        return c(node, st, "Function");
      };
      base.VariableDeclaration = function(node, st, c) {
        for (var i = 0, list = node.declarations; i < list.length; i += 1) {
          var decl = list[i];
          c(decl, st);
        }
      };
      base.VariableDeclarator = function(node, st, c) {
        c(node.id, st, "Pattern");
        if (node.init) {
          c(node.init, st, "Expression");
        }
      };
      base.Function = function(node, st, c) {
        if (node.id) {
          c(node.id, st, "Pattern");
        }
        for (var i = 0, list = node.params; i < list.length; i += 1) {
          var param = list[i];
          c(param, st, "Pattern");
        }
        c(node.body, st, node.expression ? "Expression" : "Statement");
      };
      base.Pattern = function(node, st, c) {
        if (node.type === "Identifier") {
          c(node, st, "VariablePattern");
        } else if (node.type === "MemberExpression") {
          c(node, st, "MemberPattern");
        } else {
          c(node, st);
        }
      };
      base.VariablePattern = ignore;
      base.MemberPattern = skipThrough;
      base.RestElement = function(node, st, c) {
        return c(node.argument, st, "Pattern");
      };
      base.ArrayPattern = function(node, st, c) {
        for (var i = 0, list = node.elements; i < list.length; i += 1) {
          var elt = list[i];
          if (elt) {
            c(elt, st, "Pattern");
          }
        }
      };
      base.ObjectPattern = function(node, st, c) {
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop3 = list[i];
          if (prop3.type === "Property") {
            if (prop3.computed) {
              c(prop3.key, st, "Expression");
            }
            c(prop3.value, st, "Pattern");
          } else if (prop3.type === "RestElement") {
            c(prop3.argument, st, "Pattern");
          }
        }
      };
      base.Expression = skipThrough;
      base.ThisExpression = base.Super = base.MetaProperty = ignore;
      base.ArrayExpression = function(node, st, c) {
        for (var i = 0, list = node.elements; i < list.length; i += 1) {
          var elt = list[i];
          if (elt) {
            c(elt, st, "Expression");
          }
        }
      };
      base.ObjectExpression = function(node, st, c) {
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop3 = list[i];
          c(prop3, st);
        }
      };
      base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
      base.SequenceExpression = function(node, st, c) {
        for (var i = 0, list = node.expressions; i < list.length; i += 1) {
          var expr = list[i];
          c(expr, st, "Expression");
        }
      };
      base.TemplateLiteral = function(node, st, c) {
        for (var i = 0, list = node.quasis; i < list.length; i += 1) {
          var quasi = list[i];
          c(quasi, st);
        }
        for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
          var expr = list$1[i$1];
          c(expr, st, "Expression");
        }
      };
      base.TemplateElement = ignore;
      base.UnaryExpression = base.UpdateExpression = function(node, st, c) {
        c(node.argument, st, "Expression");
      };
      base.BinaryExpression = base.LogicalExpression = function(node, st, c) {
        c(node.left, st, "Expression");
        c(node.right, st, "Expression");
      };
      base.AssignmentExpression = base.AssignmentPattern = function(node, st, c) {
        c(node.left, st, "Pattern");
        c(node.right, st, "Expression");
      };
      base.ConditionalExpression = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Expression");
        c(node.alternate, st, "Expression");
      };
      base.NewExpression = base.CallExpression = function(node, st, c) {
        c(node.callee, st, "Expression");
        if (node.arguments) {
          for (var i = 0, list = node.arguments; i < list.length; i += 1) {
            var arg = list[i];
            c(arg, st, "Expression");
          }
        }
      };
      base.MemberExpression = function(node, st, c) {
        c(node.object, st, "Expression");
        if (node.computed) {
          c(node.property, st, "Expression");
        }
      };
      base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c) {
        if (node.declaration) {
          c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
        }
        if (node.source) {
          c(node.source, st, "Expression");
        }
      };
      base.ExportAllDeclaration = function(node, st, c) {
        if (node.exported) {
          c(node.exported, st);
        }
        c(node.source, st, "Expression");
      };
      base.ImportDeclaration = function(node, st, c) {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          var spec = list[i];
          c(spec, st);
        }
        c(node.source, st, "Expression");
      };
      base.ImportExpression = function(node, st, c) {
        c(node.source, st, "Expression");
      };
      base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
      base.TaggedTemplateExpression = function(node, st, c) {
        c(node.tag, st, "Expression");
        c(node.quasi, st, "Expression");
      };
      base.ClassDeclaration = base.ClassExpression = function(node, st, c) {
        return c(node, st, "Class");
      };
      base.Class = function(node, st, c) {
        if (node.id) {
          c(node.id, st, "Pattern");
        }
        if (node.superClass) {
          c(node.superClass, st, "Expression");
        }
        c(node.body, st);
      };
      base.ClassBody = function(node, st, c) {
        for (var i = 0, list = node.body; i < list.length; i += 1) {
          var elt = list[i];
          c(elt, st);
        }
      };
      base.MethodDefinition = base.PropertyDefinition = base.Property = function(node, st, c) {
        if (node.computed) {
          c(node.key, st, "Expression");
        }
        if (node.value) {
          c(node.value, st, "Expression");
        }
      };
      exports2.ancestor = ancestor;
      exports2.base = base;
      exports2.findNodeAfter = findNodeAfter;
      exports2.findNodeAround = findNodeAround;
      exports2.findNodeAt = findNodeAt;
      exports2.findNodeBefore = findNodeBefore;
      exports2.full = full;
      exports2.fullAncestor = fullAncestor;
      exports2.make = make;
      exports2.recursive = recursive;
      exports2.simple = simple;
    });
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-repl-await.js
var require_node_internal_repl_await = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-repl-await.js"(exports, module) {
    "use strict";
    var {
      ArrayFrom,
      ArrayPrototypeForEach,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypePop,
      ArrayPrototypePush,
      FunctionPrototype,
      ObjectKeys,
      RegExpPrototypeSymbolReplace,
      StringPrototypeEndsWith,
      StringPrototypeIncludes,
      StringPrototypeIndexOf,
      StringPrototypeRepeat,
      StringPrototypeSplit,
      StringPrototypeStartsWith,
      SyntaxError: SyntaxError2
    } = require_node_primordials();
    var parser = require_acorn().Parser;
    var walk = require_walk();
    var { Recoverable } = require_repl();
    function isTopLevelDeclaration(state) {
      return state.ancestors[state.ancestors.length - 2] === state.body;
    }
    var noop3 = FunctionPrototype;
    var visitorsWithoutAncestors = {
      ClassDeclaration(node, state, c) {
        if (isTopLevelDeclaration(state)) {
          state.prepend(node, `${node.id.name}=`);
          ArrayPrototypePush(
            state.hoistedDeclarationStatements,
            `let ${node.id.name}; `
          );
        }
        walk.base.ClassDeclaration(node, state, c);
      },
      ForOfStatement(node, state, c) {
        if (node.await === true) {
          state.containsAwait = true;
        }
        walk.base.ForOfStatement(node, state, c);
      },
      FunctionDeclaration(node, state, c) {
        state.prepend(node, `${node.id.name}=`);
        ArrayPrototypePush(
          state.hoistedDeclarationStatements,
          `var ${node.id.name}; `
        );
      },
      FunctionExpression: noop3,
      ArrowFunctionExpression: noop3,
      MethodDefinition: noop3,
      AwaitExpression(node, state, c) {
        state.containsAwait = true;
        walk.base.AwaitExpression(node, state, c);
      },
      ReturnStatement(node, state, c) {
        state.containsReturn = true;
        walk.base.ReturnStatement(node, state, c);
      },
      VariableDeclaration(node, state, c) {
        const variableKind = node.kind;
        const isIterableForDeclaration = ArrayPrototypeIncludes(
          ["ForOfStatement", "ForInStatement"],
          state.ancestors[state.ancestors.length - 2].type
        );
        if (variableKind === "var" || isTopLevelDeclaration(state)) {
          let registerVariableDeclarationIdentifiers = function(node2) {
            switch (node2.type) {
              case "Identifier":
                ArrayPrototypePush(
                  variableIdentifiersToHoist[variableKind === "var" ? 0 : 1][1],
                  node2.name
                );
                break;
              case "ObjectPattern":
                ArrayPrototypeForEach(node2.properties, (property) => {
                  registerVariableDeclarationIdentifiers(property.value);
                });
                break;
              case "ArrayPattern":
                ArrayPrototypeForEach(node2.elements, (element) => {
                  registerVariableDeclarationIdentifiers(element);
                });
                break;
            }
          };
          state.replace(
            node.start,
            node.start + variableKind.length + (isIterableForDeclaration ? 1 : 0),
            variableKind === "var" && isIterableForDeclaration ? "" : "void" + (node.declarations.length === 1 ? "" : " (")
          );
          if (!isIterableForDeclaration) {
            ArrayPrototypeForEach(node.declarations, (decl) => {
              state.prepend(decl, "(");
              state.append(decl, decl.init ? ")" : "=undefined)");
            });
            if (node.declarations.length !== 1) {
              state.append(node.declarations[node.declarations.length - 1], ")");
            }
          }
          const variableIdentifiersToHoist = [
            ["var", []],
            ["let", []]
          ];
          ArrayPrototypeForEach(node.declarations, (decl) => {
            registerVariableDeclarationIdentifiers(decl.id);
          });
          ArrayPrototypeForEach(
            variableIdentifiersToHoist,
            ({ 0: kind, 1: identifiers }) => {
              if (identifiers.length > 0) {
                ArrayPrototypePush(
                  state.hoistedDeclarationStatements,
                  `${kind} ${ArrayPrototypeJoin(identifiers, ", ")}; `
                );
              }
            }
          );
        }
        walk.base.VariableDeclaration(node, state, c);
      }
    };
    var visitors = {};
    for (const nodeType of ObjectKeys(walk.base)) {
      const callback = visitorsWithoutAncestors[nodeType] || walk.base[nodeType];
      visitors[nodeType] = (node, state, c) => {
        const isNew = node !== state.ancestors[state.ancestors.length - 1];
        if (isNew) {
          ArrayPrototypePush(state.ancestors, node);
        }
        callback(node, state, c);
        if (isNew) {
          ArrayPrototypePop(state.ancestors);
        }
      };
    }
    function processTopLevelAwait(src) {
      const wrapPrefix = "(async () => { ";
      const wrapped = `${wrapPrefix}${src} })()`;
      const wrappedArray = ArrayFrom(wrapped);
      let root;
      try {
        root = parser.parse(wrapped, { ecmaVersion: "latest" });
      } catch (e) {
        if (StringPrototypeStartsWith(e.message, "Unterminated "))
          throw new Recoverable(e);
        const awaitPos = StringPrototypeIndexOf(src, "await");
        const errPos = e.pos - wrapPrefix.length;
        if (awaitPos > errPos)
          return null;
        if (errPos === awaitPos + 6 && StringPrototypeIncludes(e.message, "Expecting Unicode escape sequence"))
          return null;
        if (errPos === awaitPos + 7 && StringPrototypeIncludes(e.message, "Unexpected token"))
          return null;
        const line = e.loc.line;
        const column = line === 1 ? e.loc.column - wrapPrefix.length : e.loc.column;
        let message = "\n" + StringPrototypeSplit(src, "\n")[line - 1] + "\n" + StringPrototypeRepeat(" ", column) + "^\n\n" + RegExpPrototypeSymbolReplace(/ \([^)]+\)/, e.message, "");
        if (StringPrototypeEndsWith(message, "Unexpected token"))
          message += " '" + // Wrapper end may cause acorn to report error position after the source
          (src.length - 1 >= e.pos - wrapPrefix.length ? src[e.pos - wrapPrefix.length] : src[src.length - 1]) + "'";
        throw new SyntaxError2(message);
      }
      const body = root.body[0].expression.callee.body;
      const state = {
        body,
        ancestors: [],
        hoistedDeclarationStatements: [],
        replace(from, to, str) {
          for (let i = from; i < to; i++) {
            wrappedArray[i] = "";
          }
          if (from === to)
            str += wrappedArray[from];
          wrappedArray[from] = str;
        },
        prepend(node, str) {
          wrappedArray[node.start] = str + wrappedArray[node.start];
        },
        append(node, str) {
          wrappedArray[node.end - 1] += str;
        },
        containsAwait: false,
        containsReturn: false
      };
      walk.recursive(body, state, visitors);
      if (!state.containsAwait || state.containsReturn) {
        return null;
      }
      const last2 = body.body[body.body.length - 1];
      if (last2.type === "ExpressionStatement") {
        state.prepend(last2, "return (");
        state.append(last2.expression, ")");
      }
      return ArrayPrototypeJoin(state.hoistedDeclarationStatements, "") + ArrayPrototypeJoin(wrappedArray, "");
    }
    module.exports = {
      processTopLevelAwait
    };
  }
});

// node_modules/.pnpm/diff@4.0.2/node_modules/diff/dist/diff.js
var require_diff = __commonJS({
  "node_modules/.pnpm/diff@4.0.2/node_modules/diff/dist/diff.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.Diff = {}));
    })(exports, function(exports2) {
      "use strict";
      function Diff() {
      }
      Diff.prototype = {
        diff: function diff(oldString, newString) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var callback = options.callback;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          this.options = options;
          var self2 = this;
          function done(value2) {
            if (callback) {
              setTimeout(function() {
                callback(void 0, value2);
              }, 0);
              return true;
            } else {
              return value2;
            }
          }
          oldString = this.castInput(oldString);
          newString = this.castInput(newString);
          oldString = this.removeEmpty(this.tokenize(oldString));
          newString = this.removeEmpty(this.tokenize(newString));
          var newLen = newString.length, oldLen = oldString.length;
          var editLength = 1;
          var maxEditLength = newLen + oldLen;
          var bestPath = [{
            newPos: -1,
            components: []
          }];
          var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
          if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
            return done([{
              value: this.join(newString),
              count: newString.length
            }]);
          }
          function execEditLength() {
            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
              var basePath = void 0;
              var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
              if (addPath) {
                bestPath[diagonalPath - 1] = void 0;
              }
              var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
              if (!canAdd && !canRemove) {
                bestPath[diagonalPath] = void 0;
                continue;
              }
              if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
                basePath = clonePath(removePath);
                self2.pushComponent(basePath.components, void 0, true);
              } else {
                basePath = addPath;
                basePath.newPos++;
                self2.pushComponent(basePath.components, true, void 0);
              }
              _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
              if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
                return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
              } else {
                bestPath[diagonalPath] = basePath;
              }
            }
            editLength++;
          }
          if (callback) {
            (function exec() {
              setTimeout(function() {
                if (editLength > maxEditLength) {
                  return callback();
                }
                if (!execEditLength()) {
                  exec();
                }
              }, 0);
            })();
          } else {
            while (editLength <= maxEditLength) {
              var ret = execEditLength();
              if (ret) {
                return ret;
              }
            }
          }
        },
        pushComponent: function pushComponent(components, added, removed) {
          var last2 = components[components.length - 1];
          if (last2 && last2.added === added && last2.removed === removed) {
            components[components.length - 1] = {
              count: last2.count + 1,
              added,
              removed
            };
          } else {
            components.push({
              count: 1,
              added,
              removed
            });
          }
        },
        extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
          var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
          while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
            newPos++;
            oldPos++;
            commonCount++;
          }
          if (commonCount) {
            basePath.components.push({
              count: commonCount
            });
          }
          basePath.newPos = newPos;
          return oldPos;
        },
        equals: function equals3(left, right) {
          if (this.options.comparator) {
            return this.options.comparator(left, right);
          } else {
            return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
          }
        },
        removeEmpty: function removeEmpty(array) {
          var ret = [];
          for (var i = 0; i < array.length; i++) {
            if (array[i]) {
              ret.push(array[i]);
            }
          }
          return ret;
        },
        castInput: function castInput(value2) {
          return value2;
        },
        tokenize: function tokenize(value2) {
          return value2.split("");
        },
        join: function join2(chars) {
          return chars.join("");
        }
      };
      function buildValues(diff, components, newString, oldString, useLongestToken) {
        var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
        for (; componentPos < componentLen; componentPos++) {
          var component = components[componentPos];
          if (!component.removed) {
            if (!component.added && useLongestToken) {
              var value2 = newString.slice(newPos, newPos + component.count);
              value2 = value2.map(function(value3, i) {
                var oldValue = oldString[oldPos + i];
                return oldValue.length > value3.length ? oldValue : value3;
              });
              component.value = diff.join(value2);
            } else {
              component.value = diff.join(newString.slice(newPos, newPos + component.count));
            }
            newPos += component.count;
            if (!component.added) {
              oldPos += component.count;
            }
          } else {
            component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
            oldPos += component.count;
            if (componentPos && components[componentPos - 1].added) {
              var tmp = components[componentPos - 1];
              components[componentPos - 1] = components[componentPos];
              components[componentPos] = tmp;
            }
          }
        }
        var lastComponent = components[componentLen - 1];
        if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
          components[componentLen - 2].value += lastComponent.value;
          components.pop();
        }
        return components;
      }
      function clonePath(path3) {
        return {
          newPos: path3.newPos,
          components: path3.components.slice(0)
        };
      }
      var characterDiff = new Diff();
      function diffChars(oldStr, newStr, options) {
        return characterDiff.diff(oldStr, newStr, options);
      }
      function generateOptions(options, defaults) {
        if (typeof options === "function") {
          defaults.callback = options;
        } else if (options) {
          for (var name in options) {
            if (options.hasOwnProperty(name)) {
              defaults[name] = options[name];
            }
          }
        }
        return defaults;
      }
      var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
      var reWhitespace = /\S/;
      var wordDiff = new Diff();
      wordDiff.equals = function(left, right) {
        if (this.options.ignoreCase) {
          left = left.toLowerCase();
          right = right.toLowerCase();
        }
        return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
      };
      wordDiff.tokenize = function(value2) {
        var tokens = value2.split(/(\s+|[()[\]{}'"]|\b)/);
        for (var i = 0; i < tokens.length - 1; i++) {
          if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
            tokens[i] += tokens[i + 2];
            tokens.splice(i + 1, 2);
            i--;
          }
        }
        return tokens;
      };
      function diffWords(oldStr, newStr, options) {
        options = generateOptions(options, {
          ignoreWhitespace: true
        });
        return wordDiff.diff(oldStr, newStr, options);
      }
      function diffWordsWithSpace(oldStr, newStr, options) {
        return wordDiff.diff(oldStr, newStr, options);
      }
      var lineDiff = new Diff();
      lineDiff.tokenize = function(value2) {
        var retLines = [], linesAndNewlines = value2.split(/(\n|\r\n)/);
        if (!linesAndNewlines[linesAndNewlines.length - 1]) {
          linesAndNewlines.pop();
        }
        for (var i = 0; i < linesAndNewlines.length; i++) {
          var line = linesAndNewlines[i];
          if (i % 2 && !this.options.newlineIsToken) {
            retLines[retLines.length - 1] += line;
          } else {
            if (this.options.ignoreWhitespace) {
              line = line.trim();
            }
            retLines.push(line);
          }
        }
        return retLines;
      };
      function diffLines(oldStr, newStr, callback) {
        return lineDiff.diff(oldStr, newStr, callback);
      }
      function diffTrimmedLines(oldStr, newStr, callback) {
        var options = generateOptions(callback, {
          ignoreWhitespace: true
        });
        return lineDiff.diff(oldStr, newStr, options);
      }
      var sentenceDiff = new Diff();
      sentenceDiff.tokenize = function(value2) {
        return value2.split(/(\S.+?[.!?])(?=\s+|$)/);
      };
      function diffSentences(oldStr, newStr, callback) {
        return sentenceDiff.diff(oldStr, newStr, callback);
      }
      var cssDiff = new Diff();
      cssDiff.tokenize = function(value2) {
        return value2.split(/([{}:;,]|\s+)/);
      };
      function diffCss(oldStr, newStr, callback) {
        return cssDiff.diff(oldStr, newStr, callback);
      }
      function _typeof2(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray2(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        }
      }
      function _iterableToArray2(iter) {
        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
          return Array.from(iter);
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
      }
      var objectPrototypeToString = Object.prototype.toString;
      var jsonDiff = new Diff();
      jsonDiff.useLongestToken = true;
      jsonDiff.tokenize = lineDiff.tokenize;
      jsonDiff.castInput = function(value2) {
        var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
          return typeof v === "undefined" ? undefinedReplacement : v;
        } : _this$options$stringi;
        return typeof value2 === "string" ? value2 : JSON.stringify(canonicalize(value2, null, null, stringifyReplacer), stringifyReplacer, "  ");
      };
      jsonDiff.equals = function(left, right) {
        return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
      };
      function diffJson(oldObj, newObj, options) {
        return jsonDiff.diff(oldObj, newObj, options);
      }
      function canonicalize(obj, stack, replacementStack, replacer, key) {
        stack = stack || [];
        replacementStack = replacementStack || [];
        if (replacer) {
          obj = replacer(key, obj);
        }
        var i;
        for (i = 0; i < stack.length; i += 1) {
          if (stack[i] === obj) {
            return replacementStack[i];
          }
        }
        var canonicalizedObj;
        if ("[object Array]" === objectPrototypeToString.call(obj)) {
          stack.push(obj);
          canonicalizedObj = new Array(obj.length);
          replacementStack.push(canonicalizedObj);
          for (i = 0; i < obj.length; i += 1) {
            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
          }
          stack.pop();
          replacementStack.pop();
          return canonicalizedObj;
        }
        if (obj && obj.toJSON) {
          obj = obj.toJSON();
        }
        if (_typeof2(obj) === "object" && obj !== null) {
          stack.push(obj);
          canonicalizedObj = {};
          replacementStack.push(canonicalizedObj);
          var sortedKeys = [], _key;
          for (_key in obj) {
            if (obj.hasOwnProperty(_key)) {
              sortedKeys.push(_key);
            }
          }
          sortedKeys.sort();
          for (i = 0; i < sortedKeys.length; i += 1) {
            _key = sortedKeys[i];
            canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
          }
          stack.pop();
          replacementStack.pop();
        } else {
          canonicalizedObj = obj;
        }
        return canonicalizedObj;
      }
      var arrayDiff = new Diff();
      arrayDiff.tokenize = function(value2) {
        return value2.slice();
      };
      arrayDiff.join = arrayDiff.removeEmpty = function(value2) {
        return value2;
      };
      function diffArrays(oldArr, newArr, callback) {
        return arrayDiff.diff(oldArr, newArr, callback);
      }
      function parsePatch(uniDiff) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/), delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [], list = [], i = 0;
        function parseIndex() {
          var index = {};
          list.push(index);
          while (i < diffstr.length) {
            var line = diffstr[i];
            if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
              break;
            }
            var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
            if (header) {
              index.index = header[1];
            }
            i++;
          }
          parseFileHeader(index);
          parseFileHeader(index);
          index.hunks = [];
          while (i < diffstr.length) {
            var _line = diffstr[i];
            if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
              break;
            } else if (/^@@/.test(_line)) {
              index.hunks.push(parseHunk());
            } else if (_line && options.strict) {
              throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(_line));
            } else {
              i++;
            }
          }
        }
        function parseFileHeader(index) {
          var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
          if (fileHeader) {
            var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
            var data = fileHeader[2].split("	", 2);
            var fileName = data[0].replace(/\\\\/g, "\\");
            if (/^".*"$/.test(fileName)) {
              fileName = fileName.substr(1, fileName.length - 2);
            }
            index[keyPrefix + "FileName"] = fileName;
            index[keyPrefix + "Header"] = (data[1] || "").trim();
            i++;
          }
        }
        function parseHunk() {
          var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
          var hunk = {
            oldStart: +chunkHeader[1],
            oldLines: +chunkHeader[2] || 1,
            newStart: +chunkHeader[3],
            newLines: +chunkHeader[4] || 1,
            lines: [],
            linedelimiters: []
          };
          var addCount = 0, removeCount = 0;
          for (; i < diffstr.length; i++) {
            if (diffstr[i].indexOf("--- ") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf("+++ ") === 0 && diffstr[i + 2].indexOf("@@") === 0) {
              break;
            }
            var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
            if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
              hunk.lines.push(diffstr[i]);
              hunk.linedelimiters.push(delimiters[i] || "\n");
              if (operation === "+") {
                addCount++;
              } else if (operation === "-") {
                removeCount++;
              } else if (operation === " ") {
                addCount++;
                removeCount++;
              }
            } else {
              break;
            }
          }
          if (!addCount && hunk.newLines === 1) {
            hunk.newLines = 0;
          }
          if (!removeCount && hunk.oldLines === 1) {
            hunk.oldLines = 0;
          }
          if (options.strict) {
            if (addCount !== hunk.newLines) {
              throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
            }
            if (removeCount !== hunk.oldLines) {
              throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
            }
          }
          return hunk;
        }
        while (i < diffstr.length) {
          parseIndex();
        }
        return list;
      }
      function distanceIterator(start, minLine, maxLine) {
        var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
        return function iterator() {
          if (wantForward && !forwardExhausted) {
            if (backwardExhausted) {
              localOffset++;
            } else {
              wantForward = false;
            }
            if (start + localOffset <= maxLine) {
              return localOffset;
            }
            forwardExhausted = true;
          }
          if (!backwardExhausted) {
            if (!forwardExhausted) {
              wantForward = true;
            }
            if (minLine <= start - localOffset) {
              return -localOffset++;
            }
            backwardExhausted = true;
            return iterator();
          }
        };
      }
      function applyPatch(source, uniDiff) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (typeof uniDiff === "string") {
          uniDiff = parsePatch(uniDiff);
        }
        if (Array.isArray(uniDiff)) {
          if (uniDiff.length > 1) {
            throw new Error("applyPatch only works with a single input.");
          }
          uniDiff = uniDiff[0];
        }
        var lines = source.split(/\r\n|[\n\v\f\r\x85]/), delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line2, operation2, patchContent) {
          return line2 === patchContent;
        }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;
        function hunkFits(hunk2, toPos2) {
          for (var j2 = 0; j2 < hunk2.lines.length; j2++) {
            var line2 = hunk2.lines[j2], operation2 = line2.length > 0 ? line2[0] : " ", content2 = line2.length > 0 ? line2.substr(1) : line2;
            if (operation2 === " " || operation2 === "-") {
              if (!compareLine(toPos2 + 1, lines[toPos2], operation2, content2)) {
                errorCount++;
                if (errorCount > fuzzFactor) {
                  return false;
                }
              }
              toPos2++;
            }
          }
          return true;
        }
        for (var i = 0; i < hunks.length; i++) {
          var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;
          var iterator = distanceIterator(toPos, minLine, maxLine);
          for (; localOffset !== void 0; localOffset = iterator()) {
            if (hunkFits(hunk, toPos + localOffset)) {
              hunk.offset = offset += localOffset;
              break;
            }
          }
          if (localOffset === void 0) {
            return false;
          }
          minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
        }
        var diffOffset = 0;
        for (var _i = 0; _i < hunks.length; _i++) {
          var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
          diffOffset += _hunk.newLines - _hunk.oldLines;
          if (_toPos < 0) {
            _toPos = 0;
          }
          for (var j = 0; j < _hunk.lines.length; j++) {
            var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : " ", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters[j];
            if (operation === " ") {
              _toPos++;
            } else if (operation === "-") {
              lines.splice(_toPos, 1);
              delimiters.splice(_toPos, 1);
            } else if (operation === "+") {
              lines.splice(_toPos, 0, content);
              delimiters.splice(_toPos, 0, delimiter);
              _toPos++;
            } else if (operation === "\\") {
              var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
              if (previousOperation === "+") {
                removeEOFNL = true;
              } else if (previousOperation === "-") {
                addEOFNL = true;
              }
            }
          }
        }
        if (removeEOFNL) {
          while (!lines[lines.length - 1]) {
            lines.pop();
            delimiters.pop();
          }
        } else if (addEOFNL) {
          lines.push("");
          delimiters.push("\n");
        }
        for (var _k = 0; _k < lines.length - 1; _k++) {
          lines[_k] = lines[_k] + delimiters[_k];
        }
        return lines.join("");
      }
      function applyPatches(uniDiff, options) {
        if (typeof uniDiff === "string") {
          uniDiff = parsePatch(uniDiff);
        }
        var currentIndex = 0;
        function processIndex() {
          var index = uniDiff[currentIndex++];
          if (!index) {
            return options.complete();
          }
          options.loadFile(index, function(err, data) {
            if (err) {
              return options.complete(err);
            }
            var updatedContent = applyPatch(data, index, options);
            options.patched(index, updatedContent, function(err2) {
              if (err2) {
                return options.complete(err2);
              }
              processIndex();
            });
          });
        }
        processIndex();
      }
      function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        if (!options) {
          options = {};
        }
        if (typeof options.context === "undefined") {
          options.context = 4;
        }
        var diff = diffLines(oldStr, newStr, options);
        diff.push({
          value: "",
          lines: []
        });
        function contextLines(lines) {
          return lines.map(function(entry) {
            return " " + entry;
          });
        }
        var hunks = [];
        var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
        var _loop = function _loop2(i2) {
          var current = diff[i2], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
          current.lines = lines;
          if (current.added || current.removed) {
            var _curRange;
            if (!oldRangeStart) {
              var prev = diff[i2 - 1];
              oldRangeStart = oldLine;
              newRangeStart = newLine;
              if (prev) {
                curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
                oldRangeStart -= curRange.length;
                newRangeStart -= curRange.length;
              }
            }
            (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
              return (current.added ? "+" : "-") + entry;
            })));
            if (current.added) {
              newLine += lines.length;
            } else {
              oldLine += lines.length;
            }
          } else {
            if (oldRangeStart) {
              if (lines.length <= options.context * 2 && i2 < diff.length - 2) {
                var _curRange2;
                (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
              } else {
                var _curRange3;
                var contextSize = Math.min(lines.length, options.context);
                (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
                var hunk = {
                  oldStart: oldRangeStart,
                  oldLines: oldLine - oldRangeStart + contextSize,
                  newStart: newRangeStart,
                  newLines: newLine - newRangeStart + contextSize,
                  lines: curRange
                };
                if (i2 >= diff.length - 2 && lines.length <= options.context) {
                  var oldEOFNewline = /\n$/.test(oldStr);
                  var newEOFNewline = /\n$/.test(newStr);
                  var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
                  if (!oldEOFNewline && noNlBeforeAdds) {
                    curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
                  }
                  if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                    curRange.push("\\ No newline at end of file");
                  }
                }
                hunks.push(hunk);
                oldRangeStart = 0;
                newRangeStart = 0;
                curRange = [];
              }
            }
            oldLine += lines.length;
            newLine += lines.length;
          }
        };
        for (var i = 0; i < diff.length; i++) {
          _loop(i);
        }
        return {
          oldFileName,
          newFileName,
          oldHeader,
          newHeader,
          hunks
        };
      }
      function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
        var ret = [];
        if (oldFileName == newFileName) {
          ret.push("Index: " + oldFileName);
        }
        ret.push("===================================================================");
        ret.push("--- " + diff.oldFileName + (typeof diff.oldHeader === "undefined" ? "" : "	" + diff.oldHeader));
        ret.push("+++ " + diff.newFileName + (typeof diff.newHeader === "undefined" ? "" : "	" + diff.newHeader));
        for (var i = 0; i < diff.hunks.length; i++) {
          var hunk = diff.hunks[i];
          ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
          ret.push.apply(ret, hunk.lines);
        }
        return ret.join("\n") + "\n";
      }
      function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
        return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
      }
      function arrayEqual(a, b) {
        if (a.length !== b.length) {
          return false;
        }
        return arrayStartsWith(a, b);
      }
      function arrayStartsWith(array, start) {
        if (start.length > array.length) {
          return false;
        }
        for (var i = 0; i < start.length; i++) {
          if (start[i] !== array[i]) {
            return false;
          }
        }
        return true;
      }
      function calcLineCount(hunk) {
        var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
        if (oldLines !== void 0) {
          hunk.oldLines = oldLines;
        } else {
          delete hunk.oldLines;
        }
        if (newLines !== void 0) {
          hunk.newLines = newLines;
        } else {
          delete hunk.newLines;
        }
      }
      function merge3(mine, theirs, base) {
        mine = loadPatch(mine, base);
        theirs = loadPatch(theirs, base);
        var ret = {};
        if (mine.index || theirs.index) {
          ret.index = mine.index || theirs.index;
        }
        if (mine.newFileName || theirs.newFileName) {
          if (!fileNameChanged(mine)) {
            ret.oldFileName = theirs.oldFileName || mine.oldFileName;
            ret.newFileName = theirs.newFileName || mine.newFileName;
            ret.oldHeader = theirs.oldHeader || mine.oldHeader;
            ret.newHeader = theirs.newHeader || mine.newHeader;
          } else if (!fileNameChanged(theirs)) {
            ret.oldFileName = mine.oldFileName;
            ret.newFileName = mine.newFileName;
            ret.oldHeader = mine.oldHeader;
            ret.newHeader = mine.newHeader;
          } else {
            ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
            ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
            ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
            ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
          }
        }
        ret.hunks = [];
        var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
        while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
          var mineCurrent = mine.hunks[mineIndex] || {
            oldStart: Infinity
          }, theirsCurrent = theirs.hunks[theirsIndex] || {
            oldStart: Infinity
          };
          if (hunkBefore(mineCurrent, theirsCurrent)) {
            ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
            mineIndex++;
            theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
          } else if (hunkBefore(theirsCurrent, mineCurrent)) {
            ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
            theirsIndex++;
            mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
          } else {
            var mergedHunk = {
              oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
              oldLines: 0,
              newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
              newLines: 0,
              lines: []
            };
            mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
            theirsIndex++;
            mineIndex++;
            ret.hunks.push(mergedHunk);
          }
        }
        return ret;
      }
      function loadPatch(param, base) {
        if (typeof param === "string") {
          if (/^@@/m.test(param) || /^Index:/m.test(param)) {
            return parsePatch(param)[0];
          }
          if (!base) {
            throw new Error("Must provide a base reference or pass in a patch");
          }
          return structuredPatch(void 0, void 0, base, param);
        }
        return param;
      }
      function fileNameChanged(patch) {
        return patch.newFileName && patch.newFileName !== patch.oldFileName;
      }
      function selectField(index, mine, theirs) {
        if (mine === theirs) {
          return mine;
        } else {
          index.conflict = true;
          return {
            mine,
            theirs
          };
        }
      }
      function hunkBefore(test3, check) {
        return test3.oldStart < check.oldStart && test3.oldStart + test3.oldLines < check.oldStart;
      }
      function cloneHunk(hunk, offset) {
        return {
          oldStart: hunk.oldStart,
          oldLines: hunk.oldLines,
          newStart: hunk.newStart + offset,
          newLines: hunk.newLines,
          lines: hunk.lines
        };
      }
      function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
        var mine = {
          offset: mineOffset,
          lines: mineLines,
          index: 0
        }, their = {
          offset: theirOffset,
          lines: theirLines,
          index: 0
        };
        insertLeading(hunk, mine, their);
        insertLeading(hunk, their, mine);
        while (mine.index < mine.lines.length && their.index < their.lines.length) {
          var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
          if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+")) {
            mutualChange(hunk, mine, their);
          } else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
            var _hunk$lines;
            (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
          } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
            var _hunk$lines2;
            (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
          } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ") {
            removal(hunk, mine, their);
          } else if (theirCurrent[0] === "-" && mineCurrent[0] === " ") {
            removal(hunk, their, mine, true);
          } else if (mineCurrent === theirCurrent) {
            hunk.lines.push(mineCurrent);
            mine.index++;
            their.index++;
          } else {
            conflict(hunk, collectChange(mine), collectChange(their));
          }
        }
        insertTrailing(hunk, mine);
        insertTrailing(hunk, their);
        calcLineCount(hunk);
      }
      function mutualChange(hunk, mine, their) {
        var myChanges = collectChange(mine), theirChanges = collectChange(their);
        if (allRemoves(myChanges) && allRemoves(theirChanges)) {
          if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
            var _hunk$lines3;
            (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
            return;
          } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
            var _hunk$lines4;
            (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
            return;
          }
        } else if (arrayEqual(myChanges, theirChanges)) {
          var _hunk$lines5;
          (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
          return;
        }
        conflict(hunk, myChanges, theirChanges);
      }
      function removal(hunk, mine, their, swap) {
        var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
        if (theirChanges.merged) {
          var _hunk$lines6;
          (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
        } else {
          conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
        }
      }
      function conflict(hunk, mine, their) {
        hunk.conflict = true;
        hunk.lines.push({
          conflict: true,
          mine,
          theirs: their
        });
      }
      function insertLeading(hunk, insert3, their) {
        while (insert3.offset < their.offset && insert3.index < insert3.lines.length) {
          var line = insert3.lines[insert3.index++];
          hunk.lines.push(line);
          insert3.offset++;
        }
      }
      function insertTrailing(hunk, insert3) {
        while (insert3.index < insert3.lines.length) {
          var line = insert3.lines[insert3.index++];
          hunk.lines.push(line);
        }
      }
      function collectChange(state) {
        var ret = [], operation = state.lines[state.index][0];
        while (state.index < state.lines.length) {
          var line = state.lines[state.index];
          if (operation === "-" && line[0] === "+") {
            operation = "+";
          }
          if (operation === line[0]) {
            ret.push(line);
            state.index++;
          } else {
            break;
          }
        }
        return ret;
      }
      function collectContext(state, matchChanges) {
        var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
        while (matchIndex < matchChanges.length && state.index < state.lines.length) {
          var change = state.lines[state.index], match3 = matchChanges[matchIndex];
          if (match3[0] === "+") {
            break;
          }
          contextChanges = contextChanges || change[0] !== " ";
          merged.push(match3);
          matchIndex++;
          if (change[0] === "+") {
            conflicted = true;
            while (change[0] === "+") {
              changes.push(change);
              change = state.lines[++state.index];
            }
          }
          if (match3.substr(1) === change.substr(1)) {
            changes.push(change);
            state.index++;
          } else {
            conflicted = true;
          }
        }
        if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) {
          conflicted = true;
        }
        if (conflicted) {
          return changes;
        }
        while (matchIndex < matchChanges.length) {
          merged.push(matchChanges[matchIndex++]);
        }
        return {
          merged,
          changes
        };
      }
      function allRemoves(changes) {
        return changes.reduce(function(prev, change) {
          return prev && change[0] === "-";
        }, true);
      }
      function skipRemoveSuperset(state, removeChanges, delta) {
        for (var i = 0; i < delta; i++) {
          var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
          if (state.lines[state.index + i] !== " " + changeContent) {
            return false;
          }
        }
        state.index += delta;
        return true;
      }
      function calcOldNewLineCount(lines) {
        var oldLines = 0;
        var newLines = 0;
        lines.forEach(function(line) {
          if (typeof line !== "string") {
            var myCount = calcOldNewLineCount(line.mine);
            var theirCount = calcOldNewLineCount(line.theirs);
            if (oldLines !== void 0) {
              if (myCount.oldLines === theirCount.oldLines) {
                oldLines += myCount.oldLines;
              } else {
                oldLines = void 0;
              }
            }
            if (newLines !== void 0) {
              if (myCount.newLines === theirCount.newLines) {
                newLines += myCount.newLines;
              } else {
                newLines = void 0;
              }
            }
          } else {
            if (newLines !== void 0 && (line[0] === "+" || line[0] === " ")) {
              newLines++;
            }
            if (oldLines !== void 0 && (line[0] === "-" || line[0] === " ")) {
              oldLines++;
            }
          }
        });
        return {
          oldLines,
          newLines
        };
      }
      function convertChangesToDMP(changes) {
        var ret = [], change, operation;
        for (var i = 0; i < changes.length; i++) {
          change = changes[i];
          if (change.added) {
            operation = 1;
          } else if (change.removed) {
            operation = -1;
          } else {
            operation = 0;
          }
          ret.push([operation, change.value]);
        }
        return ret;
      }
      function convertChangesToXML(changes) {
        var ret = [];
        for (var i = 0; i < changes.length; i++) {
          var change = changes[i];
          if (change.added) {
            ret.push("<ins>");
          } else if (change.removed) {
            ret.push("<del>");
          }
          ret.push(escapeHTML(change.value));
          if (change.added) {
            ret.push("</ins>");
          } else if (change.removed) {
            ret.push("</del>");
          }
        }
        return ret.join("");
      }
      function escapeHTML(s) {
        var n = s;
        n = n.replace(/&/g, "&amp;");
        n = n.replace(/</g, "&lt;");
        n = n.replace(/>/g, "&gt;");
        n = n.replace(/"/g, "&quot;");
        return n;
      }
      exports2.Diff = Diff;
      exports2.diffChars = diffChars;
      exports2.diffWords = diffWords;
      exports2.diffWordsWithSpace = diffWordsWithSpace;
      exports2.diffLines = diffLines;
      exports2.diffTrimmedLines = diffTrimmedLines;
      exports2.diffSentences = diffSentences;
      exports2.diffCss = diffCss;
      exports2.diffJson = diffJson;
      exports2.diffArrays = diffArrays;
      exports2.structuredPatch = structuredPatch;
      exports2.createTwoFilesPatch = createTwoFilesPatch;
      exports2.createPatch = createPatch;
      exports2.applyPatch = applyPatch;
      exports2.applyPatches = applyPatches;
      exports2.parsePatch = parsePatch;
      exports2.merge = merge3;
      exports2.convertChangesToDMP = convertChangesToDMP;
      exports2.convertChangesToXML = convertChangesToXML;
      exports2.canonicalize = canonicalize;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/repl.js
var require_repl2 = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/repl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupContext = exports.createEvalAwarePartialHost = exports.EvalState = exports.createRepl = exports.REPL_NAME = exports.REPL_FILENAME = exports.STDIN_NAME = exports.STDIN_FILENAME = exports.EVAL_NAME = exports.EVAL_FILENAME = void 0;
    var os_1 = require_os();
    var path_1 = require_path();
    var repl_1 = require_repl();
    var vm_1 = require_vm();
    var index_1 = require_dist4();
    var fs_1 = require_fs();
    var console_1 = (init_es(), __toCommonJS(es_exports));
    var assert = require_assert();
    var module_1 = require_module();
    var _processTopLevelAwait;
    function getProcessTopLevelAwait() {
      if (_processTopLevelAwait === void 0) {
        ({
          processTopLevelAwait: _processTopLevelAwait
        } = require_node_internal_repl_await());
      }
      return _processTopLevelAwait;
    }
    var diff;
    function getDiffLines() {
      if (diff === void 0) {
        diff = require_diff();
      }
      return diff.diffLines;
    }
    exports.EVAL_FILENAME = `[eval].ts`;
    exports.EVAL_NAME = `[eval]`;
    exports.STDIN_FILENAME = `[stdin].ts`;
    exports.STDIN_NAME = `[stdin]`;
    exports.REPL_FILENAME = "<repl>.ts";
    exports.REPL_NAME = "<repl>";
    function createRepl(options = {}) {
      var _a, _b, _c, _d, _e;
      const { ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl = true } = options;
      let service = options.service;
      let nodeReplServer;
      let context;
      const state = (_a = options.state) !== null && _a !== void 0 ? _a : new EvalState((0, path_1.join)(process.cwd(), exports.REPL_FILENAME));
      const evalAwarePartialHost = createEvalAwarePartialHost(state, options.composeWithEvalAwarePartialHost);
      const stdin = (_b = options.stdin) !== null && _b !== void 0 ? _b : process.stdin;
      const stdout = (_c = options.stdout) !== null && _c !== void 0 ? _c : process.stdout;
      const stderr = (_d = options.stderr) !== null && _d !== void 0 ? _d : process.stderr;
      const _console = stdout === process.stdout && stderr === process.stderr ? console : new console_1.Console(stdout, stderr);
      const replService = {
        state: (_e = options.state) !== null && _e !== void 0 ? _e : new EvalState((0, path_1.join)(process.cwd(), exports.EVAL_FILENAME)),
        setService,
        evalCode,
        evalCodeInternal,
        nodeEval,
        evalAwarePartialHost,
        start,
        startInternal,
        stdin,
        stdout,
        stderr,
        console: _console
      };
      return replService;
      function setService(_service) {
        service = _service;
        if (ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl) {
          service.addDiagnosticFilter({
            appliesToAllFiles: false,
            filenamesAbsolute: [state.path],
            diagnosticsIgnored: [
              2393,
              6133,
              7027,
              ...service.shouldReplAwait ? topLevelAwaitDiagnosticCodes : []
            ]
          });
        }
      }
      function evalCode(code) {
        const result = appendCompileAndEvalInput({
          service,
          state,
          input: code,
          context,
          overrideIsCompletion: false
        });
        assert(result.containsTopLevelAwait === false);
        return result.value;
      }
      function evalCodeInternal(options2) {
        const { code, enableTopLevelAwait, context: context2 } = options2;
        return appendCompileAndEvalInput({
          service,
          state,
          input: code,
          enableTopLevelAwait,
          context: context2
        });
      }
      function nodeEval(code, context2, _filename, callback) {
        if (code === ".scope") {
          callback(null);
          return;
        }
        try {
          const evalResult = evalCodeInternal({
            code,
            enableTopLevelAwait: true,
            context: context2
          });
          if (evalResult.containsTopLevelAwait) {
            (async () => {
              try {
                callback(null, await evalResult.valuePromise);
              } catch (promiseError) {
                handleError(promiseError);
              }
            })();
          } else {
            callback(null, evalResult.value);
          }
        } catch (error) {
          handleError(error);
        }
        function handleError(error) {
          var _a2, _b2;
          const canLogTopLevelAwaitHint = service.options.experimentalReplAwait !== false && !service.shouldReplAwait;
          if (error instanceof index_1.TSError) {
            if (repl_1.Recoverable && isRecoverable(error)) {
              callback(new repl_1.Recoverable(error));
              return;
            } else {
              _console.error(error);
              if (canLogTopLevelAwaitHint && error.diagnosticCodes.some((dC) => topLevelAwaitDiagnosticCodes.includes(dC))) {
                _console.error(getTopLevelAwaitHint());
              }
              callback(null);
            }
          } else {
            let _error = error;
            if (canLogTopLevelAwaitHint && _error instanceof SyntaxError && ((_a2 = _error.message) === null || _a2 === void 0 ? void 0 : _a2.includes("await is only valid"))) {
              try {
                _error.message += `

${getTopLevelAwaitHint()}`;
                _error.stack = (_b2 = _error.stack) === null || _b2 === void 0 ? void 0 : _b2.replace(/(SyntaxError:.*)/, (_, $1) => `${$1}

${getTopLevelAwaitHint()}`);
              } catch {
              }
            }
            callback(_error);
          }
        }
        function getTopLevelAwaitHint() {
          return `Hint: REPL top-level await requires TypeScript version 3.8 or higher and target ES2018 or higher. You are using TypeScript ${service.ts.version} and target ${service.ts.ScriptTarget[service.config.options.target]}.`;
        }
      }
      function start(code) {
        startInternal({ code });
      }
      function startInternal(options2) {
        const { code, forceToBeModule = true, ...optionsOverride } = options2 !== null && options2 !== void 0 ? options2 : {};
        if (code) {
          try {
            evalCode(`${code}
`);
          } catch (err) {
            _console.error(err);
            process.exit(1);
          }
        }
        service === null || service === void 0 ? void 0 : service.compile("", state.path);
        const repl = (0, repl_1.start)({
          prompt: "> ",
          input: replService.stdin,
          output: replService.stdout,
          // Mimicking node's REPL implementation: https://github.com/nodejs/node/blob/168b22ba073ee1cbf8d0bcb4ded7ff3099335d04/lib/internal/repl.js#L28-L30
          terminal: stdout.isTTY && !parseInt(index_1.env.NODE_NO_READLINE, 10),
          eval: nodeEval,
          useGlobal: true,
          ...optionsOverride
        });
        nodeReplServer = repl;
        context = repl.context;
        const resetEval = appendToEvalState(state, "");
        function reset() {
          resetEval();
          runInContext("exports = module.exports", state.path, context);
          if (forceToBeModule) {
            state.input += "export {};void 0;\n";
          }
          if (!(service === null || service === void 0 ? void 0 : service.transpileOnly)) {
            state.input += `// @ts-ignore
${module_1.builtinModules.filter((name) => !name.startsWith("_") && !name.includes("/") && !["console", "module", "process"].includes(name)).map((name) => `declare import ${name} = require('${name}')`).join(";")}
`;
          }
        }
        reset();
        repl.on("reset", reset);
        repl.defineCommand("type", {
          help: "Check the type of a TypeScript identifier",
          action: function(identifier) {
            if (!identifier) {
              repl.displayPrompt();
              return;
            }
            const undo = appendToEvalState(state, identifier);
            const { name, comment } = service.getTypeInfo(state.input, state.path, state.input.length);
            undo();
            if (name)
              repl.outputStream.write(`${name}
`);
            if (comment)
              repl.outputStream.write(`${comment}
`);
            repl.displayPrompt();
          }
        });
        if (repl.setupHistory) {
          const historyPath = index_1.env.TS_NODE_HISTORY || (0, path_1.join)((0, os_1.homedir)(), ".ts_node_repl_history");
          repl.setupHistory(historyPath, (err) => {
            if (!err)
              return;
            _console.error(err);
            process.exit(1);
          });
        }
        return repl;
      }
    }
    exports.createRepl = createRepl;
    var EvalState = class {
      constructor(path3) {
        this.path = path3;
        this.input = "";
        this.output = "";
        this.version = 0;
        this.lines = 0;
      }
    };
    exports.EvalState = EvalState;
    function createEvalAwarePartialHost(state, composeWith3) {
      function readFile(path3) {
        if (path3 === state.path)
          return state.input;
        if (composeWith3 === null || composeWith3 === void 0 ? void 0 : composeWith3.readFile)
          return composeWith3.readFile(path3);
        try {
          return (0, fs_1.readFileSync)(path3, "utf8");
        } catch (err) {
        }
      }
      function fileExists(path3) {
        if (path3 === state.path)
          return true;
        if (composeWith3 === null || composeWith3 === void 0 ? void 0 : composeWith3.fileExists)
          return composeWith3.fileExists(path3);
        try {
          const stats = (0, fs_1.statSync)(path3);
          return stats.isFile() || stats.isFIFO();
        } catch (err) {
          return false;
        }
      }
      return { readFile, fileExists };
    }
    exports.createEvalAwarePartialHost = createEvalAwarePartialHost;
    var sourcemapCommentRe = /\/\/# ?sourceMappingURL=\S+[\s\r\n]*$/;
    function appendCompileAndEvalInput(options) {
      const { service, state, wrappedErr, enableTopLevelAwait = false, context, overrideIsCompletion } = options;
      let { input } = options;
      let wrappedCmd = false;
      if (!wrappedErr && /^\s*{/.test(input) && !/;\s*$/.test(input)) {
        input = `(${input.trim()})
`;
        wrappedCmd = true;
      }
      const lines = state.lines;
      const isCompletion = overrideIsCompletion !== null && overrideIsCompletion !== void 0 ? overrideIsCompletion : !/\n$/.test(input);
      const undo = appendToEvalState(state, input);
      let output;
      function adjustUseStrict(code) {
        return code.replace(/^"use strict";/, '"use strict"; void 0;');
      }
      try {
        output = service.compile(state.input, state.path, -lines);
      } catch (err) {
        undo();
        if (wrappedCmd) {
          if (err instanceof index_1.TSError && err.diagnosticCodes[0] === 2339) {
            throw err;
          }
          return appendCompileAndEvalInput({
            ...options,
            wrappedErr: err
          });
        }
        if (wrappedErr)
          throw wrappedErr;
        throw err;
      }
      output = adjustUseStrict(output);
      const outputWithoutSourcemapComment = output.replace(sourcemapCommentRe, "");
      const oldOutputWithoutSourcemapComment = state.output.replace(sourcemapCommentRe, "");
      const changes = getDiffLines()(oldOutputWithoutSourcemapComment, outputWithoutSourcemapComment);
      if (isCompletion) {
        undo();
      } else {
        state.output = output;
        state.input = state.input.replace(/([^\n\s])([\n\s]*)$/, (all3, lastChar, whitespace) => {
          if (lastChar !== ";")
            return `${lastChar};${whitespace}`;
          return all3;
        });
      }
      let commands = [];
      let containsTopLevelAwait = false;
      for (const change of changes) {
        if (change.added) {
          if (enableTopLevelAwait && service.shouldReplAwait && change.value.indexOf("await") > -1) {
            const processTopLevelAwait = getProcessTopLevelAwait();
            const wrappedResult = processTopLevelAwait(change.value + "\n");
            if (wrappedResult !== null) {
              containsTopLevelAwait = true;
              commands.push({
                mustAwait: true,
                execCommand: () => runInContext(wrappedResult, state.path, context)
              });
              continue;
            }
          }
          commands.push({
            execCommand: () => runInContext(change.value, state.path, context)
          });
        }
      }
      if (containsTopLevelAwait) {
        return {
          containsTopLevelAwait,
          valuePromise: (async () => {
            let value2;
            for (const command of commands) {
              const r = command.execCommand();
              value2 = command.mustAwait ? await r : r;
            }
            return value2;
          })()
        };
      } else {
        return {
          containsTopLevelAwait: false,
          value: commands.reduce((_, c) => c.execCommand(), void 0)
        };
      }
    }
    function runInContext(code, filename, context) {
      const script = new vm_1.Script(code, { filename });
      if (context === void 0 || context === global) {
        return script.runInThisContext();
      } else {
        return script.runInContext(context);
      }
    }
    function appendToEvalState(state, input) {
      const undoInput = state.input;
      const undoVersion = state.version;
      const undoOutput = state.output;
      const undoLines = state.lines;
      state.input += input;
      state.lines += lineCount(input);
      state.version++;
      return function() {
        state.input = undoInput;
        state.output = undoOutput;
        state.version = undoVersion;
        state.lines = undoLines;
      };
    }
    function lineCount(value2) {
      let count = 0;
      for (const char of value2) {
        if (char === "\n") {
          count++;
        }
      }
      return count;
    }
    var RECOVERY_CODES = /* @__PURE__ */ new Map([
      [1003, null],
      [1005, null],
      [1109, null],
      [1126, null],
      [
        1136,
        /* @__PURE__ */ new Set([1005])
        // happens when typing out an object literal or block scope across multiple lines: '{ foo: 123,'
      ],
      [1160, null],
      [1161, null],
      [2355, null],
      [2391, null],
      [
        7010,
        /* @__PURE__ */ new Set([1005])
        // happens when fn signature spread across multiple lines: 'function a(\nb: any\n) {'
      ]
    ]);
    var topLevelAwaitDiagnosticCodes = [
      1375,
      1378,
      1431,
      1432
      // Top-level 'for await' loops are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.
    ];
    function isRecoverable(error) {
      return error.diagnosticCodes.every((code) => {
        const deps = RECOVERY_CODES.get(code);
        return deps === null || deps && error.diagnosticCodes.some((code2) => deps.has(code2));
      });
    }
    function setupContext(context, module2, filenameAndDirname) {
      if (filenameAndDirname) {
        context.__dirname = ".";
        context.__filename = `[${filenameAndDirname}]`;
      }
      context.module = module2;
      context.exports = module2.exports;
      context.require = module2.require.bind(module2);
    }
    exports.setupContext = setupContext;
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/package.json
var require_package = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/package.json"(exports, module) {
    module.exports = {
      name: "ts-node",
      version: "10.9.1",
      description: "TypeScript execution environment and REPL for node.js, with source map support",
      main: "dist/index.js",
      exports: {
        ".": "./dist/index.js",
        "./package": "./package.json",
        "./package.json": "./package.json",
        "./dist/bin": "./dist/bin.js",
        "./dist/bin.js": "./dist/bin.js",
        "./dist/bin-transpile": "./dist/bin-transpile.js",
        "./dist/bin-transpile.js": "./dist/bin-transpile.js",
        "./dist/bin-script": "./dist/bin-script.js",
        "./dist/bin-script.js": "./dist/bin-script.js",
        "./dist/bin-cwd": "./dist/bin-cwd.js",
        "./dist/bin-cwd.js": "./dist/bin-cwd.js",
        "./dist/bin-esm": "./dist/bin-esm.js",
        "./dist/bin-esm.js": "./dist/bin-esm.js",
        "./register": "./register/index.js",
        "./register/files": "./register/files.js",
        "./register/transpile-only": "./register/transpile-only.js",
        "./register/type-check": "./register/type-check.js",
        "./esm": "./esm.mjs",
        "./esm.mjs": "./esm.mjs",
        "./esm/transpile-only": "./esm/transpile-only.mjs",
        "./esm/transpile-only.mjs": "./esm/transpile-only.mjs",
        "./child-loader.mjs": "./child-loader.mjs",
        "./transpilers/swc": "./transpilers/swc.js",
        "./transpilers/swc-experimental": "./transpilers/swc-experimental.js",
        "./node10/tsconfig.json": "./node10/tsconfig.json",
        "./node12/tsconfig.json": "./node12/tsconfig.json",
        "./node14/tsconfig.json": "./node14/tsconfig.json",
        "./node16/tsconfig.json": "./node16/tsconfig.json"
      },
      types: "dist/index.d.ts",
      bin: {
        "ts-node": "dist/bin.js",
        "ts-node-cwd": "dist/bin-cwd.js",
        "ts-node-esm": "dist/bin-esm.js",
        "ts-node-script": "dist/bin-script.js",
        "ts-node-transpile-only": "dist/bin-transpile.js",
        "ts-script": "dist/bin-script-deprecated.js"
      },
      files: [
        "/transpilers/",
        "/dist/",
        "!/dist/test",
        "/dist-raw/NODE-LICENSE.md",
        "/dist-raw/**.js",
        "/register/",
        "/esm/",
        "/esm.mjs",
        "/child-loader.mjs",
        "/LICENSE",
        "/tsconfig.schema.json",
        "/tsconfig.schemastore-schema.json",
        "/node10/",
        "/node12/",
        "/node14/",
        "/node16/"
      ],
      scripts: {
        lint: "dprint check",
        "lint-fix": "dprint fmt",
        clean: "rimraf temp dist tsconfig.schema.json tsconfig.schemastore-schema.json tsconfig.tsbuildinfo tests/ts-node-packed.tgz tests/node_modules tests/tmp",
        rebuild: "npm run clean && npm run build",
        build: "npm run build-nopack && npm run build-pack",
        "build-nopack": "npm run build-tsc && npm run build-configSchema",
        "build-tsc": "tsc -b ./tsconfig.build-dist.json",
        "build-configSchema": "typescript-json-schema --topRef --refs --validationKeywords allOf --out tsconfig.schema.json tsconfig.build-schema.json TsConfigSchema && node --require ./register ./scripts/create-merged-schema",
        "build-pack": "node ./scripts/build-pack.js",
        "test-spec": "ava",
        "test-cov": "nyc ava",
        test: "npm run build && npm run lint && npm run test-cov --",
        "test-local": "npm run lint-fix && npm run build-tsc && npm run build-pack && npm run test-spec --",
        "pre-debug": "npm run build-tsc && npm run build-pack",
        "coverage-report": "nyc report --reporter=lcov",
        prepare: "npm run clean && npm run build-nopack",
        "api-extractor": "api-extractor run --local --verbose",
        "esm-usage-example": "npm run build-tsc && cd esm-usage-example && node --experimental-specifier-resolution node --loader ../esm.mjs ./index",
        "esm-usage-example2": "npm run build-tsc && cd tests && TS_NODE_PROJECT=./module-types/override-to-cjs/tsconfig.json node --loader ../esm.mjs ./module-types/override-to-cjs/test.cjs"
      },
      repository: {
        type: "git",
        url: "git://github.com/TypeStrong/ts-node.git"
      },
      keywords: [
        "typescript",
        "node",
        "runtime",
        "environment",
        "ts",
        "compiler"
      ],
      author: {
        name: "Blake Embrey",
        email: "hello@blakeembrey.com",
        url: "http://blakeembrey.me"
      },
      contributors: [
        {
          name: "Andrew Bradley",
          email: "cspotcode@gmail.com",
          url: "https://github.com/cspotcode"
        }
      ],
      license: "MIT",
      bugs: {
        url: "https://github.com/TypeStrong/ts-node/issues"
      },
      homepage: "https://typestrong.org/ts-node",
      devDependencies: {
        "@microsoft/api-extractor": "^7.19.4",
        "@swc/core": ">=1.2.205",
        "@swc/wasm": ">=1.2.205",
        "@types/diff": "^4.0.2",
        "@types/lodash": "^4.14.151",
        "@types/node": "13.13.5",
        "@types/proper-lockfile": "^4.1.2",
        "@types/proxyquire": "^1.3.28",
        "@types/react": "^16.14.19",
        "@types/rimraf": "^3.0.0",
        "@types/semver": "^7.1.0",
        "@yarnpkg/fslib": "^2.4.0",
        ava: "^3.15.0",
        axios: "^0.21.1",
        dprint: "^0.25.0",
        expect: "^27.0.2",
        "get-stream": "^6.0.0",
        lodash: "^4.17.15",
        ntypescript: "^1.201507091536.1",
        nyc: "^15.0.1",
        outdent: "^0.8.0",
        "proper-lockfile": "^4.1.2",
        proxyquire: "^2.0.0",
        react: "^16.14.0",
        rimraf: "^3.0.0",
        semver: "^7.1.3",
        throat: "^6.0.1",
        typedoc: "^0.22.10",
        typescript: "4.7.4",
        "typescript-json-schema": "^0.53.0",
        "util.promisify": "^1.0.1"
      },
      peerDependencies: {
        "@swc/core": ">=1.2.50",
        "@swc/wasm": ">=1.2.50",
        "@types/node": "*",
        typescript: ">=2.7"
      },
      peerDependenciesMeta: {
        "@swc/core": {
          optional: true
        },
        "@swc/wasm": {
          optional: true
        }
      },
      dependencies: {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        acorn: "^8.4.1",
        "acorn-walk": "^8.1.1",
        arg: "^4.1.0",
        "create-require": "^1.1.0",
        diff: "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        yn: "3.1.1"
      },
      prettier: {
        singleQuote: true
      },
      volta: {
        node: "18.1.0",
        npm: "6.14.15"
      }
    };
  }
});

// node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sourcemapCodec = {}));
    })(exports, function(exports2) {
      "use strict";
      const comma = ",".charCodeAt(0);
      const semicolon = ";".charCodeAt(0);
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar = new Uint8Array(64);
      const charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c = chars.charCodeAt(i);
        intToChar[i] = c;
        charToInt[c] = i;
      }
      const td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      function decode(mappings) {
        const state = new Int32Array(5);
        const decoded = [];
        let index = 0;
        do {
          const semi = indexOf3(mappings, index);
          const line = [];
          let sorted = true;
          let lastCol = 0;
          state[0] = 0;
          for (let i = index; i < semi; i++) {
            let seg;
            i = decodeInteger(mappings, i, state, 0);
            const col = state[0];
            if (col < lastCol)
              sorted = false;
            lastCol = col;
            if (hasMoreVlq(mappings, i, semi)) {
              i = decodeInteger(mappings, i, state, 1);
              i = decodeInteger(mappings, i, state, 2);
              i = decodeInteger(mappings, i, state, 3);
              if (hasMoreVlq(mappings, i, semi)) {
                i = decodeInteger(mappings, i, state, 4);
                seg = [col, state[1], state[2], state[3], state[4]];
              } else {
                seg = [col, state[1], state[2], state[3]];
              }
            } else {
              seg = [col];
            }
            line.push(seg);
          }
          if (!sorted)
            sort3(line);
          decoded.push(line);
          index = semi + 1;
        } while (index <= mappings.length);
        return decoded;
      }
      function indexOf3(mappings, index) {
        const idx = mappings.indexOf(";", index);
        return idx === -1 ? mappings.length : idx;
      }
      function decodeInteger(mappings, pos, state, j) {
        let value2 = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c = mappings.charCodeAt(pos++);
          integer = charToInt[c];
          value2 |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value2 & 1;
        value2 >>>= 1;
        if (shouldNegate) {
          value2 = -2147483648 | -value2;
        }
        state[j] += value2;
        return pos;
      }
      function hasMoreVlq(mappings, i, length4) {
        if (i >= length4)
          return false;
        return mappings.charCodeAt(i) !== comma;
      }
      function sort3(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode(decoded) {
        const state = new Int32Array(5);
        const bufLength = 1024 * 16;
        const subLength = bufLength - 36;
        const buf = new Uint8Array(bufLength);
        const sub = buf.subarray(0, subLength);
        let pos = 0;
        let out = "";
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0) {
            if (pos === bufLength) {
              out += td.decode(buf);
              pos = 0;
            }
            buf[pos++] = semicolon;
          }
          if (line.length === 0)
            continue;
          state[0] = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (pos > subLength) {
              out += td.decode(sub);
              buf.copyWithin(0, subLength, pos);
              pos -= subLength;
            }
            if (j > 0)
              buf[pos++] = comma;
            pos = encodeInteger(buf, pos, state, segment, 0);
            if (segment.length === 1)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 1);
            pos = encodeInteger(buf, pos, state, segment, 2);
            pos = encodeInteger(buf, pos, state, segment, 3);
            if (segment.length === 4)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 4);
          }
        }
        return out + td.decode(buf.subarray(0, pos));
      }
      function encodeInteger(buf, pos, state, segment, j) {
        const next = segment[j];
        let num = next - state[j];
        state[j] = next;
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          let clamped = num & 31;
          num >>>= 5;
          if (num > 0)
            clamped |= 32;
          buf[pos++] = intToChar[clamped];
        } while (num > 0);
        return pos;
      }
      exports2.decode = decode;
      exports2.encode = encode;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
    })(exports, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      var UrlType;
      (function(UrlType2) {
        UrlType2[UrlType2["Empty"] = 1] = "Empty";
        UrlType2[UrlType2["Hash"] = 2] = "Hash";
        UrlType2[UrlType2["Query"] = 3] = "Query";
        UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
        UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
        UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
        UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
      })(UrlType || (UrlType = {}));
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match3 = urlRegex.exec(input);
        return makeUrl(match3[1], match3[2] || "", match3[3], match3[4] || "", match3[5] || "/", match3[6] || "", match3[7] || "");
      }
      function parseFileUrl(input) {
        const match3 = fileRegex.exec(input);
        const path3 = match3[2];
        return makeUrl("file:", "", match3[1] || "", "", isAbsolutePath(path3) ? path3 : "/" + path3, match3[3] || "", match3[4] || "");
      }
      function makeUrl(scheme, user, host, port, path3, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path: path3,
          query,
          hash,
          type: UrlType.Absolute
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = UrlType.SchemeRelative;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = UrlType.AbsolutePath;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
        return url;
      }
      function stripPathFilename(path3) {
        if (path3.endsWith("/.."))
          return path3;
        const index = path3.lastIndexOf("/");
        return path3.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type3) {
        const rel = type3 <= UrlType.RelativePath;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path3 = "";
        for (let i = 1; i < pointer; i++) {
          path3 += "/" + pieces[i];
        }
        if (!path3 || addTrailingSlash && !path3.endsWith("/..")) {
          path3 += "/";
        }
        url.path = path3;
      }
      function resolve27(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== UrlType.Absolute) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case UrlType.Empty:
              url.hash = baseUrl.hash;
            case UrlType.Hash:
              url.query = baseUrl.query;
            case UrlType.Query:
            case UrlType.RelativePath:
              mergePaths(url, baseUrl);
            case UrlType.AbsolutePath:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            case UrlType.SchemeRelative:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          case UrlType.Hash:
          case UrlType.Query:
            return queryHash;
          case UrlType.RelativePath: {
            const path3 = url.path.slice(1);
            if (!path3)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path3)) {
              return "./" + path3 + queryHash;
            }
            return path3 + queryHash;
          }
          case UrlType.AbsolutePath:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve27;
    });
  }
});

// node_modules/.pnpm/@jridgewell+trace-mapping@0.3.9/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "node_modules/.pnpm/@jridgewell+trace-mapping@0.3.9/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.traceMapping = {}, global2.sourcemapCodec, global2.resolveURI));
    })(exports, function(exports2, sourcemapCodec, resolveUri) {
      "use strict";
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var resolveUri__default = _interopDefaultLegacy(resolveUri);
      function resolve27(input, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri__default["default"](input, base);
      }
      function stripFilename(path3) {
        if (!path3)
          return "";
        const index = path3.lastIndexOf("/");
        return path3.slice(0, index + 1);
      }
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      let found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; i++, index++) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; i--, index--) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
              continue;
            const sourceIndex = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex];
            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            insert3(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert3(array, index, value2) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value2;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map4, mapUrl) {
        const parsed = typeof map4 === "string" ? JSON.parse(map4) : map4;
        if (!("sections" in parsed))
          return new TraceMap(parsed, mapUrl);
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const { sections } = parsed;
        let i = 0;
        for (; i < sections.length - 1; i++) {
          const no = sections[i + 1].offset;
          addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, no.line, no.column);
        }
        if (sections.length > 0) {
          addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, Infinity, Infinity);
        }
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings
        };
        return exports2.presortedDecodedMap(joined);
      };
      function addSection(section, mapUrl, mappings, sources, sourcesContent, names, stopLine, stopColumn) {
        const map4 = AnyMap(section.map, mapUrl);
        const { line: lineOffset, column: columnOffset } = section.offset;
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = exports2.decodedMappings(map4);
        const { resolvedSources } = map4;
        append3(sources, resolvedSources);
        append3(sourcesContent, map4.sourcesContent || fillSourcesContent(resolvedSources.length));
        append3(names, map4.names);
        for (let i = mappings.length; i <= lineOffset; i++)
          mappings.push([]);
        const stopI = stopLine - lineOffset;
        const len = Math.min(decoded.length, stopI + 1);
        for (let i = 0; i < len; i++) {
          const line = decoded[i];
          const out = i === 0 ? mappings[lineOffset] : mappings[lineOffset + i] = [];
          const cOffset = i === 0 ? columnOffset : 0;
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (i === stopI && column >= stopColumn)
              break;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            if (seg.length === 4) {
              out.push([column, sourcesIndex, sourceLine, sourceColumn]);
              continue;
            }
            out.push([column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append3(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function fillSourcesContent(len) {
        const sourcesContent = [];
        for (let i = 0; i < len; i++)
          sourcesContent[i] = null;
        return sourcesContent;
      }
      const INVALID_ORIGINAL_MAPPING = Object.freeze({
        source: null,
        line: null,
        column: null,
        name: null
      });
      const INVALID_GENERATED_MAPPING = Object.freeze({
        line: null,
        column: null
      });
      const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND = -1;
      const GREATEST_LOWER_BOUND = 1;
      exports2.encodedMappings = void 0;
      exports2.decodedMappings = void 0;
      exports2.traceSegment = void 0;
      exports2.originalPositionFor = void 0;
      exports2.generatedPositionFor = void 0;
      exports2.eachMapping = void 0;
      exports2.presortedDecodedMap = void 0;
      exports2.decodedMap = void 0;
      exports2.encodedMap = void 0;
      class TraceMap {
        constructor(map4, mapUrl) {
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
          const isString = typeof map4 === "string";
          if (!isString && map4.constructor === TraceMap)
            return map4;
          const parsed = isString ? JSON.parse(map4) : map4;
          const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version;
          this.file = file;
          this.names = names;
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          if (sourceRoot || mapUrl) {
            const from = resolve27(sourceRoot || "", stripFilename(mapUrl));
            this.resolvedSources = sources.map((s) => resolve27(s || "", from));
          } else {
            this.resolvedSources = sources.map((s) => s || "");
          }
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          }
        }
      }
      (() => {
        exports2.encodedMappings = (map4) => {
          var _a;
          return (_a = map4._encoded) !== null && _a !== void 0 ? _a : map4._encoded = sourcemapCodec.encode(map4._decoded);
        };
        exports2.decodedMappings = (map4) => {
          return map4._decoded || (map4._decoded = sourcemapCodec.decode(map4._encoded));
        };
        exports2.traceSegment = (map4, line, column) => {
          const decoded = exports2.decodedMappings(map4);
          if (line >= decoded.length)
            return null;
          return traceSegmentInternal(decoded[line], map4._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        };
        exports2.originalPositionFor = (map4, { line, column, bias }) => {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const decoded = exports2.decodedMappings(map4);
          if (line >= decoded.length)
            return INVALID_ORIGINAL_MAPPING;
          const segment = traceSegmentInternal(decoded[line], map4._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
          if (segment == null)
            return INVALID_ORIGINAL_MAPPING;
          if (segment.length == 1)
            return INVALID_ORIGINAL_MAPPING;
          const { names, resolvedSources } = map4;
          return {
            source: resolvedSources[segment[SOURCES_INDEX]],
            line: segment[SOURCE_LINE] + 1,
            column: segment[SOURCE_COLUMN],
            name: segment.length === 5 ? names[segment[NAMES_INDEX]] : null
          };
        };
        exports2.generatedPositionFor = (map4, { source, line, column, bias }) => {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const { sources, resolvedSources } = map4;
          let sourceIndex = sources.indexOf(source);
          if (sourceIndex === -1)
            sourceIndex = resolvedSources.indexOf(source);
          if (sourceIndex === -1)
            return INVALID_GENERATED_MAPPING;
          const generated = map4._bySources || (map4._bySources = buildBySources(exports2.decodedMappings(map4), map4._bySourceMemos = sources.map(memoizedState)));
          const memos = map4._bySourceMemos;
          const segments = generated[sourceIndex][line];
          if (segments == null)
            return INVALID_GENERATED_MAPPING;
          const segment = traceSegmentInternal(segments, memos[sourceIndex], line, column, bias || GREATEST_LOWER_BOUND);
          if (segment == null)
            return INVALID_GENERATED_MAPPING;
          return {
            line: segment[REV_GENERATED_LINE] + 1,
            column: segment[REV_GENERATED_COLUMN]
          };
        };
        exports2.eachMapping = (map4, cb) => {
          const decoded = exports2.decodedMappings(map4);
          const { names, resolvedSources } = map4;
          for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              const generatedLine = i + 1;
              const generatedColumn = seg[0];
              let source = null;
              let originalLine = null;
              let originalColumn = null;
              let name = null;
              if (seg.length !== 1) {
                source = resolvedSources[seg[1]];
                originalLine = seg[2] + 1;
                originalColumn = seg[3];
              }
              if (seg.length === 5)
                name = names[seg[4]];
              cb({
                generatedLine,
                generatedColumn,
                source,
                originalLine,
                originalColumn,
                name
              });
            }
          }
        };
        exports2.presortedDecodedMap = (map4, mapUrl) => {
          const clone3 = Object.assign({}, map4);
          clone3.mappings = [];
          const tracer = new TraceMap(clone3, mapUrl);
          tracer._decoded = map4.mappings;
          return tracer;
        };
        exports2.decodedMap = (map4) => {
          return {
            version: 3,
            file: map4.file,
            names: map4.names,
            sourceRoot: map4.sourceRoot,
            sources: map4.sources,
            sourcesContent: map4.sourcesContent,
            mappings: exports2.decodedMappings(map4)
          };
        };
        exports2.encodedMap = (map4) => {
          return {
            version: 3,
            file: map4.file,
            names: map4.names,
            sourceRoot: map4.sourceRoot,
            sources: map4.sources,
            sourcesContent: map4.sourcesContent,
            mappings: exports2.encodedMappings(map4)
          };
        };
      })();
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND)
          index++;
        if (index === -1 || index === segments.length)
          return null;
        return segments[index];
      }
      exports2.AnyMap = AnyMap;
      exports2.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports2.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports2.TraceMap = TraceMap;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/.pnpm/@cspotcode+source-map-support@0.8.1/node_modules/@cspotcode/source-map-support/source-map-support.js
var require_source_map_support = __commonJS({
  "node_modules/.pnpm/@cspotcode+source-map-support@0.8.1/node_modules/@cspotcode/source-map-support/source-map-support.js"(exports, module) {
    var { TraceMap, originalPositionFor, AnyMap } = require_trace_mapping_umd();
    var path3 = require_path();
    var { fileURLToPath, pathToFileURL } = require_url();
    var util = require_util();
    var fs;
    try {
      fs = require_fs();
      if (!fs.existsSync || !fs.readFileSync) {
        fs = null;
      }
    } catch (err) {
    }
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    var sharedDataVersion = 1;
    function initializeSharedData(defaults) {
      var sharedDataKey = "source-map-support/sharedData";
      if (typeof Symbol !== "undefined") {
        sharedDataKey = Symbol.for(sharedDataKey);
      }
      var sharedData2 = this[sharedDataKey];
      if (!sharedData2) {
        sharedData2 = { version: sharedDataVersion };
        if (Object.defineProperty) {
          Object.defineProperty(this, sharedDataKey, { value: sharedData2 });
        } else {
          this[sharedDataKey] = sharedData2;
        }
      }
      if (sharedDataVersion !== sharedData2.version) {
        throw new Error("Multiple incompatible instances of source-map-support were loaded");
      }
      for (var key in defaults) {
        if (!(key in sharedData2)) {
          sharedData2[key] = defaults[key];
        }
      }
      return sharedData2;
    }
    var sharedData = initializeSharedData({
      // Only install once if called multiple times
      // Remember how the environment looked before installation so we can restore if able
      /** @type {HookState} */
      errorPrepareStackTraceHook: void 0,
      /** @type {HookState} */
      processEmitHook: void 0,
      /** @type {HookState} */
      moduleResolveFilenameHook: void 0,
      /** @type {Array<(request: string, parent: any, isMain: boolean, options: any, redirectedRequest: string) => void>} */
      onConflictingLibraryRedirectArr: [],
      // If true, the caches are reset before a stack trace formatting operation
      emptyCacheBetweenOperations: false,
      // Maps a file path to a string containing the file contents
      fileContentsCache: /* @__PURE__ */ Object.create(null),
      // Maps a file path to a source map for that file
      /** @type {Record<string, {url: string, map: TraceMap}} */
      sourceMapCache: /* @__PURE__ */ Object.create(null),
      // Priority list of retrieve handlers
      retrieveFileHandlers: [],
      retrieveMapHandlers: [],
      // Priority list of internally-implemented handlers.
      // When resetting state, we must keep these.
      internalRetrieveFileHandlers: [],
      internalRetrieveMapHandlers: []
    });
    var environment = "auto";
    var reSourceMap = /^data:application\/json[^,]+base64,/;
    function isInBrowser() {
      if (environment === "browser")
        return true;
      if (environment === "node")
        return false;
      return typeof window !== "undefined" && typeof XMLHttpRequest === "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
    }
    function hasGlobalProcessEventEmitter() {
      return typeof process === "object" && process !== null && typeof process.on === "function";
    }
    function tryFileURLToPath(v) {
      if (isFileUrl(v)) {
        return fileURLToPath(v);
      }
      return v;
    }
    function isFileUrl(input) {
      return input.startsWith("file:");
    }
    function isAbsoluteUrl(input) {
      return schemeRegex.test(input);
    }
    var schemeRegex = /^[\w+.-]+:\/\//;
    function isSchemeRelativeUrl(input) {
      return input.startsWith("//");
    }
    function getCacheKey(pathOrFileUrl) {
      if (pathOrFileUrl.startsWith("node:"))
        return pathOrFileUrl;
      if (isFileUrl(pathOrFileUrl)) {
        return new URL(pathOrFileUrl).toString();
      } else {
        try {
          return pathToFileURL(pathOrFileUrl).toString();
        } catch {
          return pathOrFileUrl;
        }
      }
    }
    function getFileContentsCache(key) {
      return sharedData.fileContentsCache[getCacheKey(key)];
    }
    function hasFileContentsCacheFromKey(key) {
      return Object.prototype.hasOwnProperty.call(sharedData.fileContentsCache, key);
    }
    function getFileContentsCacheFromKey(key) {
      return sharedData.fileContentsCache[key];
    }
    function setFileContentsCache(key, value2) {
      return sharedData.fileContentsCache[getCacheKey(key)] = value2;
    }
    function getSourceMapCache(key) {
      return sharedData.sourceMapCache[getCacheKey(key)];
    }
    function setSourceMapCache(key, value2) {
      return sharedData.sourceMapCache[getCacheKey(key)] = value2;
    }
    function clearCaches() {
      sharedData.fileContentsCache = /* @__PURE__ */ Object.create(null);
      sharedData.sourceMapCache = /* @__PURE__ */ Object.create(null);
    }
    function handlerExec(list, internalList) {
      return function(arg) {
        for (var i = 0; i < list.length; i++) {
          var ret = list[i](arg);
          if (ret) {
            return ret;
          }
        }
        for (var i = 0; i < internalList.length; i++) {
          var ret = internalList[i](arg);
          if (ret) {
            return ret;
          }
        }
        return null;
      };
    }
    var retrieveFile = handlerExec(sharedData.retrieveFileHandlers, sharedData.internalRetrieveFileHandlers);
    sharedData.internalRetrieveFileHandlers.push(function(path4) {
      path4 = path4.trim();
      if (/^file:/.test(path4)) {
        path4 = path4.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
          return drive ? "" : (
            // file:///C:/dir/file -> C:/dir/file
            "/"
          );
        });
      }
      const key = getCacheKey(path4);
      if (hasFileContentsCacheFromKey(key)) {
        return getFileContentsCacheFromKey(key);
      }
      var contents = "";
      try {
        if (!fs) {
          var xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            path4,
            /** async */
            false
          );
          xhr.send(null);
          if (xhr.readyState === 4 && xhr.status === 200) {
            contents = xhr.responseText;
          }
        } else if (fs.existsSync(path4)) {
          contents = fs.readFileSync(path4, "utf8");
        }
      } catch (er) {
      }
      return setFileContentsCache(path4, contents);
    });
    function supportRelativeURL(file, url) {
      if (!file)
        return url;
      try {
        if (isAbsoluteUrl(file) || isSchemeRelativeUrl(file)) {
          if (isAbsoluteUrl(url) || isSchemeRelativeUrl(url)) {
            return new URL(url, file).toString();
          }
          if (path3.isAbsolute(url)) {
            return new URL(pathToFileURL(url), file).toString();
          }
          return new URL(url.replace(/\\/g, "/"), file).toString();
        }
        if (path3.isAbsolute(file)) {
          if (isFileUrl(url)) {
            return fileURLToPath(url);
          }
          if (isSchemeRelativeUrl(url)) {
            return fileURLToPath(new URL(url, "file://"));
          }
          if (isAbsoluteUrl(url)) {
            return url;
          }
          if (path3.isAbsolute(url)) {
            return path3.normalize(url);
          }
          return path3.join(file, "..", decodeURI(url));
        }
        if (isAbsoluteUrl(url) || isSchemeRelativeUrl(url)) {
          return url;
        }
        return path3.join(file, "..", url);
      } catch (e) {
        return url;
      }
    }
    function matchStyleOfPathOrUrl(matchStyleOf, pathOrUrl) {
      try {
        if (isAbsoluteUrl(matchStyleOf) || isSchemeRelativeUrl(matchStyleOf)) {
          if (isAbsoluteUrl(pathOrUrl) || isSchemeRelativeUrl(pathOrUrl))
            return pathOrUrl;
          if (path3.isAbsolute(pathOrUrl))
            return pathToFileURL(pathOrUrl).toString();
        } else if (path3.isAbsolute(matchStyleOf)) {
          if (isAbsoluteUrl(pathOrUrl) || isSchemeRelativeUrl(pathOrUrl)) {
            return fileURLToPath(new URL(pathOrUrl, "file://"));
          }
        }
        return pathOrUrl;
      } catch (e) {
        return pathOrUrl;
      }
    }
    function retrieveSourceMapURL(source) {
      var fileData;
      if (isInBrowser()) {
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", source, false);
          xhr.send(null);
          fileData = xhr.readyState === 4 ? xhr.responseText : null;
          var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
          if (sourceMapHeader) {
            return sourceMapHeader;
          }
        } catch (e) {
        }
      }
      fileData = retrieveFile(tryFileURLToPath(source));
      var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
      var lastMatch, match3;
      while (match3 = re.exec(fileData))
        lastMatch = match3;
      if (!lastMatch)
        return null;
      return lastMatch[1];
    }
    var retrieveSourceMap = handlerExec(sharedData.retrieveMapHandlers, sharedData.internalRetrieveMapHandlers);
    sharedData.internalRetrieveMapHandlers.push(function(source) {
      var sourceMappingURL = retrieveSourceMapURL(source);
      if (!sourceMappingURL)
        return null;
      var sourceMapData;
      if (reSourceMap.test(sourceMappingURL)) {
        var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
        sourceMapData = Buffer.from(rawData, "base64").toString();
        sourceMappingURL = source;
      } else {
        sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
        sourceMapData = retrieveFile(tryFileURLToPath(sourceMappingURL));
      }
      if (!sourceMapData) {
        return null;
      }
      return {
        url: sourceMappingURL,
        map: sourceMapData
      };
    });
    function mapSourcePosition(position) {
      var sourceMap = getSourceMapCache(position.source);
      if (!sourceMap) {
        var urlAndMap = retrieveSourceMap(position.source);
        if (urlAndMap) {
          sourceMap = setSourceMapCache(position.source, {
            url: urlAndMap.url,
            map: new AnyMap(urlAndMap.map, urlAndMap.url)
          });
          sourceMap.map.resolvedSources = sourceMap.map.sources.map((s) => supportRelativeURL(sourceMap.url, s));
          if (sourceMap.map.sourcesContent) {
            sourceMap.map.resolvedSources.forEach(function(resolvedSource, i) {
              var contents = sourceMap.map.sourcesContent[i];
              if (contents) {
                setFileContentsCache(resolvedSource, contents);
              }
            });
          }
        } else {
          sourceMap = setSourceMapCache(position.source, {
            url: null,
            map: null
          });
        }
      }
      if (sourceMap && sourceMap.map) {
        var originalPosition = originalPositionFor(sourceMap.map, position);
        if (originalPosition.source !== null) {
          originalPosition.source = matchStyleOfPathOrUrl(
            position.source,
            originalPosition.source
          );
          return originalPosition;
        }
      }
      return position;
    }
    function mapEvalOrigin(origin) {
      var match3 = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
      if (match3) {
        var position = mapSourcePosition({
          source: match3[2],
          line: +match3[3],
          column: match3[4] - 1
        });
        return "eval at " + match3[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
      }
      match3 = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
      if (match3) {
        return "eval at " + match3[1] + " (" + mapEvalOrigin(match3[2]) + ")";
      }
      return origin;
    }
    function CallSiteToString() {
      var fileName;
      var fileLocation = "";
      if (this.isNative()) {
        fileLocation = "native";
      } else {
        fileName = this.getScriptNameOrSourceURL();
        if (!fileName && this.isEval()) {
          fileLocation = this.getEvalOrigin();
          fileLocation += ", ";
        }
        if (fileName) {
          fileLocation += fileName;
        } else {
          fileLocation += "<anonymous>";
        }
        var lineNumber = this.getLineNumber();
        if (lineNumber != null) {
          fileLocation += ":" + lineNumber;
          var columnNumber = this.getColumnNumber();
          if (columnNumber) {
            fileLocation += ":" + columnNumber;
          }
        }
      }
      var line = "";
      var isAsync = this.isAsync ? this.isAsync() : false;
      if (isAsync) {
        line += "async ";
        var isPromiseAll = this.isPromiseAll ? this.isPromiseAll() : false;
        var isPromiseAny = this.isPromiseAny ? this.isPromiseAny() : false;
        if (isPromiseAny || isPromiseAll) {
          line += isPromiseAll ? "Promise.all (index " : "Promise.any (index ";
          var promiseIndex = this.getPromiseIndex();
          line += promiseIndex + ")";
        }
      }
      var functionName = this.getFunctionName();
      var addSuffix = true;
      var isConstructor = this.isConstructor();
      var isMethodCall = !(this.isToplevel() || isConstructor);
      if (isMethodCall) {
        var typeName = this.getTypeName();
        if (typeName === "[object Object]") {
          typeName = "null";
        }
        var methodName = this.getMethodName();
        if (functionName) {
          if (typeName && functionName.indexOf(typeName) != 0) {
            line += typeName + ".";
          }
          line += functionName;
          if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
            line += " [as " + methodName + "]";
          }
        } else {
          line += typeName + "." + (methodName || "<anonymous>");
        }
      } else if (isConstructor) {
        line += "new " + (functionName || "<anonymous>");
      } else if (functionName) {
        line += functionName;
      } else {
        line += fileLocation;
        addSuffix = false;
      }
      if (addSuffix) {
        line += " (" + fileLocation + ")";
      }
      return line;
    }
    function cloneCallSite(frame) {
      var object = {};
      Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
        object[name] = /^(?:is|get)/.test(name) ? function() {
          return frame[name].call(frame);
        } : frame[name];
      });
      object.toString = CallSiteToString;
      return object;
    }
    function wrapCallSite(frame, state) {
      if (state === void 0) {
        state = { nextPosition: null, curPosition: null };
      }
      if (frame.isNative()) {
        state.curPosition = null;
        return frame;
      }
      var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
      if (source) {
        if (source.startsWith("wasm://")) {
          state.curPosition = null;
          return frame;
        }
        var line = frame.getLineNumber();
        var column = frame.getColumnNumber() - 1;
        var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
        var headerLength = noHeader.test(process.version) ? 0 : 62;
        if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
          column -= headerLength;
        }
        var position = mapSourcePosition({
          source,
          line,
          column
        });
        state.curPosition = position;
        frame = cloneCallSite(frame);
        var originalFunctionName = frame.getFunctionName;
        frame.getFunctionName = function() {
          if (state.nextPosition == null) {
            return originalFunctionName();
          }
          return state.nextPosition.name || originalFunctionName();
        };
        frame.getFileName = function() {
          return position.source;
        };
        frame.getLineNumber = function() {
          return position.line;
        };
        frame.getColumnNumber = function() {
          return position.column + 1;
        };
        frame.getScriptNameOrSourceURL = function() {
          return position.source;
        };
        return frame;
      }
      var origin = frame.isEval() && frame.getEvalOrigin();
      if (origin) {
        origin = mapEvalOrigin(origin);
        frame = cloneCallSite(frame);
        frame.getEvalOrigin = function() {
          return origin;
        };
        return frame;
      }
      return frame;
    }
    var kIsNodeError = void 0;
    try {
      path3.resolve(123);
    } catch (e) {
      const symbols = Object.getOwnPropertySymbols(e);
      const symbol = symbols.find(function(s) {
        return s.toString().indexOf("kIsNodeError") >= 0;
      });
      if (symbol)
        kIsNodeError = symbol;
    }
    var ErrorPrototypeToString = (err) => Error.prototype.toString.call(err);
    function createPrepareStackTrace(hookState) {
      return prepareStackTrace;
      function prepareStackTrace(error, stack) {
        if (!hookState.enabled)
          return hookState.originalValue.apply(this, arguments);
        if (sharedData.emptyCacheBetweenOperations) {
          clearCaches();
        }
        var errorString;
        if (kIsNodeError) {
          if (kIsNodeError in error) {
            errorString = `${error.name} [${error.code}]: ${error.message}`;
          } else {
            errorString = ErrorPrototypeToString(error);
          }
        } else {
          var name = error.name || "Error";
          var message = error.message || "";
          errorString = message ? name + ": " + message : name;
        }
        var state = { nextPosition: null, curPosition: null };
        var processedStack = [];
        for (var i = stack.length - 1; i >= 0; i--) {
          processedStack.push("\n    at " + wrapCallSite(stack[i], state));
          state.nextPosition = state.curPosition;
        }
        state.curPosition = state.nextPosition = null;
        return errorString + processedStack.reverse().join("");
      }
    }
    function getErrorSource(error) {
      var match3 = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
      if (match3) {
        var source = match3[1];
        var line = +match3[2];
        var column = +match3[3];
        var contents = getFileContentsCache(source);
        const sourceAsPath = tryFileURLToPath(source);
        if (!contents && fs && fs.existsSync(sourceAsPath)) {
          try {
            contents = fs.readFileSync(sourceAsPath, "utf8");
          } catch (er) {
            contents = "";
          }
        }
        if (contents) {
          var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
          if (code) {
            return source + ":" + line + "\n" + code + "\n" + new Array(column).join(" ") + "^";
          }
        }
      }
      return null;
    }
    function printFatalErrorUponExit(error) {
      var source = getErrorSource(error);
      if (process.stderr._handle && process.stderr._handle.setBlocking) {
        process.stderr._handle.setBlocking(true);
      }
      if (source) {
        console.error(source);
      }
      console.error(
        util.inspect(error, {
          customInspect: false,
          colors: process.stderr.isTTY
        })
      );
    }
    function shimEmitUncaughtException() {
      const originalValue = process.emit;
      var hook = sharedData.processEmitHook = {
        enabled: true,
        originalValue,
        installedValue: void 0
      };
      var isTerminatingDueToFatalException = false;
      var fatalException;
      process.emit = sharedData.processEmitHook.installedValue = function(type3) {
        const hadListeners = originalValue.apply(this, arguments);
        if (hook.enabled) {
          if (type3 === "uncaughtException" && !hadListeners) {
            isTerminatingDueToFatalException = true;
            fatalException = arguments[1];
            process.exit(1);
          }
          if (type3 === "exit" && isTerminatingDueToFatalException) {
            printFatalErrorUponExit(fatalException);
          }
        }
        return hadListeners;
      };
    }
    var originalRetrieveFileHandlers = sharedData.retrieveFileHandlers.slice(0);
    var originalRetrieveMapHandlers = sharedData.retrieveMapHandlers.slice(0);
    exports.wrapCallSite = wrapCallSite;
    exports.getErrorSource = getErrorSource;
    exports.mapSourcePosition = mapSourcePosition;
    exports.retrieveSourceMap = retrieveSourceMap;
    exports.install = function(options) {
      options = options || {};
      if (options.environment) {
        environment = options.environment;
        if (["node", "browser", "auto"].indexOf(environment) === -1) {
          throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
        }
      }
      var Module = dynamicRequire(module, "module");
      const { redirectConflictingLibrary = true, onConflictingLibraryRedirect } = options;
      if (redirectConflictingLibrary) {
        if (!sharedData.moduleResolveFilenameHook) {
          const originalValue = Module._resolveFilename;
          const moduleResolveFilenameHook = sharedData.moduleResolveFilenameHook = {
            enabled: true,
            originalValue,
            installedValue: void 0
          };
          Module._resolveFilename = sharedData.moduleResolveFilenameHook.installedValue = function(request, parent, isMain, options2) {
            if (moduleResolveFilenameHook.enabled) {
              let requestRedirect;
              if (request === "source-map-support") {
                requestRedirect = "./";
              } else if (request === "source-map-support/register") {
                requestRedirect = "./register";
              }
              if (requestRedirect !== void 0) {
                const newRequest = __require.resolve(requestRedirect);
                for (const cb of sharedData.onConflictingLibraryRedirectArr) {
                  cb(request, parent, isMain, options2, newRequest);
                }
                request = newRequest;
              }
            }
            return originalValue.call(this, request, parent, isMain, options2);
          };
        }
        if (onConflictingLibraryRedirect) {
          sharedData.onConflictingLibraryRedirectArr.push(onConflictingLibraryRedirect);
        }
      }
      if (options.retrieveFile) {
        if (options.overrideRetrieveFile) {
          sharedData.retrieveFileHandlers.length = 0;
        }
        sharedData.retrieveFileHandlers.unshift(options.retrieveFile);
      }
      if (options.retrieveSourceMap) {
        if (options.overrideRetrieveSourceMap) {
          sharedData.retrieveMapHandlers.length = 0;
        }
        sharedData.retrieveMapHandlers.unshift(options.retrieveSourceMap);
      }
      if (options.hookRequire && !isInBrowser()) {
        var $compile = Module.prototype._compile;
        if (!$compile.__sourceMapSupport) {
          Module.prototype._compile = function(content, filename) {
            setFileContentsCache(filename, content);
            setSourceMapCache(filename, void 0);
            return $compile.call(this, content, filename);
          };
          Module.prototype._compile.__sourceMapSupport = true;
        }
      }
      if (!sharedData.emptyCacheBetweenOperations) {
        sharedData.emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : false;
      }
      if (!sharedData.errorPrepareStackTraceHook) {
        const originalValue = Error.prepareStackTrace;
        sharedData.errorPrepareStackTraceHook = {
          enabled: true,
          originalValue,
          installedValue: void 0
        };
        Error.prepareStackTrace = sharedData.errorPrepareStackTraceHook.installedValue = createPrepareStackTrace(sharedData.errorPrepareStackTraceHook);
      }
      if (!sharedData.processEmitHook) {
        var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : true;
        try {
          var worker_threads = dynamicRequire(module, "worker_threads");
          if (worker_threads.isMainThread === false) {
            installHandler = false;
          }
        } catch (e) {
        }
        if (installHandler && hasGlobalProcessEventEmitter()) {
          shimEmitUncaughtException();
        }
      }
    };
    exports.uninstall = function() {
      if (sharedData.processEmitHook) {
        sharedData.processEmitHook.enabled = false;
        if (process.emit === sharedData.processEmitHook.installedValue) {
          process.emit = sharedData.processEmitHook.originalValue;
        }
        sharedData.processEmitHook = void 0;
      }
      if (sharedData.errorPrepareStackTraceHook) {
        sharedData.errorPrepareStackTraceHook.enabled = false;
        if (Error.prepareStackTrace === sharedData.errorPrepareStackTraceHook.installedValue || typeof sharedData.errorPrepareStackTraceHook.originalValue !== "function") {
          Error.prepareStackTrace = sharedData.errorPrepareStackTraceHook.originalValue;
        }
        sharedData.errorPrepareStackTraceHook = void 0;
      }
      if (sharedData.moduleResolveFilenameHook) {
        sharedData.moduleResolveFilenameHook.enabled = false;
        var Module = dynamicRequire(module, "module");
        if (Module._resolveFilename === sharedData.moduleResolveFilenameHook.installedValue) {
          Module._resolveFilename = sharedData.moduleResolveFilenameHook.originalValue;
        }
        sharedData.moduleResolveFilenameHook = void 0;
      }
      sharedData.onConflictingLibraryRedirectArr.length = 0;
    };
    exports.resetRetrieveHandlers = function() {
      sharedData.retrieveFileHandlers.length = 0;
      sharedData.retrieveMapHandlers.length = 0;
    };
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-modules-esm-resolve.js
var require_node_internal_modules_esm_resolve = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-modules-esm-resolve.js"(exports, module) {
    "use strict";
    var { versionGteLt } = require_util4();
    var builtinModuleProtocol = versionGteLt(process.versions.node, "14.13.1") || versionGteLt(process.versions.node, "12.20.0", "13.0.0") ? "node:" : "nodejs:";
    var {
      ArrayIsArray,
      ArrayPrototypeJoin,
      ArrayPrototypeShift,
      JSONParse,
      JSONStringify,
      ObjectFreeze,
      ObjectGetOwnPropertyNames,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeTest,
      SafeMap,
      SafeSet,
      StringPrototypeEndsWith,
      StringPrototypeIndexOf,
      StringPrototypeLastIndexOf,
      StringPrototypeReplace,
      StringPrototypeSlice,
      StringPrototypeSplit,
      StringPrototypeStartsWith,
      StringPrototypeSubstr
    } = require_node_primordials();
    var Module = require_module();
    var { NativeModule } = require_node_nativemodule();
    var {
      realpathSync,
      statSync,
      Stats
    } = require_fs();
    var { getOptionValue } = require_node_options();
    var policy = null;
    var { sep, relative } = require_path();
    var preserveSymlinks = getOptionValue("--preserve-symlinks");
    var preserveSymlinksMain = getOptionValue("--preserve-symlinks-main");
    var typeFlag = getOptionValue("--input-type");
    var { URL: URL2, pathToFileURL, fileURLToPath } = require_url();
    var {
      ERR_INPUT_TYPE_NOT_ALLOWED,
      ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE2,
      ERR_INVALID_MODULE_SPECIFIER,
      ERR_INVALID_PACKAGE_CONFIG,
      ERR_INVALID_PACKAGE_TARGET,
      ERR_MANIFEST_DEPENDENCY_MISSING,
      ERR_MODULE_NOT_FOUND,
      ERR_PACKAGE_IMPORT_NOT_DEFINED,
      ERR_PACKAGE_PATH_NOT_EXPORTED,
      ERR_UNSUPPORTED_DIR_IMPORT,
      ERR_UNSUPPORTED_ESM_URL_SCHEME
      // } = require('internal/errors').codes;
    } = require_node_internal_errors().codes;
    var CJSModule = Module;
    var packageJsonReader = require_node_internal_modules_package_json_reader();
    var userConditions = getOptionValue("--conditions");
    var DEFAULT_CONDITIONS = ObjectFreeze(["node", "import", ...userConditions]);
    var DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);
    var pendingDeprecation = getOptionValue("--pending-deprecation");
    function createResolve(opts) {
      const { preferTsExts, tsNodeExperimentalSpecifierResolution, extensions } = opts;
      const esrnExtensions = extensions.experimentalSpecifierResolutionAddsIfOmitted;
      const { legacyMainResolveAddsIfOmitted, replacementsForCjs, replacementsForJs, replacementsForMjs, replacementsForJsx } = extensions;
      const experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution != null ? tsNodeExperimentalSpecifierResolution : getOptionValue("--experimental-specifier-resolution");
      const emittedPackageWarnings = new SafeSet();
      function emitFolderMapDeprecation(match3, pjsonUrl, isExports, base) {
        const pjsonPath = fileURLToPath(pjsonUrl);
        if (!pendingDeprecation) {
          const nodeModulesIndex = StringPrototypeLastIndexOf(
            pjsonPath,
            "/node_modules/"
          );
          if (nodeModulesIndex !== -1) {
            const afterNodeModulesPath = StringPrototypeSlice(
              pjsonPath,
              nodeModulesIndex + 14,
              -13
            );
            try {
              const { packageSubpath } = parsePackageName(afterNodeModulesPath);
              if (packageSubpath === ".")
                return;
            } catch {
            }
          }
        }
        if (emittedPackageWarnings.has(pjsonPath + "|" + match3))
          return;
        emittedPackageWarnings.add(pjsonPath + "|" + match3);
        process.emitWarning(
          `Use of deprecated folder mapping "${match3}" in the ${isExports ? '"exports"' : '"imports"'} field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ""}.
Update this package.json to use a subpath pattern like "${match3}*".`,
          "DeprecationWarning",
          "DEP0148"
        );
      }
      function getConditionsSet(conditions) {
        if (conditions !== void 0 && conditions !== DEFAULT_CONDITIONS) {
          if (!ArrayIsArray(conditions)) {
            throw new ERR_INVALID_ARG_VALUE2(
              "conditions",
              conditions,
              "expected an array"
            );
          }
          return new SafeSet(conditions);
        }
        return DEFAULT_CONDITIONS_SET;
      }
      const realpathCache = new SafeMap();
      const packageJSONCache = new SafeMap();
      const statSupportsThrowIfNoEntry = versionGteLt(process.versions.node, "15.3.0") || versionGteLt(process.versions.node, "14.17.0", "15.0.0");
      const tryStatSync = statSupportsThrowIfNoEntry ? tryStatSyncWithoutErrors : tryStatSyncWithErrors;
      const statsIfNotFound = new Stats();
      function tryStatSyncWithoutErrors(path3) {
        const stats = statSync(path3, { throwIfNoEntry: false });
        if (stats != null)
          return stats;
        return statsIfNotFound;
      }
      function tryStatSyncWithErrors(path3) {
        try {
          return statSync(path3);
        } catch {
          return statsIfNotFound;
        }
      }
      function getPackageConfig(path3, specifier, base) {
        const existing = packageJSONCache.get(path3);
        if (existing !== void 0) {
          return existing;
        }
        const source = packageJsonReader.read(path3).string;
        if (source === void 0) {
          const packageConfig2 = {
            pjsonPath: path3,
            exists: false,
            main: void 0,
            name: void 0,
            type: "none",
            exports: void 0,
            imports: void 0
          };
          packageJSONCache.set(path3, packageConfig2);
          return packageConfig2;
        }
        let packageJSON;
        try {
          packageJSON = JSONParse(source);
        } catch (error) {
          throw new ERR_INVALID_PACKAGE_CONFIG(
            path3,
            (base ? `"${specifier}" from ` : "") + fileURLToPath(base || specifier),
            error.message
          );
        }
        let { imports, main, name, type: type3 } = packageJSON;
        const { exports: exports2 } = packageJSON;
        if (typeof imports !== "object" || imports === null)
          imports = void 0;
        if (typeof main !== "string")
          main = void 0;
        if (typeof name !== "string")
          name = void 0;
        if (type3 !== "module" && type3 !== "commonjs")
          type3 = "none";
        const packageConfig = {
          pjsonPath: path3,
          exists: true,
          main,
          name,
          type: type3,
          exports: exports2,
          imports
        };
        packageJSONCache.set(path3, packageConfig);
        return packageConfig;
      }
      function getPackageScopeConfig(resolved) {
        let packageJSONUrl = new URL2("./package.json", resolved);
        while (true) {
          const packageJSONPath2 = packageJSONUrl.pathname;
          if (StringPrototypeEndsWith(packageJSONPath2, "node_modules/package.json"))
            break;
          const packageConfig2 = getPackageConfig(
            fileURLToPath(packageJSONUrl),
            resolved
          );
          if (packageConfig2.exists)
            return packageConfig2;
          const lastPackageJSONUrl = packageJSONUrl;
          packageJSONUrl = new URL2("../package.json", packageJSONUrl);
          if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname)
            break;
        }
        const packageJSONPath = fileURLToPath(packageJSONUrl);
        const packageConfig = {
          pjsonPath: packageJSONPath,
          exists: false,
          main: void 0,
          name: void 0,
          type: "none",
          exports: void 0,
          imports: void 0
        };
        packageJSONCache.set(packageJSONPath, packageConfig);
        return packageConfig;
      }
      function fileExists(url) {
        return tryStatSync(fileURLToPath(url)).isFile();
      }
      function legacyMainResolve(packageJSONUrl, packageConfig, base) {
        let guess;
        if (packageConfig.main !== void 0) {
          if (guess = resolveReplacementExtensions(new URL2(`./${packageConfig.main}`, packageJSONUrl))) {
            return guess;
          }
          if (fileExists(guess = new URL2(
            `./${packageConfig.main}`,
            packageJSONUrl
          ))) {
            return guess;
          }
          for (const extension of legacyMainResolveAddsIfOmitted) {
            if (fileExists(guess = new URL2(
              `./${packageConfig.main}${extension}`,
              packageJSONUrl
            ))) {
              return guess;
            }
          }
          for (const extension of legacyMainResolveAddsIfOmitted) {
            if (fileExists(guess = new URL2(
              `./${packageConfig.main}/index${extension}`,
              packageJSONUrl
            ))) {
              return guess;
            }
          }
        }
        for (const extension of legacyMainResolveAddsIfOmitted) {
          if (fileExists(guess = new URL2(`./index${extension}`, packageJSONUrl))) {
            return guess;
          }
        }
        throw new ERR_MODULE_NOT_FOUND(
          fileURLToPath(new URL2(".", packageJSONUrl)),
          fileURLToPath(base)
        );
      }
      function resolveExtensionsWithTryExactName(search) {
        const resolvedReplacementExtension = resolveReplacementExtensions(search);
        if (resolvedReplacementExtension)
          return resolvedReplacementExtension;
        if (fileExists(search))
          return search;
        return resolveExtensions(search);
      }
      function resolveExtensions(search) {
        for (let i = 0; i < esrnExtensions.length; i++) {
          const extension = esrnExtensions[i];
          const guess = new URL2(`${search.pathname}${extension}`, search);
          if (fileExists(guess))
            return guess;
        }
        return void 0;
      }
      function resolveReplacementExtensions(search) {
        const lastDotIndex = search.pathname.lastIndexOf(".");
        if (lastDotIndex >= 0) {
          const ext = search.pathname.slice(lastDotIndex);
          if (ext === ".js" || ext === ".jsx" || ext === ".mjs" || ext === ".cjs") {
            const pathnameWithoutExtension = search.pathname.slice(0, lastDotIndex);
            const replacementExts = ext === ".js" ? replacementsForJs : ext === ".jsx" ? replacementsForJsx : ext === ".mjs" ? replacementsForMjs : replacementsForCjs;
            const guess = new URL2(search.toString());
            for (let i = 0; i < replacementExts.length; i++) {
              const extension = replacementExts[i];
              guess.pathname = `${pathnameWithoutExtension}${extension}`;
              if (fileExists(guess))
                return guess;
            }
          }
        }
        return void 0;
      }
      function resolveIndex(search) {
        return resolveExtensions(new URL2("index", search));
      }
      const encodedSepRegEx = /%2F|%2C/i;
      function finalizeResolution(resolved, base) {
        if (RegExpPrototypeTest(encodedSepRegEx, resolved.pathname))
          throw new ERR_INVALID_MODULE_SPECIFIER(
            resolved.pathname,
            'must not include encoded "/" or "\\" characters',
            fileURLToPath(base)
          );
        if (experimentalSpecifierResolution === "node") {
          const path4 = fileURLToPath(resolved);
          let file2 = resolveExtensionsWithTryExactName(resolved);
          if (file2 !== void 0)
            return file2;
          if (!StringPrototypeEndsWith(path4, "/")) {
            file2 = resolveIndex(new URL2(`${resolved}/`));
            if (file2 !== void 0)
              return file2;
          } else {
            return resolveIndex(resolved) || resolved;
          }
          throw new ERR_MODULE_NOT_FOUND(
            resolved.pathname,
            fileURLToPath(base),
            "module"
          );
        }
        const file = resolveReplacementExtensions(resolved) || resolved;
        const path3 = fileURLToPath(file);
        const stats = tryStatSync(StringPrototypeEndsWith(path3, "/") ? StringPrototypeSlice(path3, -1) : path3);
        if (stats.isDirectory()) {
          const err = new ERR_UNSUPPORTED_DIR_IMPORT(path3, fileURLToPath(base));
          err.url = String(resolved);
          throw err;
        } else if (!stats.isFile()) {
          throw new ERR_MODULE_NOT_FOUND(
            path3 || resolved.pathname,
            fileURLToPath(base),
            "module"
          );
        }
        return file;
      }
      function throwImportNotDefined(specifier, packageJSONUrl, base) {
        throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(
          specifier,
          packageJSONUrl && fileURLToPath(new URL2(".", packageJSONUrl)),
          fileURLToPath(base)
        );
      }
      function throwExportsNotFound(subpath, packageJSONUrl, base) {
        throw new ERR_PACKAGE_PATH_NOT_EXPORTED(
          fileURLToPath(new URL2(".", packageJSONUrl)),
          subpath,
          base && fileURLToPath(base)
        );
      }
      function throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {
        const reason = `request is not a valid subpath for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath(packageJSONUrl)}`;
        throw new ERR_INVALID_MODULE_SPECIFIER(
          subpath,
          reason,
          base && fileURLToPath(base)
        );
      }
      function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {
        if (typeof target === "object" && target !== null) {
          target = JSONStringify(target, null, "");
        } else {
          target = `${target}`;
        }
        throw new ERR_INVALID_PACKAGE_TARGET(
          fileURLToPath(new URL2(".", packageJSONUrl)),
          subpath,
          target,
          internal,
          base && fileURLToPath(base)
        );
      }
      const invalidSegmentRegEx = /(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/;
      const patternRegEx = /\*/g;
      function resolvePackageTargetString(target, subpath, match3, packageJSONUrl, base, pattern, internal, conditions) {
        if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
          throwInvalidPackageTarget(match3, target, packageJSONUrl, internal, base);
        if (!StringPrototypeStartsWith(target, "./")) {
          if (internal && !StringPrototypeStartsWith(target, "../") && !StringPrototypeStartsWith(target, "/")) {
            let isURL = false;
            try {
              new URL2(target);
              isURL = true;
            } catch {
            }
            if (!isURL) {
              const exportTarget = pattern ? StringPrototypeReplace(target, patternRegEx, subpath) : target + subpath;
              return packageResolve(exportTarget, packageJSONUrl, conditions);
            }
          }
          throwInvalidPackageTarget(match3, target, packageJSONUrl, internal, base);
        }
        if (RegExpPrototypeTest(invalidSegmentRegEx, StringPrototypeSlice(target, 2)))
          throwInvalidPackageTarget(match3, target, packageJSONUrl, internal, base);
        const resolved = new URL2(target, packageJSONUrl);
        const resolvedPath = resolved.pathname;
        const packagePath = new URL2(".", packageJSONUrl).pathname;
        if (!StringPrototypeStartsWith(resolvedPath, packagePath))
          throwInvalidPackageTarget(match3, target, packageJSONUrl, internal, base);
        if (subpath === "")
          return resolved;
        if (RegExpPrototypeTest(invalidSegmentRegEx, subpath))
          throwInvalidSubpath(match3 + subpath, packageJSONUrl, internal, base);
        if (pattern)
          return new URL2(StringPrototypeReplace(
            resolved.href,
            patternRegEx,
            subpath
          ));
        return new URL2(subpath, resolved);
      }
      function isArrayIndex(key) {
        const keyNum = +key;
        if (`${keyNum}` !== key)
          return false;
        return keyNum >= 0 && keyNum < 4294967295;
      }
      function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
        if (typeof target === "string") {
          return resolvePackageTargetString(
            target,
            subpath,
            packageSubpath,
            packageJSONUrl,
            base,
            pattern,
            internal,
            conditions
          );
        } else if (ArrayIsArray(target)) {
          if (target.length === 0)
            return null;
          let lastException;
          for (let i = 0; i < target.length; i++) {
            const targetItem = target[i];
            let resolved;
            try {
              resolved = resolvePackageTarget(
                packageJSONUrl,
                targetItem,
                subpath,
                packageSubpath,
                base,
                pattern,
                internal,
                conditions
              );
            } catch (e) {
              lastException = e;
              if (e.code === "ERR_INVALID_PACKAGE_TARGET")
                continue;
              throw e;
            }
            if (resolved === void 0)
              continue;
            if (resolved === null) {
              lastException = null;
              continue;
            }
            return resolved;
          }
          if (lastException === void 0 || lastException === null)
            return lastException;
          throw lastException;
        } else if (typeof target === "object" && target !== null) {
          const keys4 = ObjectGetOwnPropertyNames(target);
          for (let i = 0; i < keys4.length; i++) {
            const key = keys4[i];
            if (isArrayIndex(key)) {
              throw new ERR_INVALID_PACKAGE_CONFIG(
                fileURLToPath(packageJSONUrl),
                base,
                '"exports" cannot contain numeric property keys.'
              );
            }
          }
          for (let i = 0; i < keys4.length; i++) {
            const key = keys4[i];
            if (key === "default" || conditions.has(key)) {
              const conditionalTarget = target[key];
              const resolved = resolvePackageTarget(
                packageJSONUrl,
                conditionalTarget,
                subpath,
                packageSubpath,
                base,
                pattern,
                internal,
                conditions
              );
              if (resolved === void 0)
                continue;
              return resolved;
            }
          }
          return void 0;
        } else if (target === null) {
          return null;
        }
        throwInvalidPackageTarget(
          packageSubpath,
          target,
          packageJSONUrl,
          internal,
          base
        );
      }
      function isConditionalExportsMainSugar(exports2, packageJSONUrl, base) {
        if (typeof exports2 === "string" || ArrayIsArray(exports2))
          return true;
        if (typeof exports2 !== "object" || exports2 === null)
          return false;
        const keys4 = ObjectGetOwnPropertyNames(exports2);
        let isConditionalSugar = false;
        let i = 0;
        for (let j = 0; j < keys4.length; j++) {
          const key = keys4[j];
          const curIsConditionalSugar = key === "" || key[0] !== ".";
          if (i++ === 0) {
            isConditionalSugar = curIsConditionalSugar;
          } else if (isConditionalSugar !== curIsConditionalSugar) {
            throw new ERR_INVALID_PACKAGE_CONFIG(
              fileURLToPath(packageJSONUrl),
              base,
              `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
            );
          }
        }
        return isConditionalSugar;
      }
      function packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig, base, conditions) {
        let exports2 = packageConfig.exports;
        if (isConditionalExportsMainSugar(exports2, packageJSONUrl, base))
          exports2 = { ".": exports2 };
        if (ObjectPrototypeHasOwnProperty(exports2, packageSubpath)) {
          const target = exports2[packageSubpath];
          const resolved = resolvePackageTarget(
            packageJSONUrl,
            target,
            "",
            packageSubpath,
            base,
            false,
            false,
            conditions
          );
          if (resolved === null || resolved === void 0)
            throwExportsNotFound(packageSubpath, packageJSONUrl, base);
          return { resolved, exact: true };
        }
        let bestMatch = "";
        const keys4 = ObjectGetOwnPropertyNames(exports2);
        for (let i = 0; i < keys4.length; i++) {
          const key = keys4[i];
          if (key[key.length - 1] === "*" && StringPrototypeStartsWith(
            packageSubpath,
            StringPrototypeSlice(key, 0, -1)
          ) && packageSubpath.length >= key.length && key.length > bestMatch.length) {
            bestMatch = key;
          } else if (key[key.length - 1] === "/" && StringPrototypeStartsWith(packageSubpath, key) && key.length > bestMatch.length) {
            bestMatch = key;
          }
        }
        if (bestMatch) {
          const target = exports2[bestMatch];
          const pattern = bestMatch[bestMatch.length - 1] === "*";
          const subpath = StringPrototypeSubstr(packageSubpath, bestMatch.length - (pattern ? 1 : 0));
          const resolved = resolvePackageTarget(
            packageJSONUrl,
            target,
            subpath,
            bestMatch,
            base,
            pattern,
            false,
            conditions
          );
          if (resolved === null || resolved === void 0)
            throwExportsNotFound(packageSubpath, packageJSONUrl, base);
          if (!pattern)
            emitFolderMapDeprecation(bestMatch, packageJSONUrl, true, base);
          return { resolved, exact: pattern };
        }
        throwExportsNotFound(packageSubpath, packageJSONUrl, base);
      }
      function packageImportsResolve(name, base, conditions) {
        if (name === "#" || StringPrototypeStartsWith(name, "#/")) {
          const reason = "is not a valid internal imports specifier name";
          throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));
        }
        let packageJSONUrl;
        const packageConfig = getPackageScopeConfig(base);
        if (packageConfig.exists) {
          packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);
          const imports = packageConfig.imports;
          if (imports) {
            if (ObjectPrototypeHasOwnProperty(imports, name)) {
              const resolved = resolvePackageTarget(
                packageJSONUrl,
                imports[name],
                "",
                name,
                base,
                false,
                true,
                conditions
              );
              if (resolved !== null)
                return { resolved, exact: true };
            } else {
              let bestMatch = "";
              const keys4 = ObjectGetOwnPropertyNames(imports);
              for (let i = 0; i < keys4.length; i++) {
                const key = keys4[i];
                if (key[key.length - 1] === "*" && StringPrototypeStartsWith(
                  name,
                  StringPrototypeSlice(key, 0, -1)
                ) && name.length >= key.length && key.length > bestMatch.length) {
                  bestMatch = key;
                } else if (key[key.length - 1] === "/" && StringPrototypeStartsWith(name, key) && key.length > bestMatch.length) {
                  bestMatch = key;
                }
              }
              if (bestMatch) {
                const target = imports[bestMatch];
                const pattern = bestMatch[bestMatch.length - 1] === "*";
                const subpath = StringPrototypeSubstr(name, bestMatch.length - (pattern ? 1 : 0));
                const resolved = resolvePackageTarget(
                  packageJSONUrl,
                  target,
                  subpath,
                  bestMatch,
                  base,
                  pattern,
                  true,
                  conditions
                );
                if (resolved !== null) {
                  if (!pattern)
                    emitFolderMapDeprecation(bestMatch, packageJSONUrl, false, base);
                  return { resolved, exact: pattern };
                }
              }
            }
          }
        }
        throwImportNotDefined(name, packageJSONUrl, base);
      }
      function getPackageType(url) {
        const packageConfig = getPackageScopeConfig(url);
        return packageConfig.type;
      }
      function parsePackageName(specifier, base) {
        let separatorIndex = StringPrototypeIndexOf(specifier, "/");
        let validPackageName = true;
        let isScoped = false;
        if (specifier[0] === "@") {
          isScoped = true;
          if (separatorIndex === -1 || specifier.length === 0) {
            validPackageName = false;
          } else {
            separatorIndex = StringPrototypeIndexOf(
              specifier,
              "/",
              separatorIndex + 1
            );
          }
        }
        const packageName = separatorIndex === -1 ? specifier : StringPrototypeSlice(specifier, 0, separatorIndex);
        for (let i = 0; i < packageName.length; i++) {
          if (packageName[i] === "%" || packageName[i] === "\\") {
            validPackageName = false;
            break;
          }
        }
        if (!validPackageName) {
          throw new ERR_INVALID_MODULE_SPECIFIER(
            specifier,
            "is not a valid package name",
            fileURLToPath(base)
          );
        }
        const packageSubpath = "." + (separatorIndex === -1 ? "" : StringPrototypeSlice(specifier, separatorIndex));
        return { packageName, packageSubpath, isScoped };
      }
      function packageResolve(specifier, base, conditions) {
        const { packageName, packageSubpath, isScoped } = parsePackageName(specifier, base);
        const packageConfig = getPackageScopeConfig(base);
        if (packageConfig.exists) {
          const packageJSONUrl2 = pathToFileURL(packageConfig.pjsonPath);
          if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
            return packageExportsResolve(
              packageJSONUrl2,
              packageSubpath,
              packageConfig,
              base,
              conditions
            ).resolved;
          }
        }
        let packageJSONUrl = new URL2("./node_modules/" + packageName + "/package.json", base);
        let packageJSONPath = fileURLToPath(packageJSONUrl);
        let lastPath;
        do {
          const stat = tryStatSync(StringPrototypeSlice(
            packageJSONPath,
            0,
            packageJSONPath.length - 13
          ));
          if (!stat.isDirectory()) {
            lastPath = packageJSONPath;
            packageJSONUrl = new URL2((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJSONUrl);
            packageJSONPath = fileURLToPath(packageJSONUrl);
            continue;
          }
          const packageConfig2 = getPackageConfig(packageJSONPath, specifier, base);
          if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null)
            return packageExportsResolve(
              packageJSONUrl,
              packageSubpath,
              packageConfig2,
              base,
              conditions
            ).resolved;
          if (packageSubpath === ".")
            return legacyMainResolve(packageJSONUrl, packageConfig2, base);
          return new URL2(packageSubpath, packageJSONUrl);
        } while (packageJSONPath.length !== lastPath.length);
        throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base));
      }
      function isBareSpecifier(specifier) {
        return specifier[0] && specifier[0] !== "/" && specifier[0] !== ".";
      }
      function isRelativeSpecifier(specifier) {
        if (specifier[0] === ".") {
          if (specifier.length === 1 || specifier[1] === "/")
            return true;
          if (specifier[1] === ".") {
            if (specifier.length === 2 || specifier[2] === "/")
              return true;
          }
        }
        return false;
      }
      function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
        if (specifier === "")
          return false;
        if (specifier[0] === "/")
          return true;
        return isRelativeSpecifier(specifier);
      }
      function moduleResolve(specifier, base, conditions) {
        let resolved;
        if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
          resolved = new URL2(specifier, base);
        } else if (specifier[0] === "#") {
          ({ resolved } = packageImportsResolve(specifier, base, conditions));
        } else {
          try {
            resolved = new URL2(specifier);
          } catch {
            resolved = packageResolve(specifier, base, conditions);
          }
        }
        return finalizeResolution(resolved, base);
      }
      function resolveAsCommonJS(specifier, parentURL) {
        try {
          const parent = fileURLToPath(parentURL);
          const tmpModule = new CJSModule(parent, null);
          tmpModule.paths = CJSModule._nodeModulePaths(parent);
          let found = CJSModule._resolveFilename(specifier, tmpModule, false);
          if (isRelativeSpecifier(specifier)) {
            found = relative(parent, found);
            if (!StringPrototypeStartsWith(found, `..${sep}`)) {
              found = `.${sep}${found}`;
            }
          } else if (isBareSpecifier(specifier)) {
            const pkg = StringPrototypeSplit(specifier, "/")[0];
            const index = StringPrototypeIndexOf(found, pkg);
            if (index !== -1) {
              found = StringPrototypeSlice(found, index);
            }
          }
          if (process.platform === "win32") {
            found = StringPrototypeReplace(found, new RegExp(`\\${sep}`, "g"), "/");
          }
          return found;
        } catch {
          return false;
        }
      }
      function defaultResolve(specifier, context = {}, defaultResolveUnused) {
        let { parentURL, conditions } = context;
        if (parentURL && policy != null && policy.manifest) {
          const redirects = policy.manifest.getDependencyMapper(parentURL);
          if (redirects) {
            const { resolve: resolve27, reaction } = redirects;
            const destination = resolve27(specifier, new SafeSet(conditions));
            let missing = true;
            if (destination === true) {
              missing = false;
            } else if (destination) {
              const href = destination.href;
              return { url: href };
            }
            if (missing) {
              reaction(
                new ERR_MANIFEST_DEPENDENCY_MISSING(
                  parentURL,
                  specifier,
                  ArrayPrototypeJoin([...conditions], ", ")
                )
              );
            }
          }
        }
        let parsed;
        try {
          parsed = new URL2(specifier);
          if (parsed.protocol === "data:") {
            return {
              url: specifier
            };
          }
        } catch {
        }
        if (parsed && parsed.protocol === builtinModuleProtocol)
          return { url: specifier };
        if (parsed && parsed.protocol !== "file:" && parsed.protocol !== "data:")
          throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);
        if (NativeModule.canBeRequiredByUsers(specifier)) {
          return {
            url: builtinModuleProtocol + specifier
          };
        }
        if (parentURL && StringPrototypeStartsWith(parentURL, "data:")) {
          new URL2(specifier, parentURL);
        }
        const isMain = parentURL === void 0;
        if (isMain) {
          parentURL = pathToFileURL(`${process.cwd()}/`).href;
          if (typeFlag)
            throw new ERR_INPUT_TYPE_NOT_ALLOWED();
        }
        conditions = getConditionsSet(conditions);
        let url;
        try {
          url = moduleResolve(specifier, parentURL, conditions);
        } catch (error) {
          if (error.code === "ERR_MODULE_NOT_FOUND" || error.code === "ERR_UNSUPPORTED_DIR_IMPORT") {
            if (StringPrototypeStartsWith(specifier, "file://")) {
              specifier = fileURLToPath(specifier);
            }
            const found = resolveAsCommonJS(specifier, parentURL);
            if (found) {
              const lines = StringPrototypeSplit(error.stack, "\n");
              const hint = `Did you mean to import ${found}?`;
              error.stack = ArrayPrototypeShift(lines) + "\n" + hint + "\n" + ArrayPrototypeJoin(lines, "\n");
              error.message += `
${hint}`;
            }
          }
          throw error;
        }
        if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {
          const urlPath = fileURLToPath(url);
          const real = realpathSync(urlPath, {
            // [internalFS.realpathCacheKey]: realpathCache
          });
          const old = url;
          url = pathToFileURL(
            real + (StringPrototypeEndsWith(urlPath, sep) ? "/" : "")
          );
          url.search = old.search;
          url.hash = old.hash;
        }
        return { url: `${url}` };
      }
      return {
        DEFAULT_CONDITIONS,
        defaultResolve,
        encodedSepRegEx,
        getPackageType,
        packageExportsResolve,
        packageImportsResolve
      };
    }
    module.exports = {
      createResolve
    };
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-modules-esm-get_format.js
var require_node_internal_modules_esm_get_format = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist-raw/node-internal-modules-esm-get_format.js"(exports, module) {
    "use strict";
    var {
      RegExpPrototypeExec,
      StringPrototypeStartsWith
    } = require_node_primordials();
    var { extname } = require_path();
    var { getOptionValue } = require_node_options();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((s) => parseInt(s, 10));
    var experimentalJsonModules = nodeMajor > 17 || nodeMajor === 17 && nodeMinor >= 5 || nodeMajor === 16 && nodeMinor >= 15 || getOptionValue("--experimental-json-modules");
    var experimentalWasmModules = getOptionValue("--experimental-wasm-modules");
    var { URL: URL2, fileURLToPath } = require_url();
    var { ERR_UNKNOWN_FILE_EXTENSION } = require_node_internal_errors().codes;
    var extensionFormatMap = {
      "__proto__": null,
      ".cjs": "commonjs",
      ".js": "module",
      ".mjs": "module"
    };
    var legacyExtensionFormatMap = {
      "__proto__": null,
      ".cjs": "commonjs",
      ".js": "commonjs",
      ".json": "commonjs",
      ".mjs": "module",
      ".node": "commonjs"
    };
    if (experimentalWasmModules)
      extensionFormatMap[".wasm"] = legacyExtensionFormatMap[".wasm"] = "wasm";
    if (experimentalJsonModules)
      extensionFormatMap[".json"] = legacyExtensionFormatMap[".json"] = "json";
    function createGetFormat(tsNodeExperimentalSpecifierResolution, nodeEsmResolver) {
      let experimentalSpeciferResolution = tsNodeExperimentalSpecifierResolution != null ? tsNodeExperimentalSpecifierResolution : getOptionValue("--experimental-specifier-resolution");
      const { getPackageType } = nodeEsmResolver;
      function defaultGetFormat(url, context, defaultGetFormatUnused) {
        if (StringPrototypeStartsWith(url, "node:")) {
          return { format: "builtin" };
        }
        const parsed = new URL2(url);
        if (parsed.protocol === "data:") {
          const [, mime] = RegExpPrototypeExec(
            /^([^/]+\/[^;,]+)(?:[^,]*?)(;base64)?,/,
            parsed.pathname
          ) || [null, null, null];
          const format = {
            "__proto__": null,
            "text/javascript": "module",
            "application/json": experimentalJsonModules ? "json" : null,
            "application/wasm": experimentalWasmModules ? "wasm" : null
          }[mime] || null;
          return { format };
        } else if (parsed.protocol === "file:") {
          const ext = extname(parsed.pathname);
          let format;
          if (ext === ".js") {
            format = getPackageType(parsed.href) === "module" ? "module" : "commonjs";
          } else {
            format = extensionFormatMap[ext];
          }
          if (!format) {
            if (experimentalSpeciferResolution === "node") {
              process.emitWarning(
                "The Node.js specifier resolution in ESM is experimental.",
                "ExperimentalWarning"
              );
              format = legacyExtensionFormatMap[ext];
            } else {
              throw new ERR_UNKNOWN_FILE_EXTENSION(ext, fileURLToPath(url));
            }
          }
          return { format: format || null };
        }
        return { format: null };
      }
      return { defaultGetFormat };
    }
    module.exports = {
      createGetFormat
    };
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/esm.js
var require_esm = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/esm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEsmHooks = exports.registerAndCreateEsmHooks = exports.filterHooksByAPIVersion = void 0;
    var index_1 = require_dist4();
    var url_1 = require_url();
    var path_1 = require_path();
    var assert = require_assert();
    var util_1 = require_util4();
    var module_1 = require_module();
    var newHooksAPI = (0, util_1.versionGteLt)(process.versions.node, "16.12.0");
    function filterHooksByAPIVersion(hooks) {
      const { getFormat, load, resolve: resolve27, transformSource } = hooks;
      const hooksAPI = newHooksAPI ? { resolve: resolve27, load, getFormat: void 0, transformSource: void 0 } : { resolve: resolve27, getFormat, transformSource, load: void 0 };
      return hooksAPI;
    }
    exports.filterHooksByAPIVersion = filterHooksByAPIVersion;
    function registerAndCreateEsmHooks(opts) {
      const tsNodeInstance = (0, index_1.register)(opts);
      return createEsmHooks(tsNodeInstance);
    }
    exports.registerAndCreateEsmHooks = registerAndCreateEsmHooks;
    function createEsmHooks(tsNodeService) {
      tsNodeService.enableExperimentalEsmLoaderInterop();
      const nodeResolveImplementation = tsNodeService.getNodeEsmResolver();
      const nodeGetFormatImplementation = tsNodeService.getNodeEsmGetFormat();
      const extensions = tsNodeService.extensions;
      const hooksAPI = filterHooksByAPIVersion({
        resolve: resolve27,
        load,
        getFormat,
        transformSource
      });
      function isFileUrlOrNodeStyleSpecifier(parsed) {
        const { protocol } = parsed;
        return protocol === null || protocol === "file:";
      }
      function isProbablyEntrypoint(specifier, parentURL) {
        return parentURL === void 0 && specifier.startsWith("file://");
      }
      const rememberIsProbablyEntrypoint = /* @__PURE__ */ new Set();
      const rememberResolvedViaCommonjsFallback = /* @__PURE__ */ new Set();
      async function resolve27(specifier, context, defaultResolve) {
        const defer = async () => {
          const r = await defaultResolve(specifier, context, defaultResolve);
          return r;
        };
        async function entrypointFallback(cb) {
          try {
            const resolution = await cb();
            if ((resolution === null || resolution === void 0 ? void 0 : resolution.url) && isProbablyEntrypoint(specifier, context.parentURL))
              rememberIsProbablyEntrypoint.add(resolution.url);
            return resolution;
          } catch (esmResolverError) {
            if (!isProbablyEntrypoint(specifier, context.parentURL))
              throw esmResolverError;
            try {
              let cjsSpecifier = specifier;
              try {
                if (specifier.startsWith("file://"))
                  cjsSpecifier = (0, url_1.fileURLToPath)(specifier);
              } catch {
              }
              const resolution = (0, url_1.pathToFileURL)((0, module_1.createRequire)(process.cwd()).resolve(cjsSpecifier)).toString();
              rememberIsProbablyEntrypoint.add(resolution);
              rememberResolvedViaCommonjsFallback.add(resolution);
              return { url: resolution, format: "commonjs" };
            } catch (commonjsResolverError) {
              throw esmResolverError;
            }
          }
        }
        return addShortCircuitFlag(async () => {
          const parsed = (0, url_1.parse)(specifier);
          const { pathname, protocol, hostname } = parsed;
          if (!isFileUrlOrNodeStyleSpecifier(parsed)) {
            return entrypointFallback(defer);
          }
          if (protocol !== null && protocol !== "file:") {
            return entrypointFallback(defer);
          }
          if (hostname) {
            return entrypointFallback(defer);
          }
          return entrypointFallback(() => nodeResolveImplementation.defaultResolve(specifier, context, defaultResolve));
        });
      }
      async function load(url, context, defaultLoad) {
        return addShortCircuitFlag(async () => {
          var _a;
          const format = (_a = context.format) !== null && _a !== void 0 ? _a : (await getFormat(url, context, nodeGetFormatImplementation.defaultGetFormat)).format;
          let source = void 0;
          if (format !== "builtin" && format !== "commonjs") {
            const { source: rawSource } = await defaultLoad(url, {
              ...context,
              format
            }, defaultLoad);
            if (rawSource === void 0 || rawSource === null) {
              throw new Error(`Failed to load raw source: Format was '${format}' and url was '${url}''.`);
            }
            const defaultTransformSource = async (source2, _context, _defaultTransformSource) => ({ source: source2 });
            const { source: transformedSource } = await transformSource(rawSource, { url, format }, defaultTransformSource);
            source = transformedSource;
          }
          return { format, source };
        });
      }
      async function getFormat(url, context, defaultGetFormat) {
        const defer = (overrideUrl = url) => defaultGetFormat(overrideUrl, context, defaultGetFormat);
        async function entrypointFallback(cb) {
          try {
            return await cb();
          } catch (getFormatError) {
            if (!rememberIsProbablyEntrypoint.has(url))
              throw getFormatError;
            return { format: "commonjs" };
          }
        }
        const parsed = (0, url_1.parse)(url);
        if (!isFileUrlOrNodeStyleSpecifier(parsed)) {
          return entrypointFallback(defer);
        }
        const { pathname } = parsed;
        assert(pathname !== null, "ESM getFormat() hook: URL should never have null pathname");
        const nativePath = (0, url_1.fileURLToPath)(url);
        let nodeSays;
        const ext = (0, path_1.extname)(nativePath);
        const tsNodeIgnored = tsNodeService.ignored(nativePath);
        const nodeEquivalentExt = extensions.nodeEquivalents.get(ext);
        if (nodeEquivalentExt && !tsNodeIgnored) {
          nodeSays = await entrypointFallback(() => defer((0, url_1.format)((0, url_1.pathToFileURL)(nativePath + nodeEquivalentExt))));
        } else {
          try {
            nodeSays = await entrypointFallback(defer);
          } catch (e) {
            if (e instanceof Error && tsNodeIgnored && extensions.nodeDoesNotUnderstand.includes(ext)) {
              e.message += `

Hint:
ts-node is configured to ignore this file.
If you want ts-node to handle this file, consider enabling the "skipIgnore" option or adjusting your "ignore" patterns.
https://typestrong.org/ts-node/docs/scope
`;
            }
            throw e;
          }
        }
        if (!tsNodeService.ignored(nativePath) && (nodeSays.format === "commonjs" || nodeSays.format === "module")) {
          const { moduleType } = tsNodeService.moduleTypeClassifier.classifyModuleByModuleTypeOverrides((0, util_1.normalizeSlashes)(nativePath));
          if (moduleType === "cjs") {
            return { format: "commonjs" };
          } else if (moduleType === "esm") {
            return { format: "module" };
          }
        }
        return nodeSays;
      }
      async function transformSource(source, context, defaultTransformSource) {
        if (source === null || source === void 0) {
          throw new Error("No source");
        }
        const defer = () => defaultTransformSource(source, context, defaultTransformSource);
        const sourceAsString = typeof source === "string" ? source : source.toString("utf8");
        const { url } = context;
        const parsed = (0, url_1.parse)(url);
        if (!isFileUrlOrNodeStyleSpecifier(parsed)) {
          return defer();
        }
        const nativePath = (0, url_1.fileURLToPath)(url);
        if (tsNodeService.ignored(nativePath)) {
          return defer();
        }
        const emittedJs = tsNodeService.compile(sourceAsString, nativePath);
        return { source: emittedJs };
      }
      return hooksAPI;
    }
    exports.createEsmHooks = createEsmHooks;
    async function addShortCircuitFlag(fn) {
      const ret = await fn();
      if (ret == null)
        return ret;
      return {
        ...ret,
        shortCircuit: true
      };
    }
  }
});

// node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/.pnpm/ts-node@10.9.1_zlol4fzmmjgb3bdeviopae4asm/node_modules/ts-node/dist/index.js"(exports) {
    "use strict";
    var _a;
    var _b;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEsmHooks = exports.createFromPreloadedConfig = exports.create = exports.register = exports.TSError = exports.DEFAULTS = exports.VERSION = exports.debug = exports.INSPECT_CUSTOM = exports.env = exports.REGISTER_INSTANCE = exports.createRepl = void 0;
    var path_1 = require_path();
    var module_1 = require_module();
    var util = require_util();
    var url_1 = require_url();
    var make_error_1 = require_make_error();
    var util_1 = require_util4();
    var configuration_1 = require_configuration();
    var module_type_classifier_1 = require_module_type_classifier();
    var resolver_functions_1 = require_resolver_functions();
    var cjs_resolve_hooks_1 = require_cjs_resolve_hooks();
    var node_module_type_classifier_1 = require_node_module_type_classifier();
    var file_extensions_1 = require_file_extensions();
    var ts_transpile_module_1 = require_ts_transpile_module();
    var repl_1 = require_repl2();
    Object.defineProperty(exports, "createRepl", { enumerable: true, get: function() {
      return repl_1.createRepl;
    } });
    var engineSupportsPackageTypeField = parseInt(process.versions.node.split(".")[0], 10) >= 12;
    var assertScriptCanLoadAsCJS = engineSupportsPackageTypeField ? require_node_internal_modules_cjs_loader().assertScriptCanLoadAsCJSImpl : () => {
    };
    exports.REGISTER_INSTANCE = Symbol.for("ts-node.register.instance");
    exports.env = process.env;
    exports.INSPECT_CUSTOM = util.inspect.custom || "inspect";
    var shouldDebug = (0, util_1.yn)(exports.env.TS_NODE_DEBUG);
    exports.debug = shouldDebug ? (...args) => console.log(`[ts-node ${(/* @__PURE__ */ new Date()).toISOString()}]`, ...args) : () => void 0;
    var debugFn = shouldDebug ? (key, fn) => {
      let i = 0;
      return (x) => {
        (0, exports.debug)(key, x, ++i);
        return fn(x);
      };
    } : (_, fn) => fn;
    exports.VERSION = require_package().version;
    exports.DEFAULTS = {
      cwd: (_a = exports.env.TS_NODE_CWD) !== null && _a !== void 0 ? _a : exports.env.TS_NODE_DIR,
      emit: (0, util_1.yn)(exports.env.TS_NODE_EMIT),
      scope: (0, util_1.yn)(exports.env.TS_NODE_SCOPE),
      scopeDir: exports.env.TS_NODE_SCOPE_DIR,
      files: (0, util_1.yn)(exports.env.TS_NODE_FILES),
      pretty: (0, util_1.yn)(exports.env.TS_NODE_PRETTY),
      compiler: exports.env.TS_NODE_COMPILER,
      compilerOptions: (0, util_1.parse)(exports.env.TS_NODE_COMPILER_OPTIONS),
      ignore: (0, util_1.split)(exports.env.TS_NODE_IGNORE),
      project: exports.env.TS_NODE_PROJECT,
      skipProject: (0, util_1.yn)(exports.env.TS_NODE_SKIP_PROJECT),
      skipIgnore: (0, util_1.yn)(exports.env.TS_NODE_SKIP_IGNORE),
      preferTsExts: (0, util_1.yn)(exports.env.TS_NODE_PREFER_TS_EXTS),
      ignoreDiagnostics: (0, util_1.split)(exports.env.TS_NODE_IGNORE_DIAGNOSTICS),
      transpileOnly: (0, util_1.yn)(exports.env.TS_NODE_TRANSPILE_ONLY),
      typeCheck: (0, util_1.yn)(exports.env.TS_NODE_TYPE_CHECK),
      compilerHost: (0, util_1.yn)(exports.env.TS_NODE_COMPILER_HOST),
      logError: (0, util_1.yn)(exports.env.TS_NODE_LOG_ERROR),
      experimentalReplAwait: (_b = (0, util_1.yn)(exports.env.TS_NODE_EXPERIMENTAL_REPL_AWAIT)) !== null && _b !== void 0 ? _b : void 0,
      tsTrace: console.log.bind(console)
    };
    var TSError = class extends make_error_1.BaseError {
      constructor(diagnosticText, diagnosticCodes, diagnostics = []) {
        super(`⨯ Unable to compile TypeScript:
${diagnosticText}`);
        this.diagnosticCodes = diagnosticCodes;
        this.name = "TSError";
        Object.defineProperty(this, "diagnosticText", {
          configurable: true,
          writable: true,
          value: diagnosticText
        });
        Object.defineProperty(this, "diagnostics", {
          configurable: true,
          writable: true,
          value: diagnostics
        });
      }
      /**
       * @internal
       */
      [exports.INSPECT_CUSTOM]() {
        return this.diagnosticText;
      }
    };
    exports.TSError = TSError;
    var TS_NODE_SERVICE_BRAND = Symbol("TS_NODE_SERVICE_BRAND");
    function register(serviceOrOpts) {
      let service = serviceOrOpts;
      if (!(serviceOrOpts === null || serviceOrOpts === void 0 ? void 0 : serviceOrOpts[TS_NODE_SERVICE_BRAND])) {
        service = create(serviceOrOpts !== null && serviceOrOpts !== void 0 ? serviceOrOpts : {});
      }
      const originalJsHandler = __require.extensions[".js"];
      process[exports.REGISTER_INSTANCE] = service;
      registerExtensions(service.options.preferTsExts, service.extensions.compiled, service, originalJsHandler);
      (0, cjs_resolve_hooks_1.installCommonjsResolveHooksIfNecessary)(service);
      module_1.Module._preloadModules(service.options.require);
      return service;
    }
    exports.register = register;
    function create(rawOptions = {}) {
      const foundConfigResult = (0, configuration_1.findAndReadConfig)(rawOptions);
      return createFromPreloadedConfig(foundConfigResult);
    }
    exports.create = create;
    function createFromPreloadedConfig(foundConfigResult) {
      var _a2, _b2, _c, _d;
      const { configFilePath, cwd, options, config, compiler, projectLocalResolveDir, optionBasePaths } = foundConfigResult;
      const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(projectLocalResolveDir);
      const ts = (0, configuration_1.loadCompiler)(compiler);
      const targetSupportsTla = config.options.target >= ts.ScriptTarget.ES2018;
      if (options.experimentalReplAwait === true && !targetSupportsTla) {
        throw new Error("Experimental REPL await is not compatible with targets lower than ES2018");
      }
      const tsVersionSupportsTla = (0, util_1.versionGteLt)(ts.version, "3.8.0");
      if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {
        throw new Error("Experimental REPL await is not compatible with TypeScript versions older than 3.8");
      }
      const shouldReplAwait = options.experimentalReplAwait !== false && tsVersionSupportsTla && targetSupportsTla;
      if (options.swc && !options.typeCheck) {
        if (options.transpileOnly === false) {
          throw new Error("Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.");
        }
        if (options.transpiler) {
          throw new Error("Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.");
        }
      }
      const readFile = options.readFile || ts.sys.readFile;
      const fileExists = options.fileExists || ts.sys.fileExists;
      const transpileOnly = (options.transpileOnly === true || options.swc === true) && options.typeCheck !== true;
      let transpiler = void 0;
      let transpilerBasePath = void 0;
      if (options.transpiler) {
        transpiler = options.transpiler;
        transpilerBasePath = optionBasePaths.transpiler;
      } else if (options.swc) {
        transpiler = __require.resolve("./transpilers/swc.js");
        transpilerBasePath = optionBasePaths.swc;
      }
      const transformers = options.transformers || void 0;
      const diagnosticFilters = [
        {
          appliesToAllFiles: true,
          filenamesAbsolute: [],
          diagnosticsIgnored: [
            6059,
            18002,
            18003,
            ...options.experimentalTsImportSpecifiers ? [
              2691
              // "An import path cannot end with a '.ts' extension. Consider importing '<specifier without ext>' instead."
            ] : [],
            ...options.ignoreDiagnostics || []
          ].map(Number)
        }
      ];
      const configDiagnosticList = filterDiagnostics(config.errors, diagnosticFilters);
      const outputCache = /* @__PURE__ */ new Map();
      const configFileDirname = configFilePath ? (0, path_1.dirname)(configFilePath) : null;
      const scopeDir = (_c = (_b2 = (_a2 = options.scopeDir) !== null && _a2 !== void 0 ? _a2 : config.options.rootDir) !== null && _b2 !== void 0 ? _b2 : configFileDirname) !== null && _c !== void 0 ? _c : cwd;
      const ignoreBaseDir = configFileDirname !== null && configFileDirname !== void 0 ? configFileDirname : cwd;
      const isScoped = options.scope ? (fileName) => (0, path_1.relative)(scopeDir, fileName).charAt(0) !== "." : () => true;
      const shouldIgnore = createIgnore(ignoreBaseDir, options.skipIgnore ? [] : (options.ignore || ["(?:^|/)node_modules/"]).map((str) => new RegExp(str)));
      const diagnosticHost = {
        getNewLine: () => ts.sys.newLine,
        getCurrentDirectory: () => cwd,
        // TODO switch to getCanonicalFileName we already create later in scope
        getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? (x) => x : (x) => x.toLowerCase()
      };
      if (options.transpileOnly && typeof transformers === "function") {
        throw new TypeError('Transformers function is unavailable in "--transpile-only"');
      }
      let createTranspiler = initializeTranspilerFactory();
      function initializeTranspilerFactory() {
        var _a3;
        if (transpiler) {
          let createTranspiler2 = function(compilerOptions, nodeModuleEmitKind) {
            return transpilerFactory === null || transpilerFactory === void 0 ? void 0 : transpilerFactory({
              service: {
                options,
                config: {
                  ...config,
                  options: compilerOptions
                },
                projectLocalResolveHelper
              },
              transpilerConfigLocalResolveHelper,
              nodeModuleEmitKind,
              ...transpilerOptions
            });
          };
          if (!transpileOnly)
            throw new Error("Custom transpiler can only be used when transpileOnly is enabled.");
          const transpilerName = typeof transpiler === "string" ? transpiler : transpiler[0];
          const transpilerOptions = typeof transpiler === "string" ? {} : (_a3 = transpiler[1]) !== null && _a3 !== void 0 ? _a3 : {};
          const transpilerConfigLocalResolveHelper = transpilerBasePath ? (0, util_1.createProjectLocalResolveHelper)(transpilerBasePath) : projectLocalResolveHelper;
          const transpilerPath = transpilerConfigLocalResolveHelper(transpilerName, true);
          const transpilerFactory = __require(transpilerPath).create;
          return createTranspiler2;
        }
      }
      let experimentalEsmLoader = false;
      function enableExperimentalEsmLoaderInterop() {
        experimentalEsmLoader = true;
      }
      installSourceMapSupport();
      function installSourceMapSupport() {
        const sourceMapSupport = require_source_map_support();
        sourceMapSupport.install({
          environment: "node",
          retrieveFile(pathOrUrl) {
            var _a3;
            let path3 = pathOrUrl;
            if (experimentalEsmLoader && path3.startsWith("file://")) {
              try {
                path3 = (0, url_1.fileURLToPath)(path3);
              } catch (e) {
              }
            }
            path3 = (0, util_1.normalizeSlashes)(path3);
            return ((_a3 = outputCache.get(path3)) === null || _a3 === void 0 ? void 0 : _a3.content) || "";
          },
          redirectConflictingLibrary: true,
          onConflictingLibraryRedirect(request, parent, isMain, options2, redirectedRequest) {
            (0, exports.debug)(`Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  "${parent.filename}" attempted to require or resolve "${request}" and was redirected to "${redirectedRequest}".`);
          }
        });
      }
      const shouldHavePrettyErrors = options.pretty === void 0 ? process.stdout.isTTY : options.pretty;
      const formatDiagnostics = shouldHavePrettyErrors ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics : ts.formatDiagnostics;
      function createTSError(diagnostics) {
        const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);
        const diagnosticCodes = diagnostics.map((x) => x.code);
        return new TSError(diagnosticText, diagnosticCodes, diagnostics);
      }
      function reportTSError(configDiagnosticList2) {
        const error = createTSError(configDiagnosticList2);
        if (options.logError) {
          console.error("\x1B[31m%s\x1B[0m", error);
        } else {
          throw error;
        }
      }
      if (configDiagnosticList.length)
        reportTSError(configDiagnosticList);
      const jsxEmitPreserve = config.options.jsx === ts.JsxEmit.Preserve;
      function getEmitExtension(path3) {
        const lastDotIndex = path3.lastIndexOf(".");
        if (lastDotIndex >= 0) {
          const ext = path3.slice(lastDotIndex);
          switch (ext) {
            case ".js":
            case ".ts":
              return ".js";
            case ".jsx":
            case ".tsx":
              return jsxEmitPreserve ? ".jsx" : ".js";
            case ".mjs":
            case ".mts":
              return ".mjs";
            case ".cjs":
            case ".cts":
              return ".cjs";
          }
        }
        return ".js";
      }
      let getOutput;
      let getTypeInfo;
      const getCanonicalFileName = ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);
      const moduleTypeClassifier = (0, module_type_classifier_1.createModuleTypeClassifier)({
        basePath: (_d = options.optionBasePaths) === null || _d === void 0 ? void 0 : _d.moduleTypes,
        patterns: options.moduleTypes
      });
      const extensions = (0, file_extensions_1.getExtensions)(config, options, ts.version);
      if (!transpileOnly) {
        const fileContents = /* @__PURE__ */ new Map();
        const rootFileNames = new Set(config.fileNames);
        const cachedReadFile = (0, util_1.cachedLookup)(debugFn("readFile", readFile));
        if (!options.compilerHost) {
          let projectVersion = 1;
          const fileVersions = new Map(Array.from(rootFileNames).map((fileName) => [fileName, 0]));
          const getCustomTransformers = () => {
            if (typeof transformers === "function") {
              const program = service.getProgram();
              return program ? transformers(program) : void 0;
            }
            return transformers;
          };
          const serviceHost = {
            getProjectVersion: () => String(projectVersion),
            getScriptFileNames: () => Array.from(rootFileNames),
            getScriptVersion: (fileName) => {
              const version = fileVersions.get(fileName);
              return version ? version.toString() : "";
            },
            getScriptSnapshot(fileName) {
              let contents = fileContents.get(fileName);
              if (contents === void 0) {
                contents = cachedReadFile(fileName);
                if (contents === void 0)
                  return;
                fileVersions.set(fileName, 1);
                fileContents.set(fileName, contents);
                projectVersion++;
              }
              return ts.ScriptSnapshot.fromString(contents);
            },
            readFile: cachedReadFile,
            readDirectory: ts.sys.readDirectory,
            getDirectories: (0, util_1.cachedLookup)(debugFn("getDirectories", ts.sys.getDirectories)),
            fileExists: (0, util_1.cachedLookup)(debugFn("fileExists", fileExists)),
            directoryExists: (0, util_1.cachedLookup)(debugFn("directoryExists", ts.sys.directoryExists)),
            realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn("realpath", ts.sys.realpath)) : void 0,
            getNewLine: () => ts.sys.newLine,
            useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,
            getCurrentDirectory: () => cwd,
            getCompilationSettings: () => config.options,
            getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),
            getCustomTransformers,
            trace: options.tsTrace
          };
          const { resolveModuleNames, getResolvedModuleWithFailedLookupLocationsFromCache, resolveTypeReferenceDirectives, isFileKnownToBeInternal, markBucketOfFilenameInternal } = (0, resolver_functions_1.createResolverFunctions)({
            host: serviceHost,
            getCanonicalFileName,
            ts,
            cwd,
            config,
            projectLocalResolveHelper,
            options,
            extensions
          });
          serviceHost.resolveModuleNames = resolveModuleNames;
          serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache = getResolvedModuleWithFailedLookupLocationsFromCache;
          serviceHost.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;
          const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);
          const service = ts.createLanguageService(serviceHost, registry);
          const updateMemoryCache = (contents, fileName) => {
            if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {
              markBucketOfFilenameInternal(fileName);
              rootFileNames.add(fileName);
              projectVersion++;
            }
            const previousVersion = fileVersions.get(fileName) || 0;
            const previousContents = fileContents.get(fileName);
            if (contents !== previousContents) {
              fileVersions.set(fileName, previousVersion + 1);
              fileContents.set(fileName, contents);
              projectVersion++;
            }
          };
          let previousProgram = void 0;
          getOutput = (code, fileName) => {
            updateMemoryCache(code, fileName);
            const programBefore = service.getProgram();
            if (programBefore !== previousProgram) {
              (0, exports.debug)(`compiler rebuilt Program instance when getting output for ${fileName}`);
            }
            const output = service.getEmitOutput(fileName);
            const diagnostics = service.getSemanticDiagnostics(fileName).concat(service.getSyntacticDiagnostics(fileName));
            const programAfter = service.getProgram();
            (0, exports.debug)("invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ", programBefore === programAfter);
            previousProgram = programAfter;
            const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);
            if (diagnosticList.length)
              reportTSError(diagnosticList);
            if (output.emitSkipped) {
              return [void 0, void 0, true];
            }
            if (output.outputFiles.length === 0) {
              throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}
This is usually the result of a faulty configuration or import. Make sure there is a \`.js\`, \`.json\` or other executable extension with loader attached before \`ts-node\` available.`);
            }
            return [output.outputFiles[1].text, output.outputFiles[0].text, false];
          };
          getTypeInfo = (code, fileName, position) => {
            const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);
            updateMemoryCache(code, normalizedFileName);
            const info = service.getQuickInfoAtPosition(normalizedFileName, position);
            const name = ts.displayPartsToString(info ? info.displayParts : []);
            const comment = ts.displayPartsToString(info ? info.documentation : []);
            return { name, comment };
          };
        } else {
          const sys = {
            ...ts.sys,
            ...diagnosticHost,
            readFile: (fileName) => {
              const cacheContents = fileContents.get(fileName);
              if (cacheContents !== void 0)
                return cacheContents;
              const contents = cachedReadFile(fileName);
              if (contents)
                fileContents.set(fileName, contents);
              return contents;
            },
            readDirectory: ts.sys.readDirectory,
            getDirectories: (0, util_1.cachedLookup)(debugFn("getDirectories", ts.sys.getDirectories)),
            fileExists: (0, util_1.cachedLookup)(debugFn("fileExists", fileExists)),
            directoryExists: (0, util_1.cachedLookup)(debugFn("directoryExists", ts.sys.directoryExists)),
            resolvePath: (0, util_1.cachedLookup)(debugFn("resolvePath", ts.sys.resolvePath)),
            realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn("realpath", ts.sys.realpath)) : void 0
          };
          const host = ts.createIncrementalCompilerHost ? ts.createIncrementalCompilerHost(config.options, sys) : {
            ...sys,
            getSourceFile: (fileName, languageVersion) => {
              const contents = sys.readFile(fileName);
              if (contents === void 0)
                return;
              return ts.createSourceFile(fileName, contents, languageVersion);
            },
            getDefaultLibLocation: () => (0, util_1.normalizeSlashes)((0, path_1.dirname)(compiler)),
            getDefaultLibFileName: () => (0, util_1.normalizeSlashes)((0, path_1.join)((0, path_1.dirname)(compiler), ts.getDefaultLibFileName(config.options))),
            useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames
          };
          host.trace = options.tsTrace;
          const { resolveModuleNames, resolveTypeReferenceDirectives, isFileKnownToBeInternal, markBucketOfFilenameInternal } = (0, resolver_functions_1.createResolverFunctions)({
            host,
            cwd,
            config,
            ts,
            getCanonicalFileName,
            projectLocalResolveHelper,
            options,
            extensions
          });
          host.resolveModuleNames = resolveModuleNames;
          host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;
          let builderProgram = ts.createIncrementalProgram ? ts.createIncrementalProgram({
            rootNames: Array.from(rootFileNames),
            options: config.options,
            host,
            configFileParsingDiagnostics: config.errors,
            projectReferences: config.projectReferences
          }) : ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, void 0, config.errors, config.projectReferences);
          const customTransformers = typeof transformers === "function" ? transformers(builderProgram.getProgram()) : transformers;
          const updateMemoryCache = (contents, fileName) => {
            const previousContents = fileContents.get(fileName);
            const contentsChanged = previousContents !== contents;
            if (contentsChanged) {
              fileContents.set(fileName, contents);
            }
            let addedToRootFileNames = false;
            if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {
              markBucketOfFilenameInternal(fileName);
              rootFileNames.add(fileName);
              addedToRootFileNames = true;
            }
            if (addedToRootFileNames || contentsChanged) {
              builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, builderProgram, config.errors, config.projectReferences);
            }
          };
          getOutput = (code, fileName) => {
            let outText = "";
            let outMap = "";
            updateMemoryCache(code, fileName);
            const sourceFile = builderProgram.getSourceFile(fileName);
            if (!sourceFile)
              throw new TypeError(`Unable to read file: ${fileName}`);
            const program = builderProgram.getProgram();
            const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);
            const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);
            if (diagnosticList.length)
              reportTSError(diagnosticList);
            const result = builderProgram.emit(sourceFile, (path3, file, writeByteOrderMark) => {
              if (path3.endsWith(".map")) {
                outMap = file;
              } else {
                outText = file;
              }
              if (options.emit)
                sys.writeFile(path3, file, writeByteOrderMark);
            }, void 0, void 0, customTransformers);
            if (result.emitSkipped) {
              return [void 0, void 0, true];
            }
            if (outText === "") {
              if (program.isSourceFileFromExternalLibrary(sourceFile)) {
                throw new TypeError(`Unable to compile file from external library: ${(0, path_1.relative)(cwd, fileName)}`);
              }
              throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}
This is usually the result of a faulty configuration or import. Make sure there is a \`.js\`, \`.json\` or other executable extension with loader attached before \`ts-node\` available.`);
            }
            return [outText, outMap, false];
          };
          getTypeInfo = (code, fileName, position) => {
            const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);
            updateMemoryCache(code, normalizedFileName);
            const sourceFile = builderProgram.getSourceFile(normalizedFileName);
            if (!sourceFile)
              throw new TypeError(`Unable to read file: ${fileName}`);
            const node = getTokenAtPosition(ts, sourceFile, position);
            const checker = builderProgram.getProgram().getTypeChecker();
            const symbol = checker.getSymbolAtLocation(node);
            if (!symbol)
              return { name: "", comment: "" };
            const type3 = checker.getTypeOfSymbolAtLocation(symbol, node);
            const signatures = [
              ...type3.getConstructSignatures(),
              ...type3.getCallSignatures()
            ];
            return {
              name: signatures.length ? signatures.map((x) => checker.signatureToString(x)).join("\n") : checker.typeToString(type3),
              comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])
            };
          };
          if (options.emit && config.options.incremental) {
            process.on("exit", () => {
              builderProgram.getProgram().emitBuildInfo();
            });
          }
        }
      } else {
        getTypeInfo = () => {
          throw new TypeError('Type information is unavailable in "--transpile-only"');
        };
      }
      function createTranspileOnlyGetOutputFunction(overrideModuleType, nodeModuleEmitKind) {
        const compilerOptions = { ...config.options };
        if (overrideModuleType !== void 0)
          compilerOptions.module = overrideModuleType;
        let customTranspiler = createTranspiler === null || createTranspiler === void 0 ? void 0 : createTranspiler(compilerOptions, nodeModuleEmitKind);
        let tsTranspileModule = (0, util_1.versionGteLt)(ts.version, "4.7.0") ? (0, ts_transpile_module_1.createTsTranspileModule)(ts, {
          compilerOptions,
          reportDiagnostics: true,
          transformers
        }) : void 0;
        return (code, fileName) => {
          let result;
          if (customTranspiler) {
            result = customTranspiler.transpile(code, {
              fileName
            });
          } else if (tsTranspileModule) {
            result = tsTranspileModule(code, {
              fileName
            }, nodeModuleEmitKind === "nodeesm" ? "module" : "commonjs");
          } else {
            result = ts.transpileModule(code, {
              fileName,
              compilerOptions,
              reportDiagnostics: true,
              transformers
            });
          }
          const diagnosticList = filterDiagnostics(result.diagnostics || [], diagnosticFilters);
          if (diagnosticList.length)
            reportTSError(diagnosticList);
          return [result.outputText, result.sourceMapText, false];
        };
      }
      const shouldOverwriteEmitWhenForcingCommonJS = config.options.module !== ts.ModuleKind.CommonJS;
      const shouldOverwriteEmitWhenForcingEsm = !(config.options.module === ts.ModuleKind.ES2015 || ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020 || ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022 || config.options.module === ts.ModuleKind.ESNext);
      const isNodeModuleType = ts.ModuleKind.Node16 && config.options.module === ts.ModuleKind.Node16 || ts.ModuleKind.NodeNext && config.options.module === ts.ModuleKind.NodeNext;
      const getOutputForceCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.CommonJS);
      const getOutputForceNodeCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, "nodecjs");
      const getOutputForceNodeESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, "nodeesm");
      const getOutputForceESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015);
      const getOutputTranspileOnly = createTranspileOnlyGetOutputFunction();
      function compile(code, fileName, lineOffset = 0) {
        const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);
        const classification = moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizedFileName);
        let value2 = "";
        let sourceMap = "";
        let emitSkipped = true;
        if (getOutput) {
          [value2, sourceMap, emitSkipped] = getOutput(code, normalizedFileName);
        }
        if (classification.moduleType === "cjs" && (shouldOverwriteEmitWhenForcingCommonJS || emitSkipped)) {
          [value2, sourceMap] = getOutputForceCommonJS(code, normalizedFileName);
        } else if (classification.moduleType === "esm" && (shouldOverwriteEmitWhenForcingEsm || emitSkipped)) {
          [value2, sourceMap] = getOutputForceESM(code, normalizedFileName);
        } else if (emitSkipped) {
          const classification2 = (0, node_module_type_classifier_1.classifyModule)(fileName, isNodeModuleType);
          [value2, sourceMap] = classification2 === "nodecjs" ? getOutputForceNodeCommonJS(code, normalizedFileName) : classification2 === "nodeesm" ? getOutputForceNodeESM(code, normalizedFileName) : classification2 === "cjs" ? getOutputForceCommonJS(code, normalizedFileName) : classification2 === "esm" ? getOutputForceESM(code, normalizedFileName) : getOutputTranspileOnly(code, normalizedFileName);
        }
        const output = updateOutput(value2, normalizedFileName, sourceMap, getEmitExtension);
        outputCache.set(normalizedFileName, { content: output });
        return output;
      }
      let active = true;
      const enabled = (enabled2) => enabled2 === void 0 ? active : active = !!enabled2;
      const ignored = (fileName) => {
        if (!active)
          return true;
        const ext = (0, path_1.extname)(fileName);
        if (extensions.compiled.includes(ext)) {
          return !isScoped(fileName) || shouldIgnore(fileName);
        }
        return true;
      };
      function addDiagnosticFilter(filter2) {
        diagnosticFilters.push({
          ...filter2,
          filenamesAbsolute: filter2.filenamesAbsolute.map((f) => (0, util_1.normalizeSlashes)(f))
        });
      }
      const getNodeEsmResolver = (0, util_1.once)(() => require_node_internal_modules_esm_resolve().createResolve({
        extensions,
        preferTsExts: options.preferTsExts,
        tsNodeExperimentalSpecifierResolution: options.experimentalSpecifierResolution
      }));
      const getNodeEsmGetFormat = (0, util_1.once)(() => require_node_internal_modules_esm_get_format().createGetFormat(options.experimentalSpecifierResolution, getNodeEsmResolver()));
      const getNodeCjsLoader = (0, util_1.once)(() => require_node_internal_modules_cjs_loader().createCjsLoader({
        extensions,
        preferTsExts: options.preferTsExts,
        nodeEsmResolver: getNodeEsmResolver()
      }));
      return {
        [TS_NODE_SERVICE_BRAND]: true,
        ts,
        compilerPath: compiler,
        config,
        compile,
        getTypeInfo,
        ignored,
        enabled,
        options,
        configFilePath,
        moduleTypeClassifier,
        shouldReplAwait,
        addDiagnosticFilter,
        installSourceMapSupport,
        enableExperimentalEsmLoaderInterop,
        transpileOnly,
        projectLocalResolveHelper,
        getNodeEsmResolver,
        getNodeEsmGetFormat,
        getNodeCjsLoader,
        extensions
      };
    }
    exports.createFromPreloadedConfig = createFromPreloadedConfig;
    function createIgnore(ignoreBaseDir, ignore) {
      return (fileName) => {
        const relname = (0, path_1.relative)(ignoreBaseDir, fileName);
        const path3 = (0, util_1.normalizeSlashes)(relname);
        return ignore.some((x) => x.test(path3));
      };
    }
    function registerExtensions(preferTsExts, extensions, service, originalJsHandler) {
      const exts = new Set(extensions);
      for (const cannotAdd of [".mts", ".cts", ".mjs", ".cjs"]) {
        if (exts.has(cannotAdd) && !(0, util_1.hasOwnProperty)(__require.extensions, cannotAdd)) {
          exts.add(".js");
          exts.delete(cannotAdd);
        }
      }
      for (const ext of exts) {
        registerExtension(ext, service, originalJsHandler);
      }
      if (preferTsExts) {
        const preferredExtensions = /* @__PURE__ */ new Set([
          ...exts,
          ...Object.keys(__require.extensions)
        ]);
        for (const ext of preferredExtensions) {
          const old = Object.getOwnPropertyDescriptor(__require.extensions, ext);
          delete __require.extensions[ext];
          Object.defineProperty(__require.extensions, ext, old);
        }
      }
    }
    function registerExtension(ext, service, originalHandler) {
      const old = __require.extensions[ext] || originalHandler;
      __require.extensions[ext] = function(m, filename) {
        if (service.ignored(filename))
          return old(m, filename);
        assertScriptCanLoadAsCJS(service, m, filename);
        const _compile = m._compile;
        m._compile = function(code, fileName) {
          (0, exports.debug)("module._compile", fileName);
          const result = service.compile(code, fileName);
          return _compile.call(this, result, fileName);
        };
        return old(m, filename);
      };
    }
    function updateOutput(outputText, fileName, sourceMap, getEmitExtension) {
      const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), "utf8").toString("base64");
      const sourceMapContent = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${base64Map}`;
      const prefix = "//# sourceMappingURL=";
      const prefixLength = prefix.length;
      const baseName = (
        /*foo.tsx*/
        (0, path_1.basename)(fileName)
      );
      const extName = (
        /*.tsx*/
        (0, path_1.extname)(fileName)
      );
      const extension = (
        /*.js*/
        getEmitExtension(fileName)
      );
      const sourcemapFilename = baseName.slice(0, -extName.length) + extension + ".map";
      const sourceMapLengthWithoutPercentEncoding = prefixLength + sourcemapFilename.length;
      if (outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) === prefix) {
        return outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) + sourceMapContent;
      }
      const sourceMapLengthWithPercentEncoding = prefixLength + encodeURI(sourcemapFilename).length;
      if (outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) === prefix) {
        return outputText.slice(0, -sourceMapLengthWithPercentEncoding) + sourceMapContent;
      }
      return `${outputText}
${sourceMapContent}`;
    }
    function updateSourceMap(sourceMapText, fileName) {
      const sourceMap = JSON.parse(sourceMapText);
      sourceMap.file = fileName;
      sourceMap.sources = [fileName];
      delete sourceMap.sourceRoot;
      return JSON.stringify(sourceMap);
    }
    function filterDiagnostics(diagnostics, filters) {
      return diagnostics.filter((d) => filters.every((f) => {
        var _a2;
        return !f.appliesToAllFiles && f.filenamesAbsolute.indexOf((_a2 = d.file) === null || _a2 === void 0 ? void 0 : _a2.fileName) === -1 || f.diagnosticsIgnored.indexOf(d.code) === -1;
      }));
    }
    function getTokenAtPosition(ts, sourceFile, position) {
      let current = sourceFile;
      outer:
        while (true) {
          for (const child of current.getChildren(sourceFile)) {
            const start = child.getFullStart();
            if (start > position)
              break;
            const end = child.getEnd();
            if (position <= end) {
              current = child;
              continue outer;
            }
          }
          return current;
        }
    }
    var createEsmHooks = (tsNodeService) => require_esm().createEsmHooks(tsNodeService);
    exports.createEsmHooks = createEsmHooks;
  }
});

// node_modules/.pnpm/cosmiconfig-typescript-loader@4.4.0_s6uklkobqapejolsxhhen7w4ri/node_modules/cosmiconfig-typescript-loader/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/.pnpm/cosmiconfig-typescript-loader@4.4.0_s6uklkobqapejolsxhhen7w4ri/node_modules/cosmiconfig-typescript-loader/dist/cjs/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var lib_exports = {};
    __export2(lib_exports, {
      TypeScriptLoader: () => TypeScriptLoader
    });
    module.exports = __toCommonJS2(lib_exports);
    var import_ts_node = require_dist4();
    var TypeScriptCompileError = class _TypeScriptCompileError extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Object.setPrototypeOf(this, new.target.prototype);
      }
      static fromError(error) {
        const errMsg = error.message.replace(
          /(TypeScript compiler encountered syntax errors while transpiling\. Errors:\s?)|(⨯ Unable to compile TypeScript:\s?)/,
          ""
        );
        const message = `TypeScriptLoader failed to compile TypeScript:
${errMsg}`;
        const newError = new _TypeScriptCompileError(message);
        newError.stack = error.stack;
        return newError;
      }
    };
    function TypeScriptLoader(options) {
      const tsNodeInstance = (0, import_ts_node.register)({
        ...options,
        compilerOptions: { module: "commonjs" }
      });
      return (path3, content) => {
        try {
          tsNodeInstance.compile(content, path3);
          const result = __require(path3);
          return result.default || result;
        } catch (error) {
          if (error instanceof Error) {
            throw TypeScriptCompileError.fromError(error);
          }
          throw error;
        }
      };
    }
  }
});

// node_modules/.pnpm/@lingui+conf@3.17.2_jxelr7qioyee5kxajhwo2kklya/node_modules/@lingui/conf/build/index.js
var require_build5 = __commonJS({
  "node_modules/.pnpm/@lingui+conf@3.17.2_jxelr7qioyee5kxajhwo2kklya/node_modules/@lingui/conf/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.catalogMigration = catalogMigration;
    exports.defaultConfig = exports.configValidation = void 0;
    exports.fallbackLanguageMigration = fallbackLanguageMigration;
    exports.getConfig = getConfig;
    exports.makeConfig = makeConfig;
    exports.replaceRootDir = replaceRootDir;
    var _path = _interopRequireDefault(require_path());
    var _fs = _interopRequireDefault(require_fs());
    var _chalk = _interopRequireDefault(require_source());
    var _cosmiconfig = require_dist3();
    var _jestValidate = require_build4();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var pathJoinPosix = (...values3) => _path.default.join(...values3).split(_path.default.sep).join("/");
    var defaultConfig = {
      catalogs: [{
        path: pathJoinPosix("<rootDir>", "locale", "{locale}", "messages"),
        include: ["<rootDir>"],
        exclude: ["*/node_modules/*"]
      }],
      catalogsMergePath: "",
      compileNamespace: "cjs",
      compilerBabelOptions: {
        minified: true,
        jsescOption: {
          minimal: true
        }
      },
      extractBabelOptions: {
        plugins: [],
        presets: []
      },
      fallbackLocales: {},
      format: "po",
      formatOptions: {
        origins: true,
        lineNumbers: true
      },
      locales: [],
      orderBy: "messageId",
      pseudoLocale: "",
      rootDir: ".",
      runtimeConfigModule: ["@lingui/core", "i18n"],
      sourceLocale: "",
      service: {
        name: "",
        apiKey: ""
      }
    };
    exports.defaultConfig = defaultConfig;
    function configExists(path3) {
      return path3 && _fs.default.existsSync(path3);
    }
    function TypeScriptLoader() {
      let loaderInstance;
      return (filepath, content) => {
        if (!loaderInstance) {
          const {
            TypeScriptLoader: TypeScriptLoader2
          } = require_cjs();
          loaderInstance = TypeScriptLoader2();
        }
        return loaderInstance(filepath, content);
      };
    }
    function getConfig({
      cwd,
      configPath,
      skipValidation = false
    } = {}) {
      const defaultRootDir = cwd || process.cwd();
      const moduleName = "lingui";
      const configExplorer = (0, _cosmiconfig.cosmiconfigSync)(moduleName, {
        searchPlaces: ["package.json", `.${moduleName}rc`, `.${moduleName}rc.json`, `.${moduleName}rc.yaml`, `.${moduleName}rc.yml`, `.${moduleName}rc.ts`, `.${moduleName}rc.js`, `${moduleName}.config.ts`, `${moduleName}.config.js`],
        loaders: {
          ".ts": TypeScriptLoader()
        }
      });
      const result = configExists(configPath) ? configExplorer.load(configPath) : configExplorer.search(defaultRootDir);
      const userConfig = result ? result.config : {};
      return makeConfig({
        rootDir: result ? _path.default.dirname(result.filepath) : defaultRootDir,
        ...userConfig
      }, {
        skipValidation
      });
    }
    function makeConfig(userConfig, opts = {}) {
      const config = {
        ...defaultConfig,
        ...userConfig
      };
      if (!opts.skipValidation) {
        (0, _jestValidate.validate)(config, configValidation);
        return pipe2(
          // List config migrations from oldest to newest
          fallbackLanguageMigration,
          catalogMigration,
          // Custom validation
          validateLocales,
          // `replaceRootDir` should always be the last
          (config2) => replaceRootDir(config2, config2.rootDir)
        )(config);
      } else {
        return replaceRootDir(config, config.rootDir);
      }
    }
    var exampleConfig = {
      ...defaultConfig,
      extractors: (0, _jestValidate.multipleValidOptions)([], ["babel"], [{
        match: (fileName) => false,
        extract: (filename, targetDir, options) => {
        }
      }]),
      runtimeConfigModule: (0, _jestValidate.multipleValidOptions)({
        i18n: ["@lingui/core", "i18n"],
        Trans: ["@lingui/react", "Trans"]
      }, ["@lingui/core", "i18n"]),
      fallbackLocales: (0, _jestValidate.multipleValidOptions)({}, {
        "en-US": "en"
      }, {
        "en-US": ["en"]
      }, {
        default: "en"
      }, false),
      extractBabelOptions: {
        extends: "babelconfig.js",
        rootMode: "rootmode",
        plugins: ["plugin"],
        presets: ["preset"],
        targets: (0, _jestValidate.multipleValidOptions)({}, "> 0.5%", ["> 0.5%", "not dead"], void 0),
        assumptions: (0, _jestValidate.multipleValidOptions)({}, void 0),
        browserslistConfigFile: (0, _jestValidate.multipleValidOptions)(true, void 0),
        browserslistEnv: (0, _jestValidate.multipleValidOptions)(".browserslistrc", void 0)
      }
    };
    var deprecatedConfig = {
      fallbackLocale: (config) => ` Option ${_chalk.default.bold("fallbackLocale")} was replaced by ${_chalk.default.bold("fallbackLocales")}

    You can find more information here: https://github.com/lingui/js-lingui/issues/791

    @lingui/cli now treats your current configuration as:
    {
      ${_chalk.default.bold('"fallbackLocales"')}: {
        default: ${_chalk.default.bold(`"${config.fallbackLocale}"`)}
      }
    }

    Please update your configuration.
    `,
      localeDir: (config) => ` Option ${_chalk.default.bold("localeDir")} is deprecated. Configure source paths using ${_chalk.default.bold("catalogs")} instead.

    @lingui/cli now treats your current configuration as:

    {
      ${_chalk.default.bold('"catalogs"')}: ${JSON.stringify(catalogMigration(config).catalogs, null, 2)}
    }

    Please update your configuration.
    `,
      srcPathDirs: (config) => ` Option ${_chalk.default.bold("srcPathDirs")} is deprecated. Configure source paths using ${_chalk.default.bold("catalogs")} instead.

    @lingui/cli now treats your current configuration as:

    {
      ${_chalk.default.bold('"catalogs"')}: ${JSON.stringify(catalogMigration(config).catalogs, null, 2)}
    }

    Please update your configuration.
    `,
      srcPathIgnorePatterns: (config) => ` Option ${_chalk.default.bold("srcPathIgnorePatterns")} is deprecated. Configure excluded source paths using ${_chalk.default.bold("catalogs")} instead.

    @lingui/cli now treats your current configuration as:

    {
      ${_chalk.default.bold('"catalogs"')}: ${JSON.stringify(catalogMigration(config).catalogs, null, 2)}
    }

    Please update your configuration.
    `
    };
    var configValidation = {
      exampleConfig,
      deprecatedConfig,
      comment: "Documentation: https://lingui.dev/ref/conf"
    };
    exports.configValidation = configValidation;
    function validateLocales(config) {
      if (!Array.isArray(config.locales) || !config.locales.length) {
        console.error("No locales defined!\n");
        console.error(`Add ${_chalk.default.yellow("'locales'")} to your configuration. See ${_chalk.default.underline("https://lingui.dev/ref/conf#locales")}`);
      }
      return config;
    }
    function replaceRootDir(config, rootDir) {
      return function replaceDeep(value2, rootDir2) {
        const replace3 = (s) => s.replace("<rootDir>", rootDir2);
        if (value2 == null) {
          return value2;
        } else if (typeof value2 === "string") {
          return replace3(value2);
        } else if (Array.isArray(value2)) {
          return value2.map((item) => replaceDeep(item, rootDir2));
        } else if (typeof value2 === "object") {
          Object.keys(value2).forEach((key) => {
            const newKey = replaceDeep(key, rootDir2);
            value2[newKey] = replaceDeep(value2[key], rootDir2);
            if (key !== newKey)
              delete value2[key];
          });
        }
        return value2;
      }(config, rootDir);
    }
    function fallbackLanguageMigration(config) {
      const {
        fallbackLocale,
        fallbackLocales
      } = config;
      if (fallbackLocales === false)
        return {
          ...config,
          fallbackLocales: null
        };
      const DEFAULT_FALLBACK = (fallbackLocales === null || fallbackLocales === void 0 ? void 0 : fallbackLocales.default) || fallbackLocale;
      if (DEFAULT_FALLBACK) {
        if (!config.fallbackLocales)
          config.fallbackLocales = {};
        config.fallbackLocales.default = DEFAULT_FALLBACK;
      }
      if (config.fallbackLocales !== false && !config.fallbackLocales.default) {
        config.locales.forEach((locale) => {
          const fl = getCldrParentLocale(locale.toLowerCase());
          if (fl && !config.fallbackLocales[locale]) {
            config.fallbackLocales = {
              ...config.fallbackLocales,
              [locale]: fl
            };
          }
        });
      }
      return config;
    }
    function getCldrParentLocale(sourceLocale) {
      return {
        "en-ag": "en",
        "en-ai": "en",
        "en-au": "en",
        "en-bb": "en",
        "en-bm": "en",
        "en-bs": "en",
        "en-bw": "en",
        "en-bz": "en",
        "en-ca": "en",
        "en-cc": "en",
        "en-ck": "en",
        "en-cm": "en",
        "en-cx": "en",
        "en-cy": "en",
        "en-dg": "en",
        "en-dm": "en",
        "en-er": "en",
        "en-fj": "en",
        "en-fk": "en",
        "en-fm": "en",
        "en-gb": "en",
        "en-gd": "en",
        "en-gg": "en",
        "en-gh": "en",
        "en-gi": "en",
        "en-gm": "en",
        "en-gy": "en",
        "en-hk": "en",
        "en-ie": "en",
        "en-il": "en",
        "en-im": "en",
        "en-in": "en",
        "en-io": "en",
        "en-je": "en",
        "en-jm": "en",
        "en-ke": "en",
        "en-ki": "en",
        "en-kn": "en",
        "en-ky": "en",
        "en-lc": "en",
        "en-lr": "en",
        "en-ls": "en",
        "en-mg": "en",
        "en-mo": "en",
        "en-ms": "en",
        "en-mt": "en",
        "en-mu": "en",
        "en-mw": "en",
        "en-my": "en",
        "en-na": "en",
        "en-nf": "en",
        "en-ng": "en",
        "en-nr": "en",
        "en-nu": "en",
        "en-nz": "en",
        "en-pg": "en",
        "en-ph": "en",
        "en-pk": "en",
        "en-pn": "en",
        "en-pw": "en",
        "en-rw": "en",
        "en-sb": "en",
        "en-sc": "en",
        "en-sd": "en",
        "en-sg": "en",
        "en-sh": "en",
        "en-sl": "en",
        "en-ss": "en",
        "en-sx": "en",
        "en-sz": "en",
        "en-tc": "en",
        "en-tk": "en",
        "en-to": "en",
        "en-tt": "en",
        "en-tv": "en",
        "en-tz": "en",
        "en-ug": "en",
        "en-us": "en",
        "en-vc": "en",
        "en-vg": "en",
        "en-vu": "en",
        "en-ws": "en",
        "en-za": "en",
        "en-zm": "en",
        "en-zw": "en",
        "en-at": "en",
        "en-be": "en",
        "en-ch": "en",
        "en-de": "en",
        "en-dk": "en",
        "en-fi": "en",
        "en-nl": "en",
        "en-se": "en",
        "en-si": "en",
        "es-ar": "es",
        "es-bo": "es",
        "es-br": "es",
        "es-bz": "es",
        "es-cl": "es",
        "es-co": "es",
        "es-cr": "es",
        "es-cu": "es",
        "es-do": "es",
        "es-ec": "es",
        "es-es": "es",
        "es-gt": "es",
        "es-hn": "es",
        "es-mx": "es",
        "es-ni": "es",
        "es-pa": "es",
        "es-pe": "es",
        "es-pr": "es",
        "es-py": "es",
        "es-sv": "es",
        "es-us": "es",
        "es-uy": "es",
        "es-ve": "es",
        "pt-ao": "pt",
        "pt-ch": "pt",
        "pt-cv": "pt",
        "pt-fr": "pt",
        "pt-gq": "pt",
        "pt-gw": "pt",
        "pt-lu": "pt",
        "pt-mo": "pt",
        "pt-mz": "pt",
        "pt-pt": "pt",
        "pt-st": "pt",
        "pt-tl": "pt",
        "az-arab": "az",
        "az-cyrl": "az",
        "blt-latn": "blt",
        "bm-nkoo": "bm",
        "bs-cyrl": "bs",
        "byn-latn": "byn",
        "cu-glag": "cu",
        "dje-arab": "dje",
        "dyo-arab": "dyo",
        "en-dsrt": "en",
        "en-shaw": "en",
        "ff-adlm": "ff",
        "ff-arab": "ff",
        "ha-arab": "ha",
        "hi-latn": "hi",
        "iu-latn": "iu",
        "kk-arab": "kk",
        "ks-deva": "ks",
        "ku-arab": "ku",
        "ky-arab": "ky",
        "ky-latn": "ky",
        "ml-arab": "ml",
        "mn-mong": "mn",
        "mni-mtei": "mni",
        "ms-arab": "ms",
        "pa-arab": "pa",
        "sat-deva": "sat",
        "sd-deva": "sd",
        "sd-khoj": "sd",
        "sd-sind": "sd",
        "shi-latn": "shi",
        "so-arab": "so",
        "sr-latn": "sr",
        "sw-arab": "sw",
        "tg-arab": "tg",
        "ug-cyrl": "ug",
        "uz-arab": "uz",
        "uz-cyrl": "uz",
        "vai-latn": "vai",
        "wo-arab": "wo",
        "yo-arab": "yo",
        "yue-hans": "yue",
        "zh-hant": "zh",
        "zh-hant-hk": "zh",
        "zh-hant-mo": "zh-hant-hk"
      }[sourceLocale];
    }
    function catalogMigration(config) {
      let {
        localeDir,
        srcPathDirs,
        srcPathIgnorePatterns,
        ...newConfig
      } = config;
      if (localeDir || srcPathDirs || srcPathIgnorePatterns) {
        if (localeDir === void 0)
          localeDir = pathJoinPosix("<rootDir>", "locale", "{locale}", "messages");
        if (srcPathDirs === void 0)
          srcPathDirs = ["<rootDir>"];
        if (srcPathIgnorePatterns === void 0)
          srcPathIgnorePatterns = ["**/node_modules/**"];
        let newLocaleDir = localeDir.split(_path.default.sep).join("/");
        if (newLocaleDir.slice(-1) !== _path.default.sep) {
          newLocaleDir += "/";
        }
        if (!Array.isArray(newConfig.catalogs)) {
          newConfig.catalogs = [];
        }
        newConfig.catalogs.push({
          path: pathJoinPosix(newLocaleDir, "{locale}", "messages"),
          include: srcPathDirs,
          exclude: srcPathIgnorePatterns
        });
      }
      return newConfig;
    }
    var pipe2 = (...functions) => (args) => functions.reduce((arg, fn) => fn(arg), args);
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/F.js
var F, F_default;
var init_F = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/F.js"() {
    F = function() {
      return false;
    };
    F_default = F;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/T.js
var T, T_default;
var init_T = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/T.js"() {
    T = function() {
      return true;
    };
    T_default = T;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/__.js
var __default;
var init__ = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/__.js"() {
    __default = {
      "@@functional/placeholder": true
    };
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isPlaceholder.js
function _isPlaceholder(a) {
  return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
}
var init_isPlaceholder = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isPlaceholder.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_curry1.js
function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}
var init_curry1 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_curry1.js"() {
    init_isPlaceholder();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_curry2.js
function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
          return fn(a, _b);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}
var init_curry2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_curry2.js"() {
    init_curry1();
    init_isPlaceholder();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/add.js
var add, add_default;
var init_add = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/add.js"() {
    init_curry2();
    add = _curry2(function add2(a, b) {
      return Number(a) + Number(b);
    });
    add_default = add;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_concat.js
function _concat(set1, set22) {
  set1 = set1 || [];
  set22 = set22 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set22.length;
  var result = [];
  idx = 0;
  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }
  idx = 0;
  while (idx < len2) {
    result[result.length] = set22[idx];
    idx += 1;
  }
  return result;
}
var init_concat = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_concat.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_arity.js
function _arity(n, fn) {
  switch (n) {
    case 0:
      return function() {
        return fn.apply(this, arguments);
      };
    case 1:
      return function(a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function(a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function(a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function(a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function(a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function(a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function(a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function(a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
  }
}
var init_arity = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_arity.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_curryN.js
function _curryN(length4, received, fn) {
  return function() {
    var combined = [];
    var argsIdx = 0;
    var left = length4;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length4, combined, fn));
  };
}
var init_curryN = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_curryN.js"() {
    init_arity();
    init_isPlaceholder();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/curryN.js
var curryN, curryN_default;
var init_curryN2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/curryN.js"() {
    init_arity();
    init_curry1();
    init_curry2();
    init_curryN();
    curryN = _curry2(function curryN2(length4, fn) {
      if (length4 === 1) {
        return _curry1(fn);
      }
      return _arity(length4, _curryN(length4, [], fn));
    });
    curryN_default = curryN;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/addIndex.js
var addIndex, addIndex_default;
var init_addIndex = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/addIndex.js"() {
    init_concat();
    init_curry1();
    init_curryN2();
    addIndex = _curry1(function addIndex2(fn) {
      return curryN_default(fn.length, function() {
        var idx = 0;
        var origFn = arguments[0];
        var list = arguments[arguments.length - 1];
        var args = Array.prototype.slice.call(arguments, 0);
        args[0] = function() {
          var result = origFn.apply(this, _concat(arguments, [idx, list]));
          idx += 1;
          return result;
        };
        return fn.apply(this, args);
      });
    });
    addIndex_default = addIndex;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_curry3.js
function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder(a) ? f3 : _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        });
      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function(_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1(function(_c) {
          return fn(a, b, _c);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function(_a, _b) {
          return fn(_a, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function(_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1(function(_a) {
          return fn(_a, b, c);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1(function(_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}
var init_curry3 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_curry3.js"() {
    init_curry1();
    init_curry2();
    init_isPlaceholder();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/adjust.js
var adjust, adjust_default;
var init_adjust = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/adjust.js"() {
    init_concat();
    init_curry3();
    adjust = _curry3(function adjust2(idx, fn, list) {
      if (idx >= list.length || idx < -list.length) {
        return list;
      }
      var start = idx < 0 ? list.length : 0;
      var _idx = start + idx;
      var _list = _concat(list);
      _list[_idx] = fn(list[_idx]);
      return _list;
    });
    adjust_default = adjust;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isArray.js
var isArray_default;
var init_isArray = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isArray.js"() {
    isArray_default = Array.isArray || function _isArray(val) {
      return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
    };
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isTransformer.js
function _isTransformer(obj) {
  return obj != null && typeof obj["@@transducer/step"] === "function";
}
var init_isTransformer = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isTransformer.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_dispatchable.js
function _dispatchable(methodNames, xf, fn) {
  return function() {
    if (arguments.length === 0) {
      return fn();
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();
    if (!isArray_default(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === "function") {
          return obj[methodNames[idx]].apply(obj, args);
        }
        idx += 1;
      }
      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
}
var init_dispatchable = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_dispatchable.js"() {
    init_isArray();
    init_isTransformer();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_reduced.js
function _reduced(x) {
  return x && x["@@transducer/reduced"] ? x : {
    "@@transducer/value": x,
    "@@transducer/reduced": true
  };
}
var init_reduced = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_reduced.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfBase.js
var xfBase_default;
var init_xfBase = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfBase.js"() {
    xfBase_default = {
      init: function() {
        return this.xf["@@transducer/init"]();
      },
      result: function(result) {
        return this.xf["@@transducer/result"](result);
      }
    };
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xall.js
var XAll, _xall, xall_default;
var init_xall = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xall.js"() {
    init_curry2();
    init_reduced();
    init_xfBase();
    XAll = function() {
      function XAll2(f, xf) {
        this.xf = xf;
        this.f = f;
        this.all = true;
      }
      XAll2.prototype["@@transducer/init"] = xfBase_default.init;
      XAll2.prototype["@@transducer/result"] = function(result) {
        if (this.all) {
          result = this.xf["@@transducer/step"](result, true);
        }
        return this.xf["@@transducer/result"](result);
      };
      XAll2.prototype["@@transducer/step"] = function(result, input) {
        if (!this.f(input)) {
          this.all = false;
          result = _reduced(this.xf["@@transducer/step"](result, false));
        }
        return result;
      };
      return XAll2;
    }();
    _xall = _curry2(function _xall2(f, xf) {
      return new XAll(f, xf);
    });
    xall_default = _xall;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/all.js
var all, all_default;
var init_all = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/all.js"() {
    init_curry2();
    init_dispatchable();
    init_xall();
    all = _curry2(
      _dispatchable(["all"], xall_default, function all2(fn, list) {
        var idx = 0;
        while (idx < list.length) {
          if (!fn(list[idx])) {
            return false;
          }
          idx += 1;
        }
        return true;
      })
    );
    all_default = all;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/max.js
var max, max_default;
var init_max = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/max.js"() {
    init_curry2();
    max = _curry2(function max2(a, b) {
      return b > a ? b : a;
    });
    max_default = max;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_map.js
function _map(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }
  return result;
}
var init_map = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_map.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isString.js
function _isString(x) {
  return Object.prototype.toString.call(x) === "[object String]";
}
var init_isString = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isString.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isArrayLike.js
var _isArrayLike, isArrayLike_default;
var init_isArrayLike = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isArrayLike.js"() {
    init_curry1();
    init_isArray();
    init_isString();
    _isArrayLike = _curry1(function isArrayLike(x) {
      if (isArray_default(x)) {
        return true;
      }
      if (!x) {
        return false;
      }
      if (typeof x !== "object") {
        return false;
      }
      if (_isString(x)) {
        return false;
      }
      if (x.nodeType === 1) {
        return !!x.length;
      }
      if (x.length === 0) {
        return true;
      }
      if (x.length > 0) {
        return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
      }
      return false;
    });
    isArrayLike_default = _isArrayLike;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xwrap.js
function _xwrap(fn) {
  return new XWrap(fn);
}
var XWrap;
var init_xwrap = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xwrap.js"() {
    XWrap = function() {
      function XWrap2(fn) {
        this.f = fn;
      }
      XWrap2.prototype["@@transducer/init"] = function() {
        throw new Error("init not implemented on XWrap");
      };
      XWrap2.prototype["@@transducer/result"] = function(acc) {
        return acc;
      };
      XWrap2.prototype["@@transducer/step"] = function(acc, x) {
        return this.f(acc, x);
      };
      return XWrap2;
    }();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/bind.js
var bind, bind_default;
var init_bind = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/bind.js"() {
    init_arity();
    init_curry2();
    bind = _curry2(function bind2(fn, thisObj) {
      return _arity(fn.length, function() {
        return fn.apply(thisObj, arguments);
      });
    });
    bind_default = bind;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_reduce.js
function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    acc = xf["@@transducer/step"](acc, list[idx]);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    idx += 1;
  }
  return xf["@@transducer/result"](acc);
}
function _iterableReduce(xf, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = xf["@@transducer/step"](acc, step.value);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    step = iter.next();
  }
  return xf["@@transducer/result"](acc);
}
function _methodReduce(xf, acc, obj, methodName) {
  return xf["@@transducer/result"](obj[methodName](bind_default(xf["@@transducer/step"], xf), acc));
}
function _reduce(fn, acc, list) {
  if (typeof fn === "function") {
    fn = _xwrap(fn);
  }
  if (isArrayLike_default(list)) {
    return _arrayReduce(fn, acc, list);
  }
  if (typeof list["fantasy-land/reduce"] === "function") {
    return _methodReduce(fn, acc, list, "fantasy-land/reduce");
  }
  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }
  if (typeof list.next === "function") {
    return _iterableReduce(fn, acc, list);
  }
  if (typeof list.reduce === "function") {
    return _methodReduce(fn, acc, list, "reduce");
  }
  throw new TypeError("reduce: list must be array or iterable");
}
var symIterator;
var init_reduce = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_reduce.js"() {
    init_isArrayLike();
    init_xwrap();
    init_bind();
    symIterator = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xmap.js
var XMap, _xmap, xmap_default;
var init_xmap = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xmap.js"() {
    init_curry2();
    init_xfBase();
    XMap = function() {
      function XMap2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XMap2.prototype["@@transducer/init"] = xfBase_default.init;
      XMap2.prototype["@@transducer/result"] = xfBase_default.result;
      XMap2.prototype["@@transducer/step"] = function(result, input) {
        return this.xf["@@transducer/step"](result, this.f(input));
      };
      return XMap2;
    }();
    _xmap = _curry2(function _xmap2(f, xf) {
      return new XMap(f, xf);
    });
    xmap_default = _xmap;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_has.js
function _has(prop3, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop3);
}
var init_has = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_has.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isArguments.js
var toString, _isArguments, isArguments_default;
var init_isArguments = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isArguments.js"() {
    init_has();
    toString = Object.prototype.toString;
    _isArguments = function() {
      return toString.call(arguments) === "[object Arguments]" ? function _isArguments2(x) {
        return toString.call(x) === "[object Arguments]";
      } : function _isArguments2(x) {
        return _has("callee", x);
      };
    }();
    isArguments_default = _isArguments;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/keys.js
var hasEnumBug, nonEnumerableProps, hasArgsEnumBug, contains, keys, keys_default;
var init_keys = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/keys.js"() {
    init_curry1();
    init_has();
    init_isArguments();
    hasEnumBug = !{
      toString: null
    }.propertyIsEnumerable("toString");
    nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
    hasArgsEnumBug = function() {
      "use strict";
      return arguments.propertyIsEnumerable("length");
    }();
    contains = function contains2(list, item) {
      var idx = 0;
      while (idx < list.length) {
        if (list[idx] === item) {
          return true;
        }
        idx += 1;
      }
      return false;
    };
    keys = typeof Object.keys === "function" && !hasArgsEnumBug ? _curry1(function keys2(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    }) : _curry1(function keys3(obj) {
      if (Object(obj) !== obj) {
        return [];
      }
      var prop3, nIdx;
      var ks = [];
      var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);
      for (prop3 in obj) {
        if (_has(prop3, obj) && (!checkArgsLength || prop3 !== "length")) {
          ks[ks.length] = prop3;
        }
      }
      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;
        while (nIdx >= 0) {
          prop3 = nonEnumerableProps[nIdx];
          if (_has(prop3, obj) && !contains(ks, prop3)) {
            ks[ks.length] = prop3;
          }
          nIdx -= 1;
        }
      }
      return ks;
    });
    keys_default = keys;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/map.js
var map2, map_default;
var init_map2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/map.js"() {
    init_curry2();
    init_dispatchable();
    init_map();
    init_reduce();
    init_xmap();
    init_curryN2();
    init_keys();
    map2 = _curry2(
      _dispatchable(["fantasy-land/map", "map"], xmap_default, function map3(fn, functor) {
        switch (Object.prototype.toString.call(functor)) {
          case "[object Function]":
            return curryN_default(functor.length, function() {
              return fn.call(this, functor.apply(this, arguments));
            });
          case "[object Object]":
            return _reduce(function(acc, key) {
              acc[key] = fn(functor[key]);
              return acc;
            }, {}, keys_default(functor));
          default:
            return _map(fn, functor);
        }
      })
    );
    map_default = map2;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isInteger.js
var isInteger_default;
var init_isInteger = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isInteger.js"() {
    isInteger_default = Number.isInteger || function _isInteger(n) {
      return n << 0 === n;
    };
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/nth.js
var nth, nth_default;
var init_nth = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/nth.js"() {
    init_curry2();
    init_isString();
    nth = _curry2(function nth2(offset, list) {
      var idx = offset < 0 ? list.length + offset : offset;
      return _isString(list) ? list.charAt(idx) : list[idx];
    });
    nth_default = nth;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/paths.js
var paths, paths_default;
var init_paths = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/paths.js"() {
    init_curry2();
    init_isInteger();
    init_nth();
    paths = _curry2(function paths2(pathsArray, obj) {
      return pathsArray.map(function(paths3) {
        var val = obj;
        var idx = 0;
        var p;
        while (idx < paths3.length) {
          if (val == null) {
            return;
          }
          p = paths3[idx];
          val = isInteger_default(p) ? nth_default(p, val) : val[p];
          idx += 1;
        }
        return val;
      });
    });
    paths_default = paths;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/path.js
var path, path_default;
var init_path = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/path.js"() {
    init_curry2();
    init_paths();
    path = _curry2(function path2(pathAr, obj) {
      return paths_default([pathAr], obj)[0];
    });
    path_default = path;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/prop.js
var prop, prop_default;
var init_prop = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/prop.js"() {
    init_curry2();
    init_path();
    prop = _curry2(function prop2(p, obj) {
      return path_default([p], obj);
    });
    prop_default = prop;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pluck.js
var pluck, pluck_default;
var init_pluck = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pluck.js"() {
    init_curry2();
    init_map2();
    init_prop();
    pluck = _curry2(function pluck2(p, list) {
      return map_default(prop_default(p), list);
    });
    pluck_default = pluck;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reduce.js
var reduce, reduce_default;
var init_reduce2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reduce.js"() {
    init_curry3();
    init_reduce();
    reduce = _curry3(_reduce);
    reduce_default = reduce;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/allPass.js
var allPass, allPass_default;
var init_allPass = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/allPass.js"() {
    init_curry1();
    init_curryN2();
    init_max();
    init_pluck();
    init_reduce2();
    allPass = _curry1(function allPass2(preds) {
      return curryN_default(reduce_default(max_default, 0, pluck_default("length", preds)), function() {
        var idx = 0;
        var len = preds.length;
        while (idx < len) {
          if (!preds[idx].apply(this, arguments)) {
            return false;
          }
          idx += 1;
        }
        return true;
      });
    });
    allPass_default = allPass;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/always.js
var always, always_default;
var init_always = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/always.js"() {
    init_curry1();
    always = _curry1(function always2(val) {
      return function() {
        return val;
      };
    });
    always_default = always;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/and.js
var and, and_default;
var init_and = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/and.js"() {
    init_curry2();
    and = _curry2(function and2(a, b) {
      return a && b;
    });
    and_default = and;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xany.js
var XAny, _xany, xany_default;
var init_xany = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xany.js"() {
    init_curry2();
    init_reduced();
    init_xfBase();
    XAny = function() {
      function XAny2(f, xf) {
        this.xf = xf;
        this.f = f;
        this.any = false;
      }
      XAny2.prototype["@@transducer/init"] = xfBase_default.init;
      XAny2.prototype["@@transducer/result"] = function(result) {
        if (!this.any) {
          result = this.xf["@@transducer/step"](result, false);
        }
        return this.xf["@@transducer/result"](result);
      };
      XAny2.prototype["@@transducer/step"] = function(result, input) {
        if (this.f(input)) {
          this.any = true;
          result = _reduced(this.xf["@@transducer/step"](result, true));
        }
        return result;
      };
      return XAny2;
    }();
    _xany = _curry2(function _xany2(f, xf) {
      return new XAny(f, xf);
    });
    xany_default = _xany;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/any.js
var any, any_default;
var init_any = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/any.js"() {
    init_curry2();
    init_dispatchable();
    init_xany();
    any = _curry2(
      _dispatchable(["any"], xany_default, function any2(fn, list) {
        var idx = 0;
        while (idx < list.length) {
          if (fn(list[idx])) {
            return true;
          }
          idx += 1;
        }
        return false;
      })
    );
    any_default = any;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/anyPass.js
var anyPass, anyPass_default;
var init_anyPass = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/anyPass.js"() {
    init_curry1();
    init_curryN2();
    init_max();
    init_pluck();
    init_reduce2();
    anyPass = _curry1(function anyPass2(preds) {
      return curryN_default(reduce_default(max_default, 0, pluck_default("length", preds)), function() {
        var idx = 0;
        var len = preds.length;
        while (idx < len) {
          if (preds[idx].apply(this, arguments)) {
            return true;
          }
          idx += 1;
        }
        return false;
      });
    });
    anyPass_default = anyPass;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/ap.js
var ap, ap_default;
var init_ap = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/ap.js"() {
    init_concat();
    init_curry2();
    init_reduce();
    init_map2();
    ap = _curry2(function ap2(applyF, applyX) {
      return typeof applyX["fantasy-land/ap"] === "function" ? applyX["fantasy-land/ap"](applyF) : typeof applyF.ap === "function" ? applyF.ap(applyX) : typeof applyF === "function" ? function(x) {
        return applyF(x)(applyX(x));
      } : _reduce(function(acc, f) {
        return _concat(acc, map_default(f, applyX));
      }, [], applyF);
    });
    ap_default = ap;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_aperture.js
function _aperture(n, list) {
  var idx = 0;
  var limit = list.length - (n - 1);
  var acc = new Array(limit >= 0 ? limit : 0);
  while (idx < limit) {
    acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
    idx += 1;
  }
  return acc;
}
var init_aperture = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_aperture.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xaperture.js
var XAperture, _xaperture, xaperture_default;
var init_xaperture = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xaperture.js"() {
    init_concat();
    init_curry2();
    init_xfBase();
    XAperture = function() {
      function XAperture2(n, xf) {
        this.xf = xf;
        this.pos = 0;
        this.full = false;
        this.acc = new Array(n);
      }
      XAperture2.prototype["@@transducer/init"] = xfBase_default.init;
      XAperture2.prototype["@@transducer/result"] = function(result) {
        this.acc = null;
        return this.xf["@@transducer/result"](result);
      };
      XAperture2.prototype["@@transducer/step"] = function(result, input) {
        this.store(input);
        return this.full ? this.xf["@@transducer/step"](result, this.getCopy()) : result;
      };
      XAperture2.prototype.store = function(input) {
        this.acc[this.pos] = input;
        this.pos += 1;
        if (this.pos === this.acc.length) {
          this.pos = 0;
          this.full = true;
        }
      };
      XAperture2.prototype.getCopy = function() {
        return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
      };
      return XAperture2;
    }();
    _xaperture = _curry2(function _xaperture2(n, xf) {
      return new XAperture(n, xf);
    });
    xaperture_default = _xaperture;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/aperture.js
var aperture, aperture_default;
var init_aperture2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/aperture.js"() {
    init_aperture();
    init_curry2();
    init_dispatchable();
    init_xaperture();
    aperture = _curry2(
      _dispatchable([], xaperture_default, _aperture)
    );
    aperture_default = aperture;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/append.js
var append, append_default;
var init_append = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/append.js"() {
    init_concat();
    init_curry2();
    append = _curry2(function append2(el, list) {
      return _concat(list, [el]);
    });
    append_default = append;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/apply.js
var apply, apply_default;
var init_apply = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/apply.js"() {
    init_curry2();
    apply = _curry2(function apply2(fn, args) {
      return fn.apply(this, args);
    });
    apply_default = apply;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/values.js
var values, values_default;
var init_values = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/values.js"() {
    init_curry1();
    init_keys();
    values = _curry1(function values2(obj) {
      var props3 = keys_default(obj);
      var len = props3.length;
      var vals = [];
      var idx = 0;
      while (idx < len) {
        vals[idx] = obj[props3[idx]];
        idx += 1;
      }
      return vals;
    });
    values_default = values;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/applySpec.js
function mapValues(fn, obj) {
  return keys_default(obj).reduce(function(acc, key) {
    acc[key] = fn(obj[key]);
    return acc;
  }, {});
}
var applySpec, applySpec_default;
var init_applySpec = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/applySpec.js"() {
    init_curry1();
    init_apply();
    init_curryN2();
    init_max();
    init_pluck();
    init_reduce2();
    init_keys();
    init_values();
    applySpec = _curry1(function applySpec2(spec) {
      spec = mapValues(function(v) {
        return typeof v == "function" ? v : applySpec2(v);
      }, spec);
      return curryN_default(reduce_default(max_default, 0, pluck_default("length", values_default(spec))), function() {
        var args = arguments;
        return mapValues(function(f) {
          return apply_default(f, args);
        }, spec);
      });
    });
    applySpec_default = applySpec;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/applyTo.js
var applyTo, applyTo_default;
var init_applyTo = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/applyTo.js"() {
    init_curry2();
    applyTo = _curry2(function applyTo2(x, f) {
      return f(x);
    });
    applyTo_default = applyTo;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/ascend.js
var ascend, ascend_default;
var init_ascend = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/ascend.js"() {
    init_curry3();
    ascend = _curry3(function ascend2(fn, a, b) {
      var aa = fn(a);
      var bb = fn(b);
      return aa < bb ? -1 : aa > bb ? 1 : 0;
    });
    ascend_default = ascend;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/assoc.js
var assoc, assoc_default;
var init_assoc = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/assoc.js"() {
    init_curry3();
    assoc = _curry3(function assoc2(prop3, val, obj) {
      var result = {};
      for (var p in obj) {
        result[p] = obj[p];
      }
      result[prop3] = val;
      return result;
    });
    assoc_default = assoc;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/isNil.js
var isNil, isNil_default;
var init_isNil = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/isNil.js"() {
    init_curry1();
    isNil = _curry1(function isNil2(x) {
      return x == null;
    });
    isNil_default = isNil;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/assocPath.js
var assocPath, assocPath_default;
var init_assocPath = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/assocPath.js"() {
    init_curry3();
    init_has();
    init_isArray();
    init_isInteger();
    init_assoc();
    init_isNil();
    assocPath = _curry3(function assocPath2(path3, val, obj) {
      if (path3.length === 0) {
        return val;
      }
      var idx = path3[0];
      if (path3.length > 1) {
        var nextObj = !isNil_default(obj) && _has(idx, obj) ? obj[idx] : isInteger_default(path3[1]) ? [] : {};
        val = assocPath2(Array.prototype.slice.call(path3, 1), val, nextObj);
      }
      if (isInteger_default(idx) && isArray_default(obj)) {
        var arr = [].concat(obj);
        arr[idx] = val;
        return arr;
      } else {
        return assoc_default(idx, val, obj);
      }
    });
    assocPath_default = assocPath;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/nAry.js
var nAry, nAry_default;
var init_nAry = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/nAry.js"() {
    init_curry2();
    nAry = _curry2(function nAry2(n, fn) {
      switch (n) {
        case 0:
          return function() {
            return fn.call(this);
          };
        case 1:
          return function(a0) {
            return fn.call(this, a0);
          };
        case 2:
          return function(a0, a1) {
            return fn.call(this, a0, a1);
          };
        case 3:
          return function(a0, a1, a2) {
            return fn.call(this, a0, a1, a2);
          };
        case 4:
          return function(a0, a1, a2, a3) {
            return fn.call(this, a0, a1, a2, a3);
          };
        case 5:
          return function(a0, a1, a2, a3, a4) {
            return fn.call(this, a0, a1, a2, a3, a4);
          };
        case 6:
          return function(a0, a1, a2, a3, a4, a5) {
            return fn.call(this, a0, a1, a2, a3, a4, a5);
          };
        case 7:
          return function(a0, a1, a2, a3, a4, a5, a6) {
            return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
          };
        case 8:
          return function(a0, a1, a2, a3, a4, a5, a6, a7) {
            return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
          };
        case 9:
          return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
            return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
          };
        case 10:
          return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          };
        default:
          throw new Error("First argument to nAry must be a non-negative integer no greater than ten");
      }
    });
    nAry_default = nAry;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/binary.js
var binary2, binary_default;
var init_binary = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/binary.js"() {
    init_curry1();
    init_nAry();
    binary2 = _curry1(function binary3(fn) {
      return nAry_default(2, fn);
    });
    binary_default = binary2;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isFunction.js
function _isFunction(x) {
  var type3 = Object.prototype.toString.call(x);
  return type3 === "[object Function]" || type3 === "[object AsyncFunction]" || type3 === "[object GeneratorFunction]" || type3 === "[object AsyncGeneratorFunction]";
}
var init_isFunction = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isFunction.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/liftN.js
var liftN, liftN_default;
var init_liftN = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/liftN.js"() {
    init_curry2();
    init_reduce();
    init_ap();
    init_curryN2();
    init_map2();
    liftN = _curry2(function liftN2(arity, fn) {
      var lifted = curryN_default(arity, fn);
      return curryN_default(arity, function() {
        return _reduce(ap_default, map_default(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
      });
    });
    liftN_default = liftN;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lift.js
var lift, lift_default;
var init_lift = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lift.js"() {
    init_curry1();
    init_liftN();
    lift = _curry1(function lift2(fn) {
      return liftN_default(fn.length, fn);
    });
    lift_default = lift;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/both.js
var both, both_default;
var init_both = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/both.js"() {
    init_curry2();
    init_isFunction();
    init_and();
    init_lift();
    both = _curry2(function both2(f, g) {
      return _isFunction(f) ? function _both() {
        return f.apply(this, arguments) && g.apply(this, arguments);
      } : lift_default(and_default)(f, g);
    });
    both_default = both;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/curry.js
var curry, curry_default;
var init_curry = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/curry.js"() {
    init_curry1();
    init_curryN2();
    curry = _curry1(function curry2(fn) {
      return curryN_default(fn.length, fn);
    });
    curry_default = curry;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/call.js
var call, call_default;
var init_call = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/call.js"() {
    init_curry();
    call = curry_default(function call2(fn) {
      return fn.apply(this, Array.prototype.slice.call(arguments, 1));
    });
    call_default = call;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_makeFlat.js
function _makeFlat(recursive) {
  return function flatt(list) {
    var value2, jlen, j;
    var result = [];
    var idx = 0;
    var ilen = list.length;
    while (idx < ilen) {
      if (isArrayLike_default(list[idx])) {
        value2 = recursive ? flatt(list[idx]) : list[idx];
        j = 0;
        jlen = value2.length;
        while (j < jlen) {
          result[result.length] = value2[j];
          j += 1;
        }
      } else {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
    return result;
  };
}
var init_makeFlat = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_makeFlat.js"() {
    init_isArrayLike();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_forceReduced.js
function _forceReduced(x) {
  return {
    "@@transducer/value": x,
    "@@transducer/reduced": true
  };
}
var init_forceReduced = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_forceReduced.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_flatCat.js
var preservingReduced, _flatCat, flatCat_default;
var init_flatCat = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_flatCat.js"() {
    init_forceReduced();
    init_isArrayLike();
    init_reduce();
    init_xfBase();
    preservingReduced = function(xf) {
      return {
        "@@transducer/init": xfBase_default.init,
        "@@transducer/result": function(result) {
          return xf["@@transducer/result"](result);
        },
        "@@transducer/step": function(result, input) {
          var ret = xf["@@transducer/step"](result, input);
          return ret["@@transducer/reduced"] ? _forceReduced(ret) : ret;
        }
      };
    };
    _flatCat = function _xcat(xf) {
      var rxf = preservingReduced(xf);
      return {
        "@@transducer/init": xfBase_default.init,
        "@@transducer/result": function(result) {
          return rxf["@@transducer/result"](result);
        },
        "@@transducer/step": function(result, input) {
          return !isArrayLike_default(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
        }
      };
    };
    flatCat_default = _flatCat;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xchain.js
var _xchain, xchain_default;
var init_xchain = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xchain.js"() {
    init_curry2();
    init_flatCat();
    init_map2();
    _xchain = _curry2(function _xchain2(f, xf) {
      return map_default(f, flatCat_default(xf));
    });
    xchain_default = _xchain;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/chain.js
var chain, chain_default;
var init_chain = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/chain.js"() {
    init_curry2();
    init_dispatchable();
    init_makeFlat();
    init_xchain();
    init_map2();
    chain = _curry2(
      _dispatchable(["fantasy-land/chain", "chain"], xchain_default, function chain2(fn, monad) {
        if (typeof monad === "function") {
          return function(x) {
            return fn(monad(x))(x);
          };
        }
        return _makeFlat(false)(map_default(fn, monad));
      })
    );
    chain_default = chain;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/clamp.js
var clamp, clamp_default;
var init_clamp = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/clamp.js"() {
    init_curry3();
    clamp = _curry3(function clamp2(min3, max3, value2) {
      if (min3 > max3) {
        throw new Error("min must not be greater than max in clamp(min, max, value)");
      }
      return value2 < min3 ? min3 : value2 > max3 ? max3 : value2;
    });
    clamp_default = clamp;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_cloneRegExp.js
function _cloneRegExp(pattern) {
  return new RegExp(pattern.source, (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : ""));
}
var init_cloneRegExp = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_cloneRegExp.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/type.js
var type, type_default;
var init_type = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/type.js"() {
    init_curry1();
    type = _curry1(function type2(val) {
      return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
    });
    type_default = type;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_clone.js
function _clone(value2, refFrom, refTo, deep) {
  var copy = function copy2(copiedValue) {
    var len = refFrom.length;
    var idx = 0;
    while (idx < len) {
      if (value2 === refFrom[idx]) {
        return refTo[idx];
      }
      idx += 1;
    }
    refFrom[idx + 1] = value2;
    refTo[idx + 1] = copiedValue;
    for (var key in value2) {
      copiedValue[key] = deep ? _clone(value2[key], refFrom, refTo, true) : value2[key];
    }
    return copiedValue;
  };
  switch (type_default(value2)) {
    case "Object":
      return copy({});
    case "Array":
      return copy([]);
    case "Date":
      return new Date(value2.valueOf());
    case "RegExp":
      return _cloneRegExp(value2);
    default:
      return value2;
  }
}
var init_clone = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_clone.js"() {
    init_cloneRegExp();
    init_type();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/clone.js
var clone, clone_default;
var init_clone2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/clone.js"() {
    init_clone();
    init_curry1();
    clone = _curry1(function clone2(value2) {
      return value2 != null && typeof value2.clone === "function" ? value2.clone() : _clone(value2, [], [], true);
    });
    clone_default = clone;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/comparator.js
var comparator, comparator_default;
var init_comparator = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/comparator.js"() {
    init_curry1();
    comparator = _curry1(function comparator2(pred) {
      return function(a, b) {
        return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
      };
    });
    comparator_default = comparator;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/not.js
var not, not_default;
var init_not = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/not.js"() {
    init_curry1();
    not = _curry1(function not2(a) {
      return !a;
    });
    not_default = not;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/complement.js
var complement, complement_default;
var init_complement = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/complement.js"() {
    init_lift();
    init_not();
    complement = lift_default(not_default);
    complement_default = complement;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_pipe.js
function _pipe(f, g) {
  return function() {
    return g.call(this, f.apply(this, arguments));
  };
}
var init_pipe = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_pipe.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_checkForMethod.js
function _checkForMethod(methodname, fn) {
  return function() {
    var length4 = arguments.length;
    if (length4 === 0) {
      return fn();
    }
    var obj = arguments[length4 - 1];
    return isArray_default(obj) || typeof obj[methodname] !== "function" ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length4 - 1));
  };
}
var init_checkForMethod = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_checkForMethod.js"() {
    init_isArray();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/slice.js
var slice, slice_default;
var init_slice = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/slice.js"() {
    init_checkForMethod();
    init_curry3();
    slice = _curry3(
      _checkForMethod("slice", function slice2(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
      })
    );
    slice_default = slice;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/tail.js
var tail, tail_default;
var init_tail = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/tail.js"() {
    init_checkForMethod();
    init_curry1();
    init_slice();
    tail = _curry1(
      _checkForMethod(
        "tail",
        slice_default(1, Infinity)
      )
    );
    tail_default = tail;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pipe.js
function pipe() {
  if (arguments.length === 0) {
    throw new Error("pipe requires at least one argument");
  }
  return _arity(arguments[0].length, reduce_default(_pipe, arguments[0], tail_default(arguments)));
}
var init_pipe2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pipe.js"() {
    init_arity();
    init_pipe();
    init_reduce2();
    init_tail();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reverse.js
var reverse, reverse_default;
var init_reverse = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reverse.js"() {
    init_curry1();
    init_isString();
    reverse = _curry1(function reverse2(list) {
      return _isString(list) ? list.split("").reverse().join("") : Array.prototype.slice.call(list, 0).reverse();
    });
    reverse_default = reverse;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/compose.js
function compose() {
  if (arguments.length === 0) {
    throw new Error("compose requires at least one argument");
  }
  return pipe.apply(this, reverse_default(arguments));
}
var init_compose = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/compose.js"() {
    init_pipe2();
    init_reverse();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/composeK.js
function composeK() {
  if (arguments.length === 0) {
    throw new Error("composeK requires at least one argument");
  }
  var init2 = Array.prototype.slice.call(arguments);
  var last2 = init2.pop();
  return compose(compose.apply(this, map_default(chain_default, init2)), last2);
}
var init_composeK = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/composeK.js"() {
    init_chain();
    init_compose();
    init_map2();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_pipeP.js
function _pipeP(f, g) {
  return function() {
    var ctx = this;
    return f.apply(ctx, arguments).then(function(x) {
      return g.call(ctx, x);
    });
  };
}
var init_pipeP = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_pipeP.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pipeP.js
function pipeP() {
  if (arguments.length === 0) {
    throw new Error("pipeP requires at least one argument");
  }
  return _arity(arguments[0].length, reduce_default(_pipeP, arguments[0], tail_default(arguments)));
}
var init_pipeP2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pipeP.js"() {
    init_arity();
    init_pipeP();
    init_reduce2();
    init_tail();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/composeP.js
function composeP() {
  if (arguments.length === 0) {
    throw new Error("composeP requires at least one argument");
  }
  return pipeP.apply(this, reverse_default(arguments));
}
var init_composeP = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/composeP.js"() {
    init_pipeP2();
    init_reverse();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/head.js
var head, head_default;
var init_head = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/head.js"() {
    init_nth();
    head = nth_default(0);
    head_default = head;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_identity.js
function _identity(x) {
  return x;
}
var init_identity = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_identity.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/identity.js
var identity, identity_default;
var init_identity2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/identity.js"() {
    init_curry1();
    init_identity();
    identity = _curry1(_identity);
    identity_default = identity;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pipeWith.js
var pipeWith, pipeWith_default;
var init_pipeWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pipeWith.js"() {
    init_arity();
    init_curry2();
    init_head();
    init_reduce();
    init_tail();
    init_identity2();
    pipeWith = _curry2(function pipeWith2(xf, list) {
      if (list.length <= 0) {
        return identity_default;
      }
      var headList = head_default(list);
      var tailList = tail_default(list);
      return _arity(headList.length, function() {
        return _reduce(function(result, f) {
          return xf.call(this, f, result);
        }, headList.apply(this, arguments), tailList);
      });
    });
    pipeWith_default = pipeWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/composeWith.js
var composeWith, composeWith_default;
var init_composeWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/composeWith.js"() {
    init_curry2();
    init_pipeWith();
    init_reverse();
    composeWith = _curry2(function composeWith2(xf, list) {
      return pipeWith_default.apply(this, [xf, reverse_default(list)]);
    });
    composeWith_default = composeWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_arrayFromIterator.js
function _arrayFromIterator(iter) {
  var list = [];
  var next;
  while (!(next = iter.next()).done) {
    list.push(next.value);
  }
  return list;
}
var init_arrayFromIterator = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_arrayFromIterator.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_includesWith.js
function _includesWith(pred, x, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (pred(x, list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}
var init_includesWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_includesWith.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_functionName.js
function _functionName(f) {
  var match3 = String(f).match(/^function (\w*)/);
  return match3 == null ? "" : match3[1];
}
var init_functionName = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_functionName.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_objectIs.js
function _objectIs(a, b) {
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  } else {
    return a !== a && b !== b;
  }
}
var objectIs_default;
var init_objectIs = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_objectIs.js"() {
    objectIs_default = typeof Object.is === "function" ? Object.is : _objectIs;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_equals.js
function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a = _arrayFromIterator(aIterator);
  var b = _arrayFromIterator(bIterator);
  function eq(_a, _b) {
    return _equals(_a, _b, stackA.slice(), stackB.slice());
  }
  return !_includesWith(function(b2, aItem) {
    return !_includesWith(eq, aItem, b2);
  }, b, a);
}
function _equals(a, b, stackA, stackB) {
  if (objectIs_default(a, b)) {
    return true;
  }
  var typeA = type_default(a);
  if (typeA !== type_default(b)) {
    return false;
  }
  if (a == null || b == null) {
    return false;
  }
  if (typeof a["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
    return typeof a["fantasy-land/equals"] === "function" && a["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a);
  }
  if (typeof a.equals === "function" || typeof b.equals === "function") {
    return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
  }
  switch (typeA) {
    case "Arguments":
    case "Array":
    case "Object":
      if (typeof a.constructor === "function" && _functionName(a.constructor) === "Promise") {
        return a === b;
      }
      break;
    case "Boolean":
    case "Number":
    case "String":
      if (!(typeof a === typeof b && objectIs_default(a.valueOf(), b.valueOf()))) {
        return false;
      }
      break;
    case "Date":
      if (!objectIs_default(a.valueOf(), b.valueOf())) {
        return false;
      }
      break;
    case "Error":
      return a.name === b.name && a.message === b.message;
    case "RegExp":
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }
      break;
  }
  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }
    idx -= 1;
  }
  switch (typeA) {
    case "Map":
      if (a.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
    case "Set":
      if (a.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
    case "Arguments":
    case "Array":
    case "Object":
    case "Boolean":
    case "Number":
    case "String":
    case "Date":
    case "Error":
    case "RegExp":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "ArrayBuffer":
      break;
    default:
      return false;
  }
  var keysA = keys_default(a);
  if (keysA.length !== keys_default(b).length) {
    return false;
  }
  var extendedStackA = stackA.concat([a]);
  var extendedStackB = stackB.concat([b]);
  idx = keysA.length - 1;
  while (idx >= 0) {
    var key = keysA[idx];
    if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
      return false;
    }
    idx -= 1;
  }
  return true;
}
var init_equals = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_equals.js"() {
    init_arrayFromIterator();
    init_includesWith();
    init_functionName();
    init_has();
    init_objectIs();
    init_keys();
    init_type();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/equals.js
var equals, equals_default;
var init_equals2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/equals.js"() {
    init_curry2();
    init_equals();
    equals = _curry2(function equals2(a, b) {
      return _equals(a, b, [], []);
    });
    equals_default = equals;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_indexOf.js
function _indexOf(list, a, idx) {
  var inf, item;
  if (typeof list.indexOf === "function") {
    switch (typeof a) {
      case "number":
        if (a === 0) {
          inf = 1 / a;
          while (idx < list.length) {
            item = list[idx];
            if (item === 0 && 1 / item === inf) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        } else if (a !== a) {
          while (idx < list.length) {
            item = list[idx];
            if (typeof item === "number" && item !== item) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        }
        return list.indexOf(a, idx);
      case "string":
      case "boolean":
      case "function":
      case "undefined":
        return list.indexOf(a, idx);
      case "object":
        if (a === null) {
          return list.indexOf(a, idx);
        }
    }
  }
  while (idx < list.length) {
    if (equals_default(list[idx], a)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}
var init_indexOf = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_indexOf.js"() {
    init_equals2();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_includes.js
function _includes(a, list) {
  return _indexOf(list, a, 0) >= 0;
}
var init_includes = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_includes.js"() {
    init_indexOf();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_quote.js
function _quote(s) {
  var escaped = s.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\f/g, "\\f").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\v/g, "\\v").replace(/\0/g, "\\0");
  return '"' + escaped.replace(/"/g, '\\"') + '"';
}
var init_quote = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_quote.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_toISOString.js
var pad, _toISOString, toISOString_default;
var init_toISOString = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_toISOString.js"() {
    pad = function pad2(n) {
      return (n < 10 ? "0" : "") + n;
    };
    _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d) {
      return d.toISOString();
    } : function _toISOString3(d) {
      return d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "." + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
    };
    toISOString_default = _toISOString;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_complement.js
function _complement(f) {
  return function() {
    return !f.apply(this, arguments);
  };
}
var init_complement2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_complement.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_filter.js
function _filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
}
var init_filter = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_filter.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isObject.js
function _isObject(x) {
  return Object.prototype.toString.call(x) === "[object Object]";
}
var init_isObject = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isObject.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfilter.js
var XFilter, _xfilter, xfilter_default;
var init_xfilter = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfilter.js"() {
    init_curry2();
    init_xfBase();
    XFilter = function() {
      function XFilter2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XFilter2.prototype["@@transducer/init"] = xfBase_default.init;
      XFilter2.prototype["@@transducer/result"] = xfBase_default.result;
      XFilter2.prototype["@@transducer/step"] = function(result, input) {
        return this.f(input) ? this.xf["@@transducer/step"](result, input) : result;
      };
      return XFilter2;
    }();
    _xfilter = _curry2(function _xfilter2(f, xf) {
      return new XFilter(f, xf);
    });
    xfilter_default = _xfilter;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/filter.js
var filter, filter_default;
var init_filter2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/filter.js"() {
    init_curry2();
    init_dispatchable();
    init_filter();
    init_isObject();
    init_reduce();
    init_xfilter();
    init_keys();
    filter = _curry2(
      _dispatchable(["filter"], xfilter_default, function(pred, filterable) {
        return _isObject(filterable) ? _reduce(function(acc, key) {
          if (pred(filterable[key])) {
            acc[key] = filterable[key];
          }
          return acc;
        }, {}, keys_default(filterable)) : (
          // else
          _filter(pred, filterable)
        );
      })
    );
    filter_default = filter;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reject.js
var reject, reject_default;
var init_reject = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reject.js"() {
    init_complement2();
    init_curry2();
    init_filter2();
    reject = _curry2(function reject2(pred, filterable) {
      return filter_default(_complement(pred), filterable);
    });
    reject_default = reject;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_toString.js
function _toString(x, seen) {
  var recur = function recur2(y) {
    var xs = seen.concat([x]);
    return _includes(y, xs) ? "<Circular>" : _toString(y, xs);
  };
  var mapPairs = function(obj, keys4) {
    return _map(function(k) {
      return _quote(k) + ": " + recur(obj[k]);
    }, keys4.slice().sort());
  };
  switch (Object.prototype.toString.call(x)) {
    case "[object Arguments]":
      return "(function() { return arguments; }(" + _map(recur, x).join(", ") + "))";
    case "[object Array]":
      return "[" + _map(recur, x).concat(mapPairs(x, reject_default(function(k) {
        return /^\d+$/.test(k);
      }, keys_default(x)))).join(", ") + "]";
    case "[object Boolean]":
      return typeof x === "object" ? "new Boolean(" + recur(x.valueOf()) + ")" : x.toString();
    case "[object Date]":
      return "new Date(" + (isNaN(x.valueOf()) ? recur(NaN) : _quote(toISOString_default(x))) + ")";
    case "[object Null]":
      return "null";
    case "[object Number]":
      return typeof x === "object" ? "new Number(" + recur(x.valueOf()) + ")" : 1 / x === -Infinity ? "-0" : x.toString(10);
    case "[object String]":
      return typeof x === "object" ? "new String(" + recur(x.valueOf()) + ")" : _quote(x);
    case "[object Undefined]":
      return "undefined";
    default:
      if (typeof x.toString === "function") {
        var repr = x.toString();
        if (repr !== "[object Object]") {
          return repr;
        }
      }
      return "{" + mapPairs(x, keys_default(x)).join(", ") + "}";
  }
}
var init_toString = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_toString.js"() {
    init_includes();
    init_map();
    init_quote();
    init_toISOString();
    init_keys();
    init_reject();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/toString.js
var toString2, toString_default;
var init_toString2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/toString.js"() {
    init_curry1();
    init_toString();
    toString2 = _curry1(function toString3(val) {
      return _toString(val, []);
    });
    toString_default = toString2;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/concat.js
var concat, concat_default;
var init_concat2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/concat.js"() {
    init_curry2();
    init_isArray();
    init_isFunction();
    init_isString();
    init_toString2();
    concat = _curry2(function concat2(a, b) {
      if (isArray_default(a)) {
        if (isArray_default(b)) {
          return a.concat(b);
        }
        throw new TypeError(toString_default(b) + " is not an array");
      }
      if (_isString(a)) {
        if (_isString(b)) {
          return a + b;
        }
        throw new TypeError(toString_default(b) + " is not a string");
      }
      if (a != null && _isFunction(a["fantasy-land/concat"])) {
        return a["fantasy-land/concat"](b);
      }
      if (a != null && _isFunction(a.concat)) {
        return a.concat(b);
      }
      throw new TypeError(toString_default(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
    });
    concat_default = concat;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/cond.js
var cond, cond_default;
var init_cond = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/cond.js"() {
    init_arity();
    init_curry1();
    init_map2();
    init_max();
    init_reduce2();
    cond = _curry1(function cond2(pairs2) {
      var arity = reduce_default(max_default, 0, map_default(function(pair3) {
        return pair3[0].length;
      }, pairs2));
      return _arity(arity, function() {
        var idx = 0;
        while (idx < pairs2.length) {
          if (pairs2[idx][0].apply(this, arguments)) {
            return pairs2[idx][1].apply(this, arguments);
          }
          idx += 1;
        }
      });
    });
    cond_default = cond;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/constructN.js
var constructN, constructN_default;
var init_constructN = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/constructN.js"() {
    init_curry2();
    init_curry();
    init_nAry();
    constructN = _curry2(function constructN2(n, Fn) {
      if (n > 10) {
        throw new Error("Constructor with greater than ten arguments");
      }
      if (n === 0) {
        return function() {
          return new Fn();
        };
      }
      return curry_default(nAry_default(n, function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
        switch (arguments.length) {
          case 1:
            return new Fn($0);
          case 2:
            return new Fn($0, $1);
          case 3:
            return new Fn($0, $1, $2);
          case 4:
            return new Fn($0, $1, $2, $3);
          case 5:
            return new Fn($0, $1, $2, $3, $4);
          case 6:
            return new Fn($0, $1, $2, $3, $4, $5);
          case 7:
            return new Fn($0, $1, $2, $3, $4, $5, $6);
          case 8:
            return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
          case 9:
            return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
          case 10:
            return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
        }
      }));
    });
    constructN_default = constructN;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/construct.js
var construct, construct_default;
var init_construct = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/construct.js"() {
    init_curry1();
    init_constructN();
    construct = _curry1(function construct2(Fn) {
      return constructN_default(Fn.length, Fn);
    });
    construct_default = construct;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/contains.js
var contains3, contains_default;
var init_contains = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/contains.js"() {
    init_includes();
    init_curry2();
    contains3 = _curry2(_includes);
    contains_default = contains3;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/converge.js
var converge, converge_default;
var init_converge = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/converge.js"() {
    init_curry2();
    init_map();
    init_curryN2();
    init_max();
    init_pluck();
    init_reduce2();
    converge = _curry2(function converge2(after, fns) {
      return curryN_default(reduce_default(max_default, 0, pluck_default("length", fns)), function() {
        var args = arguments;
        var context = this;
        return after.apply(context, _map(function(fn) {
          return fn.apply(context, args);
        }, fns));
      });
    });
    converge_default = converge;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xreduceBy.js
var XReduceBy, _xreduceBy, xreduceBy_default;
var init_xreduceBy = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xreduceBy.js"() {
    init_curryN();
    init_has();
    init_xfBase();
    XReduceBy = function() {
      function XReduceBy2(valueFn, valueAcc, keyFn, xf) {
        this.valueFn = valueFn;
        this.valueAcc = valueAcc;
        this.keyFn = keyFn;
        this.xf = xf;
        this.inputs = {};
      }
      XReduceBy2.prototype["@@transducer/init"] = xfBase_default.init;
      XReduceBy2.prototype["@@transducer/result"] = function(result) {
        var key;
        for (key in this.inputs) {
          if (_has(key, this.inputs)) {
            result = this.xf["@@transducer/step"](result, this.inputs[key]);
            if (result["@@transducer/reduced"]) {
              result = result["@@transducer/value"];
              break;
            }
          }
        }
        this.inputs = null;
        return this.xf["@@transducer/result"](result);
      };
      XReduceBy2.prototype["@@transducer/step"] = function(result, input) {
        var key = this.keyFn(input);
        this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
        this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
        return result;
      };
      return XReduceBy2;
    }();
    _xreduceBy = _curryN(4, [], function _xreduceBy2(valueFn, valueAcc, keyFn, xf) {
      return new XReduceBy(valueFn, valueAcc, keyFn, xf);
    });
    xreduceBy_default = _xreduceBy;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reduceBy.js
var reduceBy, reduceBy_default;
var init_reduceBy = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reduceBy.js"() {
    init_clone();
    init_curryN();
    init_dispatchable();
    init_has();
    init_reduce();
    init_xreduceBy();
    reduceBy = _curryN(
      4,
      [],
      _dispatchable([], xreduceBy_default, function reduceBy2(valueFn, valueAcc, keyFn, list) {
        return _reduce(function(acc, elt) {
          var key = keyFn(elt);
          acc[key] = valueFn(_has(key, acc) ? acc[key] : _clone(valueAcc, [], [], false), elt);
          return acc;
        }, {}, list);
      })
    );
    reduceBy_default = reduceBy;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/countBy.js
var countBy, countBy_default;
var init_countBy = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/countBy.js"() {
    init_reduceBy();
    countBy = reduceBy_default(function(acc, elem) {
      return acc + 1;
    }, 0);
    countBy_default = countBy;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dec.js
var dec, dec_default;
var init_dec = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dec.js"() {
    init_add();
    dec = add_default(-1);
    dec_default = dec;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/defaultTo.js
var defaultTo, defaultTo_default;
var init_defaultTo = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/defaultTo.js"() {
    init_curry2();
    defaultTo = _curry2(function defaultTo2(d, v) {
      return v == null || v !== v ? d : v;
    });
    defaultTo_default = defaultTo;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/descend.js
var descend, descend_default;
var init_descend = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/descend.js"() {
    init_curry3();
    descend = _curry3(function descend2(fn, a, b) {
      var aa = fn(a);
      var bb = fn(b);
      return aa > bb ? -1 : aa < bb ? 1 : 0;
    });
    descend_default = descend;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_Set.js
function hasOrAdd(item, shouldAdd, set4) {
  var type3 = typeof item;
  var prevSize, newSize;
  switch (type3) {
    case "string":
    case "number":
      if (item === 0 && 1 / item === -Infinity) {
        if (set4._items["-0"]) {
          return true;
        } else {
          if (shouldAdd) {
            set4._items["-0"] = true;
          }
          return false;
        }
      }
      if (set4._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set4._nativeSet.size;
          set4._nativeSet.add(item);
          newSize = set4._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set4._nativeSet.has(item);
        }
      } else {
        if (!(type3 in set4._items)) {
          if (shouldAdd) {
            set4._items[type3] = {};
            set4._items[type3][item] = true;
          }
          return false;
        } else if (item in set4._items[type3]) {
          return true;
        } else {
          if (shouldAdd) {
            set4._items[type3][item] = true;
          }
          return false;
        }
      }
    case "boolean":
      if (type3 in set4._items) {
        var bIdx = item ? 1 : 0;
        if (set4._items[type3][bIdx]) {
          return true;
        } else {
          if (shouldAdd) {
            set4._items[type3][bIdx] = true;
          }
          return false;
        }
      } else {
        if (shouldAdd) {
          set4._items[type3] = item ? [false, true] : [true, false];
        }
        return false;
      }
    case "function":
      if (set4._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set4._nativeSet.size;
          set4._nativeSet.add(item);
          newSize = set4._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set4._nativeSet.has(item);
        }
      } else {
        if (!(type3 in set4._items)) {
          if (shouldAdd) {
            set4._items[type3] = [item];
          }
          return false;
        }
        if (!_includes(item, set4._items[type3])) {
          if (shouldAdd) {
            set4._items[type3].push(item);
          }
          return false;
        }
        return true;
      }
    case "undefined":
      if (set4._items[type3]) {
        return true;
      } else {
        if (shouldAdd) {
          set4._items[type3] = true;
        }
        return false;
      }
    case "object":
      if (item === null) {
        if (!set4._items["null"]) {
          if (shouldAdd) {
            set4._items["null"] = true;
          }
          return false;
        }
        return true;
      }
    default:
      type3 = Object.prototype.toString.call(item);
      if (!(type3 in set4._items)) {
        if (shouldAdd) {
          set4._items[type3] = [item];
        }
        return false;
      }
      if (!_includes(item, set4._items[type3])) {
        if (shouldAdd) {
          set4._items[type3].push(item);
        }
        return false;
      }
      return true;
  }
}
var _Set, Set_default;
var init_Set = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_Set.js"() {
    init_includes();
    _Set = function() {
      function _Set2() {
        this._nativeSet = typeof Set === "function" ? /* @__PURE__ */ new Set() : null;
        this._items = {};
      }
      _Set2.prototype.add = function(item) {
        return !hasOrAdd(item, true, this);
      };
      _Set2.prototype.has = function(item) {
        return hasOrAdd(item, false, this);
      };
      return _Set2;
    }();
    Set_default = _Set;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/difference.js
var difference, difference_default;
var init_difference = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/difference.js"() {
    init_curry2();
    init_Set();
    difference = _curry2(function difference2(first, second) {
      var out = [];
      var idx = 0;
      var firstLen = first.length;
      var secondLen = second.length;
      var toFilterOut = new Set_default();
      for (var i = 0; i < secondLen; i += 1) {
        toFilterOut.add(second[i]);
      }
      while (idx < firstLen) {
        if (toFilterOut.add(first[idx])) {
          out[out.length] = first[idx];
        }
        idx += 1;
      }
      return out;
    });
    difference_default = difference;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/differenceWith.js
var differenceWith, differenceWith_default;
var init_differenceWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/differenceWith.js"() {
    init_includesWith();
    init_curry3();
    differenceWith = _curry3(function differenceWith2(pred, first, second) {
      var out = [];
      var idx = 0;
      var firstLen = first.length;
      while (idx < firstLen) {
        if (!_includesWith(pred, first[idx], second) && !_includesWith(pred, first[idx], out)) {
          out.push(first[idx]);
        }
        idx += 1;
      }
      return out;
    });
    differenceWith_default = differenceWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dissoc.js
var dissoc, dissoc_default;
var init_dissoc = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dissoc.js"() {
    init_curry2();
    dissoc = _curry2(function dissoc2(prop3, obj) {
      var result = {};
      for (var p in obj) {
        result[p] = obj[p];
      }
      delete result[prop3];
      return result;
    });
    dissoc_default = dissoc;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/remove.js
var remove, remove_default;
var init_remove = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/remove.js"() {
    init_curry3();
    remove = _curry3(function remove2(start, count, list) {
      var result = Array.prototype.slice.call(list, 0);
      result.splice(start, count);
      return result;
    });
    remove_default = remove;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/update.js
var update, update_default;
var init_update = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/update.js"() {
    init_curry3();
    init_adjust();
    init_always();
    update = _curry3(function update2(idx, x, list) {
      return adjust_default(idx, always_default(x), list);
    });
    update_default = update;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dissocPath.js
var dissocPath, dissocPath_default;
var init_dissocPath = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dissocPath.js"() {
    init_curry2();
    init_isInteger();
    init_isArray();
    init_assoc();
    init_dissoc();
    init_remove();
    init_update();
    dissocPath = _curry2(function dissocPath2(path3, obj) {
      switch (path3.length) {
        case 0:
          return obj;
        case 1:
          return isInteger_default(path3[0]) && isArray_default(obj) ? remove_default(path3[0], 1, obj) : dissoc_default(path3[0], obj);
        default:
          var head2 = path3[0];
          var tail2 = Array.prototype.slice.call(path3, 1);
          if (obj[head2] == null) {
            return obj;
          } else if (isInteger_default(head2) && isArray_default(obj)) {
            return update_default(head2, dissocPath2(tail2, obj[head2]), obj);
          } else {
            return assoc_default(head2, dissocPath2(tail2, obj[head2]), obj);
          }
      }
    });
    dissocPath_default = dissocPath;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/divide.js
var divide, divide_default;
var init_divide = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/divide.js"() {
    init_curry2();
    divide = _curry2(function divide2(a, b) {
      return a / b;
    });
    divide_default = divide;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xdrop.js
var XDrop, _xdrop, xdrop_default;
var init_xdrop = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xdrop.js"() {
    init_curry2();
    init_xfBase();
    XDrop = function() {
      function XDrop2(n, xf) {
        this.xf = xf;
        this.n = n;
      }
      XDrop2.prototype["@@transducer/init"] = xfBase_default.init;
      XDrop2.prototype["@@transducer/result"] = xfBase_default.result;
      XDrop2.prototype["@@transducer/step"] = function(result, input) {
        if (this.n > 0) {
          this.n -= 1;
          return result;
        }
        return this.xf["@@transducer/step"](result, input);
      };
      return XDrop2;
    }();
    _xdrop = _curry2(function _xdrop2(n, xf) {
      return new XDrop(n, xf);
    });
    xdrop_default = _xdrop;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/drop.js
var drop, drop_default;
var init_drop = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/drop.js"() {
    init_curry2();
    init_dispatchable();
    init_xdrop();
    init_slice();
    drop = _curry2(
      _dispatchable(["drop"], xdrop_default, function drop2(n, xs) {
        return slice_default(Math.max(0, n), Infinity, xs);
      })
    );
    drop_default = drop;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xtake.js
var XTake, _xtake, xtake_default;
var init_xtake = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xtake.js"() {
    init_curry2();
    init_reduced();
    init_xfBase();
    XTake = function() {
      function XTake2(n, xf) {
        this.xf = xf;
        this.n = n;
        this.i = 0;
      }
      XTake2.prototype["@@transducer/init"] = xfBase_default.init;
      XTake2.prototype["@@transducer/result"] = xfBase_default.result;
      XTake2.prototype["@@transducer/step"] = function(result, input) {
        this.i += 1;
        var ret = this.n === 0 ? result : this.xf["@@transducer/step"](result, input);
        return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
      };
      return XTake2;
    }();
    _xtake = _curry2(function _xtake2(n, xf) {
      return new XTake(n, xf);
    });
    xtake_default = _xtake;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/take.js
var take, take_default;
var init_take = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/take.js"() {
    init_curry2();
    init_dispatchable();
    init_xtake();
    init_slice();
    take = _curry2(
      _dispatchable(["take"], xtake_default, function take2(n, xs) {
        return slice_default(0, n < 0 ? Infinity : n, xs);
      })
    );
    take_default = take;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_dropLast.js
function dropLast(n, xs) {
  return take_default(n < xs.length ? xs.length - n : 0, xs);
}
var init_dropLast = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_dropLast.js"() {
    init_take();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xdropLast.js
var XDropLast, _xdropLast, xdropLast_default;
var init_xdropLast = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xdropLast.js"() {
    init_curry2();
    init_xfBase();
    XDropLast = function() {
      function XDropLast2(n, xf) {
        this.xf = xf;
        this.pos = 0;
        this.full = false;
        this.acc = new Array(n);
      }
      XDropLast2.prototype["@@transducer/init"] = xfBase_default.init;
      XDropLast2.prototype["@@transducer/result"] = function(result) {
        this.acc = null;
        return this.xf["@@transducer/result"](result);
      };
      XDropLast2.prototype["@@transducer/step"] = function(result, input) {
        if (this.full) {
          result = this.xf["@@transducer/step"](result, this.acc[this.pos]);
        }
        this.store(input);
        return result;
      };
      XDropLast2.prototype.store = function(input) {
        this.acc[this.pos] = input;
        this.pos += 1;
        if (this.pos === this.acc.length) {
          this.pos = 0;
          this.full = true;
        }
      };
      return XDropLast2;
    }();
    _xdropLast = _curry2(function _xdropLast2(n, xf) {
      return new XDropLast(n, xf);
    });
    xdropLast_default = _xdropLast;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dropLast.js
var dropLast2, dropLast_default;
var init_dropLast2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dropLast.js"() {
    init_curry2();
    init_dispatchable();
    init_dropLast();
    init_xdropLast();
    dropLast2 = _curry2(
      _dispatchable([], xdropLast_default, dropLast)
    );
    dropLast_default = dropLast2;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_dropLastWhile.js
function dropLastWhile(pred, xs) {
  var idx = xs.length - 1;
  while (idx >= 0 && pred(xs[idx])) {
    idx -= 1;
  }
  return slice_default(0, idx + 1, xs);
}
var init_dropLastWhile = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_dropLastWhile.js"() {
    init_slice();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xdropLastWhile.js
var XDropLastWhile, _xdropLastWhile, xdropLastWhile_default;
var init_xdropLastWhile = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xdropLastWhile.js"() {
    init_curry2();
    init_reduce();
    init_xfBase();
    XDropLastWhile = function() {
      function XDropLastWhile2(fn, xf) {
        this.f = fn;
        this.retained = [];
        this.xf = xf;
      }
      XDropLastWhile2.prototype["@@transducer/init"] = xfBase_default.init;
      XDropLastWhile2.prototype["@@transducer/result"] = function(result) {
        this.retained = null;
        return this.xf["@@transducer/result"](result);
      };
      XDropLastWhile2.prototype["@@transducer/step"] = function(result, input) {
        return this.f(input) ? this.retain(result, input) : this.flush(result, input);
      };
      XDropLastWhile2.prototype.flush = function(result, input) {
        result = _reduce(this.xf["@@transducer/step"], result, this.retained);
        this.retained = [];
        return this.xf["@@transducer/step"](result, input);
      };
      XDropLastWhile2.prototype.retain = function(result, input) {
        this.retained.push(input);
        return result;
      };
      return XDropLastWhile2;
    }();
    _xdropLastWhile = _curry2(function _xdropLastWhile2(fn, xf) {
      return new XDropLastWhile(fn, xf);
    });
    xdropLastWhile_default = _xdropLastWhile;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dropLastWhile.js
var dropLastWhile2, dropLastWhile_default;
var init_dropLastWhile2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dropLastWhile.js"() {
    init_curry2();
    init_dispatchable();
    init_dropLastWhile();
    init_xdropLastWhile();
    dropLastWhile2 = _curry2(
      _dispatchable([], xdropLastWhile_default, dropLastWhile)
    );
    dropLastWhile_default = dropLastWhile2;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xdropRepeatsWith.js
var XDropRepeatsWith, _xdropRepeatsWith, xdropRepeatsWith_default;
var init_xdropRepeatsWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xdropRepeatsWith.js"() {
    init_curry2();
    init_xfBase();
    XDropRepeatsWith = function() {
      function XDropRepeatsWith2(pred, xf) {
        this.xf = xf;
        this.pred = pred;
        this.lastValue = void 0;
        this.seenFirstValue = false;
      }
      XDropRepeatsWith2.prototype["@@transducer/init"] = xfBase_default.init;
      XDropRepeatsWith2.prototype["@@transducer/result"] = xfBase_default.result;
      XDropRepeatsWith2.prototype["@@transducer/step"] = function(result, input) {
        var sameAsLast = false;
        if (!this.seenFirstValue) {
          this.seenFirstValue = true;
        } else if (this.pred(this.lastValue, input)) {
          sameAsLast = true;
        }
        this.lastValue = input;
        return sameAsLast ? result : this.xf["@@transducer/step"](result, input);
      };
      return XDropRepeatsWith2;
    }();
    _xdropRepeatsWith = _curry2(function _xdropRepeatsWith2(pred, xf) {
      return new XDropRepeatsWith(pred, xf);
    });
    xdropRepeatsWith_default = _xdropRepeatsWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/last.js
var last, last_default;
var init_last = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/last.js"() {
    init_nth();
    last = nth_default(-1);
    last_default = last;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dropRepeatsWith.js
var dropRepeatsWith, dropRepeatsWith_default;
var init_dropRepeatsWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dropRepeatsWith.js"() {
    init_curry2();
    init_dispatchable();
    init_xdropRepeatsWith();
    init_last();
    dropRepeatsWith = _curry2(
      _dispatchable([], xdropRepeatsWith_default, function dropRepeatsWith2(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;
        if (len !== 0) {
          result[0] = list[0];
          while (idx < len) {
            if (!pred(last_default(result), list[idx])) {
              result[result.length] = list[idx];
            }
            idx += 1;
          }
        }
        return result;
      })
    );
    dropRepeatsWith_default = dropRepeatsWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dropRepeats.js
var dropRepeats, dropRepeats_default;
var init_dropRepeats = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dropRepeats.js"() {
    init_curry1();
    init_dispatchable();
    init_xdropRepeatsWith();
    init_dropRepeatsWith();
    init_equals2();
    dropRepeats = _curry1(
      _dispatchable(
        [],
        xdropRepeatsWith_default(equals_default),
        dropRepeatsWith_default(equals_default)
      )
    );
    dropRepeats_default = dropRepeats;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xdropWhile.js
var XDropWhile, _xdropWhile, xdropWhile_default;
var init_xdropWhile = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xdropWhile.js"() {
    init_curry2();
    init_xfBase();
    XDropWhile = function() {
      function XDropWhile2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XDropWhile2.prototype["@@transducer/init"] = xfBase_default.init;
      XDropWhile2.prototype["@@transducer/result"] = xfBase_default.result;
      XDropWhile2.prototype["@@transducer/step"] = function(result, input) {
        if (this.f) {
          if (this.f(input)) {
            return result;
          }
          this.f = null;
        }
        return this.xf["@@transducer/step"](result, input);
      };
      return XDropWhile2;
    }();
    _xdropWhile = _curry2(function _xdropWhile2(f, xf) {
      return new XDropWhile(f, xf);
    });
    xdropWhile_default = _xdropWhile;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dropWhile.js
var dropWhile, dropWhile_default;
var init_dropWhile = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/dropWhile.js"() {
    init_curry2();
    init_dispatchable();
    init_xdropWhile();
    init_slice();
    dropWhile = _curry2(
      _dispatchable(["dropWhile"], xdropWhile_default, function dropWhile2(pred, xs) {
        var idx = 0;
        var len = xs.length;
        while (idx < len && pred(xs[idx])) {
          idx += 1;
        }
        return slice_default(idx, Infinity, xs);
      })
    );
    dropWhile_default = dropWhile;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/or.js
var or, or_default;
var init_or = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/or.js"() {
    init_curry2();
    or = _curry2(function or2(a, b) {
      return a || b;
    });
    or_default = or;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/either.js
var either, either_default;
var init_either = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/either.js"() {
    init_curry2();
    init_isFunction();
    init_lift();
    init_or();
    either = _curry2(function either2(f, g) {
      return _isFunction(f) ? function _either() {
        return f.apply(this, arguments) || g.apply(this, arguments);
      } : lift_default(or_default)(f, g);
    });
    either_default = either;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/empty.js
var empty, empty_default;
var init_empty = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/empty.js"() {
    init_curry1();
    init_isArguments();
    init_isArray();
    init_isObject();
    init_isString();
    empty = _curry1(function empty2(x) {
      return x != null && typeof x["fantasy-land/empty"] === "function" ? x["fantasy-land/empty"]() : x != null && x.constructor != null && typeof x.constructor["fantasy-land/empty"] === "function" ? x.constructor["fantasy-land/empty"]() : x != null && typeof x.empty === "function" ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === "function" ? x.constructor.empty() : isArray_default(x) ? [] : _isString(x) ? "" : _isObject(x) ? {} : isArguments_default(x) ? function() {
        return arguments;
      }() : void 0;
    });
    empty_default = empty;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/takeLast.js
var takeLast, takeLast_default;
var init_takeLast = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/takeLast.js"() {
    init_curry2();
    init_drop();
    takeLast = _curry2(function takeLast2(n, xs) {
      return drop_default(n >= 0 ? xs.length - n : 0, xs);
    });
    takeLast_default = takeLast;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/endsWith.js
var endsWith, endsWith_default;
var init_endsWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/endsWith.js"() {
    init_curry2();
    init_equals2();
    init_takeLast();
    endsWith = _curry2(function(suffix, list) {
      return equals_default(takeLast_default(suffix.length, list), suffix);
    });
    endsWith_default = endsWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/eqBy.js
var eqBy, eqBy_default;
var init_eqBy = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/eqBy.js"() {
    init_curry3();
    init_equals2();
    eqBy = _curry3(function eqBy2(f, x, y) {
      return equals_default(f(x), f(y));
    });
    eqBy_default = eqBy;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/eqProps.js
var eqProps, eqProps_default;
var init_eqProps = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/eqProps.js"() {
    init_curry3();
    init_equals2();
    eqProps = _curry3(function eqProps2(prop3, obj1, obj2) {
      return equals_default(obj1[prop3], obj2[prop3]);
    });
    eqProps_default = eqProps;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/evolve.js
var evolve, evolve_default;
var init_evolve = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/evolve.js"() {
    init_curry2();
    evolve = _curry2(function evolve2(transformations, object) {
      var result = object instanceof Array ? [] : {};
      var transformation, key, type3;
      for (key in object) {
        transformation = transformations[key];
        type3 = typeof transformation;
        result[key] = type3 === "function" ? transformation(object[key]) : transformation && type3 === "object" ? evolve2(transformation, object[key]) : object[key];
      }
      return result;
    });
    evolve_default = evolve;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfind.js
var XFind, _xfind, xfind_default;
var init_xfind = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfind.js"() {
    init_curry2();
    init_reduced();
    init_xfBase();
    XFind = function() {
      function XFind2(f, xf) {
        this.xf = xf;
        this.f = f;
        this.found = false;
      }
      XFind2.prototype["@@transducer/init"] = xfBase_default.init;
      XFind2.prototype["@@transducer/result"] = function(result) {
        if (!this.found) {
          result = this.xf["@@transducer/step"](result, void 0);
        }
        return this.xf["@@transducer/result"](result);
      };
      XFind2.prototype["@@transducer/step"] = function(result, input) {
        if (this.f(input)) {
          this.found = true;
          result = _reduced(this.xf["@@transducer/step"](result, input));
        }
        return result;
      };
      return XFind2;
    }();
    _xfind = _curry2(function _xfind2(f, xf) {
      return new XFind(f, xf);
    });
    xfind_default = _xfind;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/find.js
var find, find_default;
var init_find = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/find.js"() {
    init_curry2();
    init_dispatchable();
    init_xfind();
    find = _curry2(
      _dispatchable(["find"], xfind_default, function find2(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
          if (fn(list[idx])) {
            return list[idx];
          }
          idx += 1;
        }
      })
    );
    find_default = find;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfindIndex.js
var XFindIndex, _xfindIndex, xfindIndex_default;
var init_xfindIndex = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfindIndex.js"() {
    init_curry2();
    init_reduced();
    init_xfBase();
    XFindIndex = function() {
      function XFindIndex2(f, xf) {
        this.xf = xf;
        this.f = f;
        this.idx = -1;
        this.found = false;
      }
      XFindIndex2.prototype["@@transducer/init"] = xfBase_default.init;
      XFindIndex2.prototype["@@transducer/result"] = function(result) {
        if (!this.found) {
          result = this.xf["@@transducer/step"](result, -1);
        }
        return this.xf["@@transducer/result"](result);
      };
      XFindIndex2.prototype["@@transducer/step"] = function(result, input) {
        this.idx += 1;
        if (this.f(input)) {
          this.found = true;
          result = _reduced(this.xf["@@transducer/step"](result, this.idx));
        }
        return result;
      };
      return XFindIndex2;
    }();
    _xfindIndex = _curry2(function _xfindIndex2(f, xf) {
      return new XFindIndex(f, xf);
    });
    xfindIndex_default = _xfindIndex;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/findIndex.js
var findIndex, findIndex_default;
var init_findIndex = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/findIndex.js"() {
    init_curry2();
    init_dispatchable();
    init_xfindIndex();
    findIndex = _curry2(
      _dispatchable([], xfindIndex_default, function findIndex2(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
          if (fn(list[idx])) {
            return idx;
          }
          idx += 1;
        }
        return -1;
      })
    );
    findIndex_default = findIndex;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfindLast.js
var XFindLast, _xfindLast, xfindLast_default;
var init_xfindLast = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfindLast.js"() {
    init_curry2();
    init_xfBase();
    XFindLast = function() {
      function XFindLast2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XFindLast2.prototype["@@transducer/init"] = xfBase_default.init;
      XFindLast2.prototype["@@transducer/result"] = function(result) {
        return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.last));
      };
      XFindLast2.prototype["@@transducer/step"] = function(result, input) {
        if (this.f(input)) {
          this.last = input;
        }
        return result;
      };
      return XFindLast2;
    }();
    _xfindLast = _curry2(function _xfindLast2(f, xf) {
      return new XFindLast(f, xf);
    });
    xfindLast_default = _xfindLast;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/findLast.js
var findLast, findLast_default;
var init_findLast = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/findLast.js"() {
    init_curry2();
    init_dispatchable();
    init_xfindLast();
    findLast = _curry2(
      _dispatchable([], xfindLast_default, function findLast2(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
          if (fn(list[idx])) {
            return list[idx];
          }
          idx -= 1;
        }
      })
    );
    findLast_default = findLast;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfindLastIndex.js
var XFindLastIndex, _xfindLastIndex, xfindLastIndex_default;
var init_xfindLastIndex = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xfindLastIndex.js"() {
    init_curry2();
    init_xfBase();
    XFindLastIndex = function() {
      function XFindLastIndex2(f, xf) {
        this.xf = xf;
        this.f = f;
        this.idx = -1;
        this.lastIdx = -1;
      }
      XFindLastIndex2.prototype["@@transducer/init"] = xfBase_default.init;
      XFindLastIndex2.prototype["@@transducer/result"] = function(result) {
        return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.lastIdx));
      };
      XFindLastIndex2.prototype["@@transducer/step"] = function(result, input) {
        this.idx += 1;
        if (this.f(input)) {
          this.lastIdx = this.idx;
        }
        return result;
      };
      return XFindLastIndex2;
    }();
    _xfindLastIndex = _curry2(function _xfindLastIndex2(f, xf) {
      return new XFindLastIndex(f, xf);
    });
    xfindLastIndex_default = _xfindLastIndex;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/findLastIndex.js
var findLastIndex, findLastIndex_default;
var init_findLastIndex = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/findLastIndex.js"() {
    init_curry2();
    init_dispatchable();
    init_xfindLastIndex();
    findLastIndex = _curry2(
      _dispatchable([], xfindLastIndex_default, function findLastIndex2(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
          if (fn(list[idx])) {
            return idx;
          }
          idx -= 1;
        }
        return -1;
      })
    );
    findLastIndex_default = findLastIndex;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/flatten.js
var flatten, flatten_default;
var init_flatten = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/flatten.js"() {
    init_curry1();
    init_makeFlat();
    flatten = _curry1(
      _makeFlat(true)
    );
    flatten_default = flatten;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/flip.js
var flip, flip_default;
var init_flip = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/flip.js"() {
    init_curry1();
    init_curryN2();
    flip = _curry1(function flip2(fn) {
      return curryN_default(fn.length, function(a, b) {
        var args = Array.prototype.slice.call(arguments, 0);
        args[0] = b;
        args[1] = a;
        return fn.apply(this, args);
      });
    });
    flip_default = flip;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/forEach.js
var forEach, forEach_default;
var init_forEach = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/forEach.js"() {
    init_checkForMethod();
    init_curry2();
    forEach = _curry2(
      _checkForMethod("forEach", function forEach2(fn, list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
          fn(list[idx]);
          idx += 1;
        }
        return list;
      })
    );
    forEach_default = forEach;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/forEachObjIndexed.js
var forEachObjIndexed, forEachObjIndexed_default;
var init_forEachObjIndexed = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/forEachObjIndexed.js"() {
    init_curry2();
    init_keys();
    forEachObjIndexed = _curry2(function forEachObjIndexed2(fn, obj) {
      var keyList = keys_default(obj);
      var idx = 0;
      while (idx < keyList.length) {
        var key = keyList[idx];
        fn(obj[key], key, obj);
        idx += 1;
      }
      return obj;
    });
    forEachObjIndexed_default = forEachObjIndexed;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/fromPairs.js
var fromPairs, fromPairs_default;
var init_fromPairs = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/fromPairs.js"() {
    init_curry1();
    fromPairs = _curry1(function fromPairs2(pairs2) {
      var result = {};
      var idx = 0;
      while (idx < pairs2.length) {
        result[pairs2[idx][0]] = pairs2[idx][1];
        idx += 1;
      }
      return result;
    });
    fromPairs_default = fromPairs;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/groupBy.js
var groupBy, groupBy_default;
var init_groupBy = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/groupBy.js"() {
    init_checkForMethod();
    init_curry2();
    init_reduceBy();
    groupBy = _curry2(
      _checkForMethod(
        "groupBy",
        reduceBy_default(function(acc, item) {
          if (acc == null) {
            acc = [];
          }
          acc.push(item);
          return acc;
        }, null)
      )
    );
    groupBy_default = groupBy;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/groupWith.js
var groupWith, groupWith_default;
var init_groupWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/groupWith.js"() {
    init_curry2();
    groupWith = _curry2(function(fn, list) {
      var res = [];
      var idx = 0;
      var len = list.length;
      while (idx < len) {
        var nextidx = idx + 1;
        while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {
          nextidx += 1;
        }
        res.push(list.slice(idx, nextidx));
        idx = nextidx;
      }
      return res;
    });
    groupWith_default = groupWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/gt.js
var gt, gt_default;
var init_gt = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/gt.js"() {
    init_curry2();
    gt = _curry2(function gt2(a, b) {
      return a > b;
    });
    gt_default = gt;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/gte.js
var gte, gte_default;
var init_gte = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/gte.js"() {
    init_curry2();
    gte = _curry2(function gte2(a, b) {
      return a >= b;
    });
    gte_default = gte;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/hasPath.js
var hasPath, hasPath_default;
var init_hasPath = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/hasPath.js"() {
    init_curry2();
    init_has();
    init_isNil();
    hasPath = _curry2(function hasPath2(_path, obj) {
      if (_path.length === 0 || isNil_default(obj)) {
        return false;
      }
      var val = obj;
      var idx = 0;
      while (idx < _path.length) {
        if (!isNil_default(val) && _has(_path[idx], val)) {
          val = val[_path[idx]];
          idx += 1;
        } else {
          return false;
        }
      }
      return true;
    });
    hasPath_default = hasPath;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/has.js
var has, has_default;
var init_has2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/has.js"() {
    init_curry2();
    init_hasPath();
    has = _curry2(function has2(prop3, obj) {
      return hasPath_default([prop3], obj);
    });
    has_default = has;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/hasIn.js
var hasIn, hasIn_default;
var init_hasIn = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/hasIn.js"() {
    init_curry2();
    hasIn = _curry2(function hasIn2(prop3, obj) {
      return prop3 in obj;
    });
    hasIn_default = hasIn;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/identical.js
var identical, identical_default;
var init_identical = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/identical.js"() {
    init_objectIs();
    init_curry2();
    identical = _curry2(objectIs_default);
    identical_default = identical;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/ifElse.js
var ifElse, ifElse_default;
var init_ifElse = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/ifElse.js"() {
    init_curry3();
    init_curryN2();
    ifElse = _curry3(function ifElse2(condition, onTrue, onFalse) {
      return curryN_default(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
        return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
      });
    });
    ifElse_default = ifElse;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/inc.js
var inc, inc_default;
var init_inc = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/inc.js"() {
    init_add();
    inc = add_default(1);
    inc_default = inc;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/includes.js
var includes, includes_default;
var init_includes2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/includes.js"() {
    init_includes();
    init_curry2();
    includes = _curry2(_includes);
    includes_default = includes;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/indexBy.js
var indexBy, indexBy_default;
var init_indexBy = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/indexBy.js"() {
    init_reduceBy();
    indexBy = reduceBy_default(function(acc, elem) {
      return elem;
    }, null);
    indexBy_default = indexBy;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/indexOf.js
var indexOf, indexOf_default;
var init_indexOf2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/indexOf.js"() {
    init_curry2();
    init_indexOf();
    init_isArray();
    indexOf = _curry2(function indexOf2(target, xs) {
      return typeof xs.indexOf === "function" && !isArray_default(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
    });
    indexOf_default = indexOf;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/init.js
var init, init_default;
var init_init = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/init.js"() {
    init_slice();
    init = slice_default(0, -1);
    init_default = init;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/innerJoin.js
var innerJoin, innerJoin_default;
var init_innerJoin = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/innerJoin.js"() {
    init_includesWith();
    init_curry3();
    init_filter();
    innerJoin = _curry3(function innerJoin2(pred, xs, ys) {
      return _filter(function(x) {
        return _includesWith(pred, x, ys);
      }, xs);
    });
    innerJoin_default = innerJoin;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/insert.js
var insert, insert_default;
var init_insert = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/insert.js"() {
    init_curry3();
    insert = _curry3(function insert2(idx, elt, list) {
      idx = idx < list.length && idx >= 0 ? idx : list.length;
      var result = Array.prototype.slice.call(list, 0);
      result.splice(idx, 0, elt);
      return result;
    });
    insert_default = insert;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/insertAll.js
var insertAll, insertAll_default;
var init_insertAll = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/insertAll.js"() {
    init_curry3();
    insertAll = _curry3(function insertAll2(idx, elts, list) {
      idx = idx < list.length && idx >= 0 ? idx : list.length;
      return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
    });
    insertAll_default = insertAll;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/uniqBy.js
var uniqBy, uniqBy_default;
var init_uniqBy = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/uniqBy.js"() {
    init_Set();
    init_curry2();
    uniqBy = _curry2(function uniqBy2(fn, list) {
      var set4 = new Set_default();
      var result = [];
      var idx = 0;
      var appliedItem, item;
      while (idx < list.length) {
        item = list[idx];
        appliedItem = fn(item);
        if (set4.add(appliedItem)) {
          result.push(item);
        }
        idx += 1;
      }
      return result;
    });
    uniqBy_default = uniqBy;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/uniq.js
var uniq, uniq_default;
var init_uniq = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/uniq.js"() {
    init_identity2();
    init_uniqBy();
    uniq = uniqBy_default(identity_default);
    uniq_default = uniq;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/intersection.js
var intersection, intersection_default;
var init_intersection = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/intersection.js"() {
    init_includes();
    init_curry2();
    init_filter();
    init_flip();
    init_uniq();
    intersection = _curry2(function intersection2(list1, list2) {
      var lookupList, filteredList;
      if (list1.length > list2.length) {
        lookupList = list1;
        filteredList = list2;
      } else {
        lookupList = list2;
        filteredList = list1;
      }
      return uniq_default(_filter(flip_default(_includes)(lookupList), filteredList));
    });
    intersection_default = intersection;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/intersperse.js
var intersperse, intersperse_default;
var init_intersperse = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/intersperse.js"() {
    init_checkForMethod();
    init_curry2();
    intersperse = _curry2(
      _checkForMethod("intersperse", function intersperse2(separator, list) {
        var out = [];
        var idx = 0;
        var length4 = list.length;
        while (idx < length4) {
          if (idx === length4 - 1) {
            out.push(list[idx]);
          } else {
            out.push(list[idx], separator);
          }
          idx += 1;
        }
        return out;
      })
    );
    intersperse_default = intersperse;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_objectAssign.js
function _objectAssign(target) {
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  var output = Object(target);
  var idx = 1;
  var length4 = arguments.length;
  while (idx < length4) {
    var source = arguments[idx];
    if (source != null) {
      for (var nextKey in source) {
        if (_has(nextKey, source)) {
          output[nextKey] = source[nextKey];
        }
      }
    }
    idx += 1;
  }
  return output;
}
var objectAssign_default;
var init_objectAssign = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_objectAssign.js"() {
    init_has();
    objectAssign_default = typeof Object.assign === "function" ? Object.assign : _objectAssign;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/objOf.js
var objOf, objOf_default;
var init_objOf = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/objOf.js"() {
    init_curry2();
    objOf = _curry2(function objOf2(key, val) {
      var obj = {};
      obj[key] = val;
      return obj;
    });
    objOf_default = objOf;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_stepCat.js
function _stepCat(obj) {
  if (_isTransformer(obj)) {
    return obj;
  }
  if (isArrayLike_default(obj)) {
    return _stepCatArray;
  }
  if (typeof obj === "string") {
    return _stepCatString;
  }
  if (typeof obj === "object") {
    return _stepCatObject;
  }
  throw new Error("Cannot create transformer for " + obj);
}
var _stepCatArray, _stepCatString, _stepCatObject;
var init_stepCat = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_stepCat.js"() {
    init_objectAssign();
    init_identity();
    init_isArrayLike();
    init_isTransformer();
    init_objOf();
    _stepCatArray = {
      "@@transducer/init": Array,
      "@@transducer/step": function(xs, x) {
        xs.push(x);
        return xs;
      },
      "@@transducer/result": _identity
    };
    _stepCatString = {
      "@@transducer/init": String,
      "@@transducer/step": function(a, b) {
        return a + b;
      },
      "@@transducer/result": _identity
    };
    _stepCatObject = {
      "@@transducer/init": Object,
      "@@transducer/step": function(result, input) {
        return objectAssign_default(result, isArrayLike_default(input) ? objOf_default(input[0], input[1]) : input);
      },
      "@@transducer/result": _identity
    };
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/into.js
var into, into_default;
var init_into = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/into.js"() {
    init_clone();
    init_curry3();
    init_isTransformer();
    init_reduce();
    init_stepCat();
    into = _curry3(function into2(acc, xf, list) {
      return _isTransformer(acc) ? _reduce(xf(acc), acc["@@transducer/init"](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
    });
    into_default = into;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/invert.js
var invert, invert_default;
var init_invert = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/invert.js"() {
    init_curry1();
    init_has();
    init_keys();
    invert = _curry1(function invert2(obj) {
      var props3 = keys_default(obj);
      var len = props3.length;
      var idx = 0;
      var out = {};
      while (idx < len) {
        var key = props3[idx];
        var val = obj[key];
        var list = _has(val, out) ? out[val] : out[val] = [];
        list[list.length] = key;
        idx += 1;
      }
      return out;
    });
    invert_default = invert;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/invertObj.js
var invertObj, invertObj_default;
var init_invertObj = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/invertObj.js"() {
    init_curry1();
    init_keys();
    invertObj = _curry1(function invertObj2(obj) {
      var props3 = keys_default(obj);
      var len = props3.length;
      var idx = 0;
      var out = {};
      while (idx < len) {
        var key = props3[idx];
        out[obj[key]] = key;
        idx += 1;
      }
      return out;
    });
    invertObj_default = invertObj;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/invoker.js
var invoker, invoker_default;
var init_invoker = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/invoker.js"() {
    init_curry2();
    init_isFunction();
    init_curryN2();
    init_toString2();
    invoker = _curry2(function invoker2(arity, method2) {
      return curryN_default(arity + 1, function() {
        var target = arguments[arity];
        if (target != null && _isFunction(target[method2])) {
          return target[method2].apply(target, Array.prototype.slice.call(arguments, 0, arity));
        }
        throw new TypeError(toString_default(target) + ' does not have a method named "' + method2 + '"');
      });
    });
    invoker_default = invoker;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/is.js
var is, is_default;
var init_is = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/is.js"() {
    init_curry2();
    is = _curry2(function is2(Ctor, val) {
      return val != null && val.constructor === Ctor || val instanceof Ctor;
    });
    is_default = is;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/isEmpty.js
var isEmpty, isEmpty_default;
var init_isEmpty = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/isEmpty.js"() {
    init_curry1();
    init_empty();
    init_equals2();
    isEmpty = _curry1(function isEmpty2(x) {
      return x != null && equals_default(x, empty_default(x));
    });
    isEmpty_default = isEmpty;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/join.js
var join, join_default;
var init_join = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/join.js"() {
    init_invoker();
    join = invoker_default(1, "join");
    join_default = join;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/juxt.js
var juxt, juxt_default;
var init_juxt = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/juxt.js"() {
    init_curry1();
    init_converge();
    juxt = _curry1(function juxt2(fns) {
      return converge_default(function() {
        return Array.prototype.slice.call(arguments, 0);
      }, fns);
    });
    juxt_default = juxt;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/keysIn.js
var keysIn, keysIn_default;
var init_keysIn = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/keysIn.js"() {
    init_curry1();
    keysIn = _curry1(function keysIn2(obj) {
      var prop3;
      var ks = [];
      for (prop3 in obj) {
        ks[ks.length] = prop3;
      }
      return ks;
    });
    keysIn_default = keysIn;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lastIndexOf.js
var lastIndexOf, lastIndexOf_default;
var init_lastIndexOf = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lastIndexOf.js"() {
    init_curry2();
    init_isArray();
    init_equals2();
    lastIndexOf = _curry2(function lastIndexOf2(target, xs) {
      if (typeof xs.lastIndexOf === "function" && !isArray_default(xs)) {
        return xs.lastIndexOf(target);
      } else {
        var idx = xs.length - 1;
        while (idx >= 0) {
          if (equals_default(xs[idx], target)) {
            return idx;
          }
          idx -= 1;
        }
        return -1;
      }
    });
    lastIndexOf_default = lastIndexOf;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isNumber.js
function _isNumber(x) {
  return Object.prototype.toString.call(x) === "[object Number]";
}
var init_isNumber = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isNumber.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/length.js
var length2, length_default;
var init_length = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/length.js"() {
    init_curry1();
    init_isNumber();
    length2 = _curry1(function length3(list) {
      return list != null && _isNumber(list.length) ? list.length : NaN;
    });
    length_default = length2;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lens.js
var lens, lens_default;
var init_lens = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lens.js"() {
    init_curry2();
    init_map2();
    lens = _curry2(function lens2(getter, setter) {
      return function(toFunctorFn) {
        return function(target) {
          return map_default(function(focus) {
            return setter(focus, target);
          }, toFunctorFn(getter(target)));
        };
      };
    });
    lens_default = lens;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lensIndex.js
var lensIndex, lensIndex_default;
var init_lensIndex = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lensIndex.js"() {
    init_curry1();
    init_lens();
    init_nth();
    init_update();
    lensIndex = _curry1(function lensIndex2(n) {
      return lens_default(nth_default(n), update_default(n));
    });
    lensIndex_default = lensIndex;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lensPath.js
var lensPath, lensPath_default;
var init_lensPath = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lensPath.js"() {
    init_curry1();
    init_assocPath();
    init_lens();
    init_path();
    lensPath = _curry1(function lensPath2(p) {
      return lens_default(path_default(p), assocPath_default(p));
    });
    lensPath_default = lensPath;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lensProp.js
var lensProp, lensProp_default;
var init_lensProp = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lensProp.js"() {
    init_curry1();
    init_assoc();
    init_lens();
    init_prop();
    lensProp = _curry1(function lensProp2(k) {
      return lens_default(prop_default(k), assoc_default(k));
    });
    lensProp_default = lensProp;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lt.js
var lt, lt_default;
var init_lt = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lt.js"() {
    init_curry2();
    lt = _curry2(function lt2(a, b) {
      return a < b;
    });
    lt_default = lt;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lte.js
var lte, lte_default;
var init_lte = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/lte.js"() {
    init_curry2();
    lte = _curry2(function lte2(a, b) {
      return a <= b;
    });
    lte_default = lte;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mapAccum.js
var mapAccum, mapAccum_default;
var init_mapAccum = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mapAccum.js"() {
    init_curry3();
    mapAccum = _curry3(function mapAccum2(fn, acc, list) {
      var idx = 0;
      var len = list.length;
      var result = [];
      var tuple = [acc];
      while (idx < len) {
        tuple = fn(tuple[0], list[idx]);
        result[idx] = tuple[1];
        idx += 1;
      }
      return [tuple[0], result];
    });
    mapAccum_default = mapAccum;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mapAccumRight.js
var mapAccumRight, mapAccumRight_default;
var init_mapAccumRight = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mapAccumRight.js"() {
    init_curry3();
    mapAccumRight = _curry3(function mapAccumRight2(fn, acc, list) {
      var idx = list.length - 1;
      var result = [];
      var tuple = [acc];
      while (idx >= 0) {
        tuple = fn(tuple[0], list[idx]);
        result[idx] = tuple[1];
        idx -= 1;
      }
      return [tuple[0], result];
    });
    mapAccumRight_default = mapAccumRight;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mapObjIndexed.js
var mapObjIndexed, mapObjIndexed_default;
var init_mapObjIndexed = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mapObjIndexed.js"() {
    init_curry2();
    init_reduce();
    init_keys();
    mapObjIndexed = _curry2(function mapObjIndexed2(fn, obj) {
      return _reduce(function(acc, key) {
        acc[key] = fn(obj[key], key, obj);
        return acc;
      }, {}, keys_default(obj));
    });
    mapObjIndexed_default = mapObjIndexed;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/match.js
var match, match_default;
var init_match = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/match.js"() {
    init_curry2();
    match = _curry2(function match2(rx, str) {
      return str.match(rx) || [];
    });
    match_default = match;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mathMod.js
var mathMod, mathMod_default;
var init_mathMod = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mathMod.js"() {
    init_curry2();
    init_isInteger();
    mathMod = _curry2(function mathMod2(m, p) {
      if (!isInteger_default(m)) {
        return NaN;
      }
      if (!isInteger_default(p) || p < 1) {
        return NaN;
      }
      return (m % p + p) % p;
    });
    mathMod_default = mathMod;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/maxBy.js
var maxBy, maxBy_default;
var init_maxBy = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/maxBy.js"() {
    init_curry3();
    maxBy = _curry3(function maxBy2(f, a, b) {
      return f(b) > f(a) ? b : a;
    });
    maxBy_default = maxBy;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/sum.js
var sum, sum_default;
var init_sum = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/sum.js"() {
    init_add();
    init_reduce2();
    sum = reduce_default(add_default, 0);
    sum_default = sum;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mean.js
var mean, mean_default;
var init_mean = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mean.js"() {
    init_curry1();
    init_sum();
    mean = _curry1(function mean2(list) {
      return sum_default(list) / list.length;
    });
    mean_default = mean;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/median.js
var median, median_default;
var init_median = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/median.js"() {
    init_curry1();
    init_mean();
    median = _curry1(function median2(list) {
      var len = list.length;
      if (len === 0) {
        return NaN;
      }
      var width = 2 - len % 2;
      var idx = (len - width) / 2;
      return mean_default(Array.prototype.slice.call(list, 0).sort(function(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }).slice(idx, idx + width));
    });
    median_default = median;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/memoizeWith.js
var memoizeWith, memoizeWith_default;
var init_memoizeWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/memoizeWith.js"() {
    init_arity();
    init_curry2();
    init_has();
    memoizeWith = _curry2(function memoizeWith2(mFn, fn) {
      var cache = {};
      return _arity(fn.length, function() {
        var key = mFn.apply(this, arguments);
        if (!_has(key, cache)) {
          cache[key] = fn.apply(this, arguments);
        }
        return cache[key];
      });
    });
    memoizeWith_default = memoizeWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/merge.js
var merge, merge_default;
var init_merge = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/merge.js"() {
    init_objectAssign();
    init_curry2();
    merge = _curry2(function merge2(l, r) {
      return objectAssign_default({}, l, r);
    });
    merge_default = merge;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeAll.js
var mergeAll, mergeAll_default;
var init_mergeAll = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeAll.js"() {
    init_objectAssign();
    init_curry1();
    mergeAll = _curry1(function mergeAll2(list) {
      return objectAssign_default.apply(null, [{}].concat(list));
    });
    mergeAll_default = mergeAll;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeWithKey.js
var mergeWithKey, mergeWithKey_default;
var init_mergeWithKey = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeWithKey.js"() {
    init_curry3();
    init_has();
    mergeWithKey = _curry3(function mergeWithKey2(fn, l, r) {
      var result = {};
      var k;
      for (k in l) {
        if (_has(k, l)) {
          result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
        }
      }
      for (k in r) {
        if (_has(k, r) && !_has(k, result)) {
          result[k] = r[k];
        }
      }
      return result;
    });
    mergeWithKey_default = mergeWithKey;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeDeepWithKey.js
var mergeDeepWithKey, mergeDeepWithKey_default;
var init_mergeDeepWithKey = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeDeepWithKey.js"() {
    init_curry3();
    init_isObject();
    init_mergeWithKey();
    mergeDeepWithKey = _curry3(function mergeDeepWithKey2(fn, lObj, rObj) {
      return mergeWithKey_default(function(k, lVal, rVal) {
        if (_isObject(lVal) && _isObject(rVal)) {
          return mergeDeepWithKey2(fn, lVal, rVal);
        } else {
          return fn(k, lVal, rVal);
        }
      }, lObj, rObj);
    });
    mergeDeepWithKey_default = mergeDeepWithKey;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeDeepLeft.js
var mergeDeepLeft, mergeDeepLeft_default;
var init_mergeDeepLeft = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeDeepLeft.js"() {
    init_curry2();
    init_mergeDeepWithKey();
    mergeDeepLeft = _curry2(function mergeDeepLeft2(lObj, rObj) {
      return mergeDeepWithKey_default(function(k, lVal, rVal) {
        return lVal;
      }, lObj, rObj);
    });
    mergeDeepLeft_default = mergeDeepLeft;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeDeepRight.js
var mergeDeepRight, mergeDeepRight_default;
var init_mergeDeepRight = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeDeepRight.js"() {
    init_curry2();
    init_mergeDeepWithKey();
    mergeDeepRight = _curry2(function mergeDeepRight2(lObj, rObj) {
      return mergeDeepWithKey_default(function(k, lVal, rVal) {
        return rVal;
      }, lObj, rObj);
    });
    mergeDeepRight_default = mergeDeepRight;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeDeepWith.js
var mergeDeepWith, mergeDeepWith_default;
var init_mergeDeepWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeDeepWith.js"() {
    init_curry3();
    init_mergeDeepWithKey();
    mergeDeepWith = _curry3(function mergeDeepWith2(fn, lObj, rObj) {
      return mergeDeepWithKey_default(function(k, lVal, rVal) {
        return fn(lVal, rVal);
      }, lObj, rObj);
    });
    mergeDeepWith_default = mergeDeepWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeLeft.js
var mergeLeft, mergeLeft_default;
var init_mergeLeft = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeLeft.js"() {
    init_objectAssign();
    init_curry2();
    mergeLeft = _curry2(function mergeLeft2(l, r) {
      return objectAssign_default({}, r, l);
    });
    mergeLeft_default = mergeLeft;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeRight.js
var mergeRight, mergeRight_default;
var init_mergeRight = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeRight.js"() {
    init_objectAssign();
    init_curry2();
    mergeRight = _curry2(function mergeRight2(l, r) {
      return objectAssign_default({}, l, r);
    });
    mergeRight_default = mergeRight;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeWith.js
var mergeWith, mergeWith_default;
var init_mergeWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/mergeWith.js"() {
    init_curry3();
    init_mergeWithKey();
    mergeWith = _curry3(function mergeWith2(fn, l, r) {
      return mergeWithKey_default(function(_, _l, _r) {
        return fn(_l, _r);
      }, l, r);
    });
    mergeWith_default = mergeWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/min.js
var min, min_default;
var init_min = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/min.js"() {
    init_curry2();
    min = _curry2(function min2(a, b) {
      return b < a ? b : a;
    });
    min_default = min;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/minBy.js
var minBy, minBy_default;
var init_minBy = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/minBy.js"() {
    init_curry3();
    minBy = _curry3(function minBy2(f, a, b) {
      return f(b) < f(a) ? b : a;
    });
    minBy_default = minBy;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/modulo.js
var modulo, modulo_default;
var init_modulo = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/modulo.js"() {
    init_curry2();
    modulo = _curry2(function modulo2(a, b) {
      return a % b;
    });
    modulo_default = modulo;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/move.js
var move, move_default;
var init_move = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/move.js"() {
    init_curry3();
    move = _curry3(function(from, to, list) {
      var length4 = list.length;
      var result = list.slice();
      var positiveFrom = from < 0 ? length4 + from : from;
      var positiveTo = to < 0 ? length4 + to : to;
      var item = result.splice(positiveFrom, 1);
      return positiveFrom < 0 || positiveFrom >= list.length || positiveTo < 0 || positiveTo >= list.length ? list : [].concat(result.slice(0, positiveTo)).concat(item).concat(result.slice(positiveTo, list.length));
    });
    move_default = move;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/multiply.js
var multiply, multiply_default;
var init_multiply = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/multiply.js"() {
    init_curry2();
    multiply = _curry2(function multiply2(a, b) {
      return a * b;
    });
    multiply_default = multiply;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/negate.js
var negate, negate_default;
var init_negate = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/negate.js"() {
    init_curry1();
    negate = _curry1(function negate2(n) {
      return -n;
    });
    negate_default = negate;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/none.js
var none, none_default;
var init_none = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/none.js"() {
    init_complement2();
    init_curry2();
    init_all();
    none = _curry2(function none2(fn, input) {
      return all_default(_complement(fn), input);
    });
    none_default = none;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/nthArg.js
var nthArg, nthArg_default;
var init_nthArg = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/nthArg.js"() {
    init_curry1();
    init_curryN2();
    init_nth();
    nthArg = _curry1(function nthArg2(n) {
      var arity = n < 0 ? 1 : n + 1;
      return curryN_default(arity, function() {
        return nth_default(n, arguments);
      });
    });
    nthArg_default = nthArg;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/o.js
var o, o_default;
var init_o = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/o.js"() {
    init_curry3();
    o = _curry3(function o2(f, g, x) {
      return f(g(x));
    });
    o_default = o;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_of.js
function _of(x) {
  return [x];
}
var init_of = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_of.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/of.js
var of, of_default;
var init_of2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/of.js"() {
    init_curry1();
    init_of();
    of = _curry1(_of);
    of_default = of;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/omit.js
var omit, omit_default;
var init_omit = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/omit.js"() {
    init_curry2();
    omit = _curry2(function omit2(names, obj) {
      var result = {};
      var index = {};
      var idx = 0;
      var len = names.length;
      while (idx < len) {
        index[names[idx]] = 1;
        idx += 1;
      }
      for (var prop3 in obj) {
        if (!index.hasOwnProperty(prop3)) {
          result[prop3] = obj[prop3];
        }
      }
      return result;
    });
    omit_default = omit;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/once.js
var once, once_default;
var init_once = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/once.js"() {
    init_arity();
    init_curry1();
    once = _curry1(function once2(fn) {
      var called = false;
      var result;
      return _arity(fn.length, function() {
        if (called) {
          return result;
        }
        called = true;
        result = fn.apply(this, arguments);
        return result;
      });
    });
    once_default = once;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_assertPromise.js
function _assertPromise(name, p) {
  if (p == null || !_isFunction(p.then)) {
    throw new TypeError("`" + name + "` expected a Promise, received " + _toString(p, []));
  }
}
var init_assertPromise = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_assertPromise.js"() {
    init_isFunction();
    init_toString();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/otherwise.js
var otherwise, otherwise_default;
var init_otherwise = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/otherwise.js"() {
    init_curry2();
    init_assertPromise();
    otherwise = _curry2(function otherwise2(f, p) {
      _assertPromise("otherwise", p);
      return p.then(null, f);
    });
    otherwise_default = otherwise;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/over.js
var Identity, over, over_default;
var init_over = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/over.js"() {
    init_curry3();
    Identity = function(x) {
      return {
        value: x,
        map: function(f) {
          return Identity(f(x));
        }
      };
    };
    over = _curry3(function over2(lens3, f, x) {
      return lens3(function(y) {
        return Identity(f(y));
      })(x).value;
    });
    over_default = over;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pair.js
var pair, pair_default;
var init_pair = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pair.js"() {
    init_curry2();
    pair = _curry2(function pair2(fst, snd) {
      return [fst, snd];
    });
    pair_default = pair;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_createPartialApplicator.js
function _createPartialApplicator(concat3) {
  return _curry2(function(fn, args) {
    return _arity(Math.max(0, fn.length - args.length), function() {
      return fn.apply(this, concat3(args, arguments));
    });
  });
}
var init_createPartialApplicator = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_createPartialApplicator.js"() {
    init_arity();
    init_curry2();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/partial.js
var partial, partial_default;
var init_partial = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/partial.js"() {
    init_concat();
    init_createPartialApplicator();
    partial = _createPartialApplicator(_concat);
    partial_default = partial;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/partialRight.js
var partialRight, partialRight_default;
var init_partialRight = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/partialRight.js"() {
    init_concat();
    init_createPartialApplicator();
    init_flip();
    partialRight = _createPartialApplicator(
      flip_default(_concat)
    );
    partialRight_default = partialRight;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/partition.js
var partition, partition_default;
var init_partition = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/partition.js"() {
    init_filter2();
    init_juxt();
    init_reject();
    partition = juxt_default([filter_default, reject_default]);
    partition_default = partition;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pathEq.js
var pathEq, pathEq_default;
var init_pathEq = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pathEq.js"() {
    init_curry3();
    init_equals2();
    init_path();
    pathEq = _curry3(function pathEq2(_path, val, obj) {
      return equals_default(path_default(_path, obj), val);
    });
    pathEq_default = pathEq;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pathOr.js
var pathOr, pathOr_default;
var init_pathOr = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pathOr.js"() {
    init_curry3();
    init_defaultTo();
    init_path();
    pathOr = _curry3(function pathOr2(d, p, obj) {
      return defaultTo_default(d, path_default(p, obj));
    });
    pathOr_default = pathOr;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pathSatisfies.js
var pathSatisfies, pathSatisfies_default;
var init_pathSatisfies = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pathSatisfies.js"() {
    init_curry3();
    init_path();
    pathSatisfies = _curry3(function pathSatisfies2(pred, propPath, obj) {
      return pred(path_default(propPath, obj));
    });
    pathSatisfies_default = pathSatisfies;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pick.js
var pick, pick_default;
var init_pick = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pick.js"() {
    init_curry2();
    pick = _curry2(function pick2(names, obj) {
      var result = {};
      var idx = 0;
      while (idx < names.length) {
        if (names[idx] in obj) {
          result[names[idx]] = obj[names[idx]];
        }
        idx += 1;
      }
      return result;
    });
    pick_default = pick;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pickAll.js
var pickAll, pickAll_default;
var init_pickAll = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pickAll.js"() {
    init_curry2();
    pickAll = _curry2(function pickAll2(names, obj) {
      var result = {};
      var idx = 0;
      var len = names.length;
      while (idx < len) {
        var name = names[idx];
        result[name] = obj[name];
        idx += 1;
      }
      return result;
    });
    pickAll_default = pickAll;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pickBy.js
var pickBy, pickBy_default;
var init_pickBy = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pickBy.js"() {
    init_curry2();
    pickBy = _curry2(function pickBy2(test3, obj) {
      var result = {};
      for (var prop3 in obj) {
        if (test3(obj[prop3], prop3, obj)) {
          result[prop3] = obj[prop3];
        }
      }
      return result;
    });
    pickBy_default = pickBy;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pipeK.js
function pipeK() {
  if (arguments.length === 0) {
    throw new Error("pipeK requires at least one argument");
  }
  return composeK.apply(this, reverse_default(arguments));
}
var init_pipeK = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/pipeK.js"() {
    init_composeK();
    init_reverse();
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/prepend.js
var prepend, prepend_default;
var init_prepend = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/prepend.js"() {
    init_concat();
    init_curry2();
    prepend = _curry2(function prepend2(el, list) {
      return _concat([el], list);
    });
    prepend_default = prepend;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/product.js
var product, product_default;
var init_product = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/product.js"() {
    init_multiply();
    init_reduce2();
    product = reduce_default(multiply_default, 1);
    product_default = product;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/useWith.js
var useWith, useWith_default;
var init_useWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/useWith.js"() {
    init_curry2();
    init_curryN2();
    useWith = _curry2(function useWith2(fn, transformers) {
      return curryN_default(transformers.length, function() {
        var args = [];
        var idx = 0;
        while (idx < transformers.length) {
          args.push(transformers[idx].call(this, arguments[idx]));
          idx += 1;
        }
        return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
      });
    });
    useWith_default = useWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/project.js
var project, project_default;
var init_project = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/project.js"() {
    init_map();
    init_identity2();
    init_pickAll();
    init_useWith();
    project = useWith_default(_map, [pickAll_default, identity_default]);
    project_default = project;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/propEq.js
var propEq, propEq_default;
var init_propEq = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/propEq.js"() {
    init_curry3();
    init_equals2();
    propEq = _curry3(function propEq2(name, val, obj) {
      return equals_default(val, obj[name]);
    });
    propEq_default = propEq;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/propIs.js
var propIs, propIs_default;
var init_propIs = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/propIs.js"() {
    init_curry3();
    init_is();
    propIs = _curry3(function propIs2(type3, name, obj) {
      return is_default(type3, obj[name]);
    });
    propIs_default = propIs;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/propOr.js
var propOr, propOr_default;
var init_propOr = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/propOr.js"() {
    init_curry3();
    init_pathOr();
    propOr = _curry3(function propOr2(val, p, obj) {
      return pathOr_default(val, [p], obj);
    });
    propOr_default = propOr;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/propSatisfies.js
var propSatisfies, propSatisfies_default;
var init_propSatisfies = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/propSatisfies.js"() {
    init_curry3();
    propSatisfies = _curry3(function propSatisfies2(pred, name, obj) {
      return pred(obj[name]);
    });
    propSatisfies_default = propSatisfies;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/props.js
var props, props_default;
var init_props = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/props.js"() {
    init_curry2();
    init_path();
    props = _curry2(function props2(ps, obj) {
      return ps.map(function(p) {
        return path_default([p], obj);
      });
    });
    props_default = props;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/range.js
var range, range_default;
var init_range = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/range.js"() {
    init_curry2();
    init_isNumber();
    range = _curry2(function range2(from, to) {
      if (!(_isNumber(from) && _isNumber(to))) {
        throw new TypeError("Both arguments to range must be numbers");
      }
      var result = [];
      var n = from;
      while (n < to) {
        result.push(n);
        n += 1;
      }
      return result;
    });
    range_default = range;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reduceRight.js
var reduceRight, reduceRight_default;
var init_reduceRight = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reduceRight.js"() {
    init_curry3();
    reduceRight = _curry3(function reduceRight2(fn, acc, list) {
      var idx = list.length - 1;
      while (idx >= 0) {
        acc = fn(list[idx], acc);
        idx -= 1;
      }
      return acc;
    });
    reduceRight_default = reduceRight;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reduceWhile.js
var reduceWhile, reduceWhile_default;
var init_reduceWhile = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reduceWhile.js"() {
    init_curryN();
    init_reduce();
    init_reduced();
    reduceWhile = _curryN(4, [], function _reduceWhile(pred, fn, a, list) {
      return _reduce(function(acc, x) {
        return pred(acc, x) ? fn(acc, x) : _reduced(acc);
      }, a, list);
    });
    reduceWhile_default = reduceWhile;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reduced.js
var reduced, reduced_default;
var init_reduced2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/reduced.js"() {
    init_curry1();
    init_reduced();
    reduced = _curry1(_reduced);
    reduced_default = reduced;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/times.js
var times, times_default;
var init_times = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/times.js"() {
    init_curry2();
    times = _curry2(function times2(fn, n) {
      var len = Number(n);
      var idx = 0;
      var list;
      if (len < 0 || isNaN(len)) {
        throw new RangeError("n must be a non-negative number");
      }
      list = new Array(len);
      while (idx < len) {
        list[idx] = fn(idx);
        idx += 1;
      }
      return list;
    });
    times_default = times;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/repeat.js
var repeat, repeat_default;
var init_repeat = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/repeat.js"() {
    init_curry2();
    init_always();
    init_times();
    repeat = _curry2(function repeat2(value2, n) {
      return times_default(always_default(value2), n);
    });
    repeat_default = repeat;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/replace.js
var replace, replace_default;
var init_replace = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/replace.js"() {
    init_curry3();
    replace = _curry3(function replace2(regex, replacement, str) {
      return str.replace(regex, replacement);
    });
    replace_default = replace;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/scan.js
var scan, scan_default;
var init_scan = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/scan.js"() {
    init_curry3();
    scan = _curry3(function scan2(fn, acc, list) {
      var idx = 0;
      var len = list.length;
      var result = [acc];
      while (idx < len) {
        acc = fn(acc, list[idx]);
        result[idx + 1] = acc;
        idx += 1;
      }
      return result;
    });
    scan_default = scan;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/sequence.js
var sequence, sequence_default;
var init_sequence = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/sequence.js"() {
    init_curry2();
    init_ap();
    init_map2();
    init_prepend();
    init_reduceRight();
    sequence = _curry2(function sequence2(of2, traversable) {
      return typeof traversable.sequence === "function" ? traversable.sequence(of2) : reduceRight_default(function(x, acc) {
        return ap_default(map_default(prepend_default, x), acc);
      }, of2([]), traversable);
    });
    sequence_default = sequence;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/set.js
var set2, set_default;
var init_set = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/set.js"() {
    init_curry3();
    init_always();
    init_over();
    set2 = _curry3(function set3(lens3, v, x) {
      return over_default(lens3, always_default(v), x);
    });
    set_default = set2;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/sort.js
var sort, sort_default;
var init_sort = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/sort.js"() {
    init_curry2();
    sort = _curry2(function sort2(comparator3, list) {
      return Array.prototype.slice.call(list, 0).sort(comparator3);
    });
    sort_default = sort;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/sortBy.js
var sortBy, sortBy_default;
var init_sortBy = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/sortBy.js"() {
    init_curry2();
    sortBy = _curry2(function sortBy2(fn, list) {
      return Array.prototype.slice.call(list, 0).sort(function(a, b) {
        var aa = fn(a);
        var bb = fn(b);
        return aa < bb ? -1 : aa > bb ? 1 : 0;
      });
    });
    sortBy_default = sortBy;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/sortWith.js
var sortWith, sortWith_default;
var init_sortWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/sortWith.js"() {
    init_curry2();
    sortWith = _curry2(function sortWith2(fns, list) {
      return Array.prototype.slice.call(list, 0).sort(function(a, b) {
        var result = 0;
        var i = 0;
        while (result === 0 && i < fns.length) {
          result = fns[i](a, b);
          i += 1;
        }
        return result;
      });
    });
    sortWith_default = sortWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/split.js
var split, split_default;
var init_split = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/split.js"() {
    init_invoker();
    split = invoker_default(1, "split");
    split_default = split;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/splitAt.js
var splitAt, splitAt_default;
var init_splitAt = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/splitAt.js"() {
    init_curry2();
    init_length();
    init_slice();
    splitAt = _curry2(function splitAt2(index, array) {
      return [slice_default(0, index, array), slice_default(index, length_default(array), array)];
    });
    splitAt_default = splitAt;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/splitEvery.js
var splitEvery, splitEvery_default;
var init_splitEvery = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/splitEvery.js"() {
    init_curry2();
    init_slice();
    splitEvery = _curry2(function splitEvery2(n, list) {
      if (n <= 0) {
        throw new Error("First argument to splitEvery must be a positive integer");
      }
      var result = [];
      var idx = 0;
      while (idx < list.length) {
        result.push(slice_default(idx, idx += n, list));
      }
      return result;
    });
    splitEvery_default = splitEvery;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/splitWhen.js
var splitWhen, splitWhen_default;
var init_splitWhen = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/splitWhen.js"() {
    init_curry2();
    splitWhen = _curry2(function splitWhen2(pred, list) {
      var idx = 0;
      var len = list.length;
      var prefix = [];
      while (idx < len && !pred(list[idx])) {
        prefix.push(list[idx]);
        idx += 1;
      }
      return [prefix, Array.prototype.slice.call(list, idx)];
    });
    splitWhen_default = splitWhen;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/startsWith.js
var startsWith, startsWith_default;
var init_startsWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/startsWith.js"() {
    init_curry2();
    init_equals2();
    init_take();
    startsWith = _curry2(function(prefix, list) {
      return equals_default(take_default(prefix.length, list), prefix);
    });
    startsWith_default = startsWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/subtract.js
var subtract, subtract_default;
var init_subtract = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/subtract.js"() {
    init_curry2();
    subtract = _curry2(function subtract2(a, b) {
      return Number(a) - Number(b);
    });
    subtract_default = subtract;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/symmetricDifference.js
var symmetricDifference, symmetricDifference_default;
var init_symmetricDifference = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/symmetricDifference.js"() {
    init_curry2();
    init_concat2();
    init_difference();
    symmetricDifference = _curry2(function symmetricDifference2(list1, list2) {
      return concat_default(difference_default(list1, list2), difference_default(list2, list1));
    });
    symmetricDifference_default = symmetricDifference;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/symmetricDifferenceWith.js
var symmetricDifferenceWith, symmetricDifferenceWith_default;
var init_symmetricDifferenceWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/symmetricDifferenceWith.js"() {
    init_curry3();
    init_concat2();
    init_differenceWith();
    symmetricDifferenceWith = _curry3(function symmetricDifferenceWith2(pred, list1, list2) {
      return concat_default(differenceWith_default(pred, list1, list2), differenceWith_default(pred, list2, list1));
    });
    symmetricDifferenceWith_default = symmetricDifferenceWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/takeLastWhile.js
var takeLastWhile, takeLastWhile_default;
var init_takeLastWhile = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/takeLastWhile.js"() {
    init_curry2();
    init_slice();
    takeLastWhile = _curry2(function takeLastWhile2(fn, xs) {
      var idx = xs.length - 1;
      while (idx >= 0 && fn(xs[idx])) {
        idx -= 1;
      }
      return slice_default(idx + 1, Infinity, xs);
    });
    takeLastWhile_default = takeLastWhile;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xtakeWhile.js
var XTakeWhile, _xtakeWhile, xtakeWhile_default;
var init_xtakeWhile = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xtakeWhile.js"() {
    init_curry2();
    init_reduced();
    init_xfBase();
    XTakeWhile = function() {
      function XTakeWhile2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XTakeWhile2.prototype["@@transducer/init"] = xfBase_default.init;
      XTakeWhile2.prototype["@@transducer/result"] = xfBase_default.result;
      XTakeWhile2.prototype["@@transducer/step"] = function(result, input) {
        return this.f(input) ? this.xf["@@transducer/step"](result, input) : _reduced(result);
      };
      return XTakeWhile2;
    }();
    _xtakeWhile = _curry2(function _xtakeWhile2(f, xf) {
      return new XTakeWhile(f, xf);
    });
    xtakeWhile_default = _xtakeWhile;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/takeWhile.js
var takeWhile, takeWhile_default;
var init_takeWhile = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/takeWhile.js"() {
    init_curry2();
    init_dispatchable();
    init_xtakeWhile();
    init_slice();
    takeWhile = _curry2(
      _dispatchable(["takeWhile"], xtakeWhile_default, function takeWhile2(fn, xs) {
        var idx = 0;
        var len = xs.length;
        while (idx < len && fn(xs[idx])) {
          idx += 1;
        }
        return slice_default(0, idx, xs);
      })
    );
    takeWhile_default = takeWhile;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xtap.js
var XTap, _xtap, xtap_default;
var init_xtap = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_xtap.js"() {
    init_curry2();
    init_xfBase();
    XTap = function() {
      function XTap2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XTap2.prototype["@@transducer/init"] = xfBase_default.init;
      XTap2.prototype["@@transducer/result"] = xfBase_default.result;
      XTap2.prototype["@@transducer/step"] = function(result, input) {
        this.f(input);
        return this.xf["@@transducer/step"](result, input);
      };
      return XTap2;
    }();
    _xtap = _curry2(function _xtap2(f, xf) {
      return new XTap(f, xf);
    });
    xtap_default = _xtap;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/tap.js
var tap, tap_default;
var init_tap = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/tap.js"() {
    init_curry2();
    init_dispatchable();
    init_xtap();
    tap = _curry2(
      _dispatchable([], xtap_default, function tap2(fn, x) {
        fn(x);
        return x;
      })
    );
    tap_default = tap;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isRegExp.js
function _isRegExp(x) {
  return Object.prototype.toString.call(x) === "[object RegExp]";
}
var init_isRegExp = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/internal/_isRegExp.js"() {
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/test.js
var test, test_default;
var init_test = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/test.js"() {
    init_cloneRegExp();
    init_curry2();
    init_isRegExp();
    init_toString2();
    test = _curry2(function test2(pattern, str) {
      if (!_isRegExp(pattern)) {
        throw new TypeError("‘test’ requires a value of type RegExp as its first argument; received " + toString_default(pattern));
      }
      return _cloneRegExp(pattern).test(str);
    });
    test_default = test;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/andThen.js
var andThen, andThen_default;
var init_andThen = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/andThen.js"() {
    init_curry2();
    init_assertPromise();
    andThen = _curry2(function andThen2(f, p) {
      _assertPromise("andThen", p);
      return p.then(f);
    });
    andThen_default = andThen;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/toLower.js
var toLower, toLower_default;
var init_toLower = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/toLower.js"() {
    init_invoker();
    toLower = invoker_default(0, "toLowerCase");
    toLower_default = toLower;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/toPairs.js
var toPairs, toPairs_default;
var init_toPairs = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/toPairs.js"() {
    init_curry1();
    init_has();
    toPairs = _curry1(function toPairs2(obj) {
      var pairs2 = [];
      for (var prop3 in obj) {
        if (_has(prop3, obj)) {
          pairs2[pairs2.length] = [prop3, obj[prop3]];
        }
      }
      return pairs2;
    });
    toPairs_default = toPairs;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/toPairsIn.js
var toPairsIn, toPairsIn_default;
var init_toPairsIn = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/toPairsIn.js"() {
    init_curry1();
    toPairsIn = _curry1(function toPairsIn2(obj) {
      var pairs2 = [];
      for (var prop3 in obj) {
        pairs2[pairs2.length] = [prop3, obj[prop3]];
      }
      return pairs2;
    });
    toPairsIn_default = toPairsIn;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/toUpper.js
var toUpper, toUpper_default;
var init_toUpper = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/toUpper.js"() {
    init_invoker();
    toUpper = invoker_default(0, "toUpperCase");
    toUpper_default = toUpper;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/transduce.js
var transduce, transduce_default;
var init_transduce = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/transduce.js"() {
    init_reduce();
    init_xwrap();
    init_curryN2();
    transduce = curryN_default(4, function transduce2(xf, fn, acc, list) {
      return _reduce(xf(typeof fn === "function" ? _xwrap(fn) : fn), acc, list);
    });
    transduce_default = transduce;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/transpose.js
var transpose, transpose_default;
var init_transpose = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/transpose.js"() {
    init_curry1();
    transpose = _curry1(function transpose2(outerlist) {
      var i = 0;
      var result = [];
      while (i < outerlist.length) {
        var innerlist = outerlist[i];
        var j = 0;
        while (j < innerlist.length) {
          if (typeof result[j] === "undefined") {
            result[j] = [];
          }
          result[j].push(innerlist[j]);
          j += 1;
        }
        i += 1;
      }
      return result;
    });
    transpose_default = transpose;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/traverse.js
var traverse, traverse_default;
var init_traverse = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/traverse.js"() {
    init_curry3();
    init_map2();
    init_sequence();
    traverse = _curry3(function traverse2(of2, f, traversable) {
      return typeof traversable["fantasy-land/traverse"] === "function" ? traversable["fantasy-land/traverse"](f, of2) : sequence_default(of2, map_default(f, traversable));
    });
    traverse_default = traverse;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/trim.js
var ws, zeroWidth, hasProtoTrim, trim, trim_default;
var init_trim = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/trim.js"() {
    init_curry1();
    ws = "	\n\v\f\r                　\u2028\u2029\uFEFF";
    zeroWidth = "​";
    hasProtoTrim = typeof String.prototype.trim === "function";
    trim = !hasProtoTrim || ws.trim() || !zeroWidth.trim() ? _curry1(function trim2(str) {
      var beginRx = new RegExp("^[" + ws + "][" + ws + "]*");
      var endRx = new RegExp("[" + ws + "][" + ws + "]*$");
      return str.replace(beginRx, "").replace(endRx, "");
    }) : _curry1(function trim3(str) {
      return str.trim();
    });
    trim_default = trim;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/tryCatch.js
var tryCatch, tryCatch_default;
var init_tryCatch = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/tryCatch.js"() {
    init_arity();
    init_concat();
    init_curry2();
    tryCatch = _curry2(function _tryCatch(tryer, catcher) {
      return _arity(tryer.length, function() {
        try {
          return tryer.apply(this, arguments);
        } catch (e) {
          return catcher.apply(this, _concat([e], arguments));
        }
      });
    });
    tryCatch_default = tryCatch;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unapply.js
var unapply, unapply_default;
var init_unapply = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unapply.js"() {
    init_curry1();
    unapply = _curry1(function unapply2(fn) {
      return function() {
        return fn(Array.prototype.slice.call(arguments, 0));
      };
    });
    unapply_default = unapply;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unary.js
var unary, unary_default;
var init_unary = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unary.js"() {
    init_curry1();
    init_nAry();
    unary = _curry1(function unary2(fn) {
      return nAry_default(1, fn);
    });
    unary_default = unary;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/uncurryN.js
var uncurryN, uncurryN_default;
var init_uncurryN = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/uncurryN.js"() {
    init_curry2();
    init_curryN2();
    uncurryN = _curry2(function uncurryN2(depth, fn) {
      return curryN_default(depth, function() {
        var currentDepth = 1;
        var value2 = fn;
        var idx = 0;
        var endIdx;
        while (currentDepth <= depth && typeof value2 === "function") {
          endIdx = currentDepth === depth ? arguments.length : idx + value2.length;
          value2 = value2.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
          currentDepth += 1;
          idx = endIdx;
        }
        return value2;
      });
    });
    uncurryN_default = uncurryN;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unfold.js
var unfold, unfold_default;
var init_unfold = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unfold.js"() {
    init_curry2();
    unfold = _curry2(function unfold2(fn, seed) {
      var pair3 = fn(seed);
      var result = [];
      while (pair3 && pair3.length) {
        result[result.length] = pair3[0];
        pair3 = fn(pair3[1]);
      }
      return result;
    });
    unfold_default = unfold;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/union.js
var union, union_default;
var init_union = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/union.js"() {
    init_concat();
    init_curry2();
    init_compose();
    init_uniq();
    union = _curry2(
      compose(uniq_default, _concat)
    );
    union_default = union;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/uniqWith.js
var uniqWith, uniqWith_default;
var init_uniqWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/uniqWith.js"() {
    init_includesWith();
    init_curry2();
    uniqWith = _curry2(function uniqWith2(pred, list) {
      var idx = 0;
      var len = list.length;
      var result = [];
      var item;
      while (idx < len) {
        item = list[idx];
        if (!_includesWith(pred, item, result)) {
          result[result.length] = item;
        }
        idx += 1;
      }
      return result;
    });
    uniqWith_default = uniqWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unionWith.js
var unionWith, unionWith_default;
var init_unionWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unionWith.js"() {
    init_concat();
    init_curry3();
    init_uniqWith();
    unionWith = _curry3(function unionWith2(pred, list1, list2) {
      return uniqWith_default(pred, _concat(list1, list2));
    });
    unionWith_default = unionWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unless.js
var unless, unless_default;
var init_unless = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unless.js"() {
    init_curry3();
    unless = _curry3(function unless2(pred, whenFalseFn, x) {
      return pred(x) ? x : whenFalseFn(x);
    });
    unless_default = unless;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unnest.js
var unnest, unnest_default;
var init_unnest = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/unnest.js"() {
    init_identity();
    init_chain();
    unnest = chain_default(_identity);
    unnest_default = unnest;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/until.js
var until, until_default;
var init_until = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/until.js"() {
    init_curry3();
    until = _curry3(function until2(pred, fn, init2) {
      var val = init2;
      while (!pred(val)) {
        val = fn(val);
      }
      return val;
    });
    until_default = until;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/valuesIn.js
var valuesIn, valuesIn_default;
var init_valuesIn = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/valuesIn.js"() {
    init_curry1();
    valuesIn = _curry1(function valuesIn2(obj) {
      var prop3;
      var vs = [];
      for (prop3 in obj) {
        vs[vs.length] = obj[prop3];
      }
      return vs;
    });
    valuesIn_default = valuesIn;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/view.js
var Const, view, view_default;
var init_view = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/view.js"() {
    init_curry2();
    Const = function(x) {
      return {
        value: x,
        "fantasy-land/map": function() {
          return this;
        }
      };
    };
    view = _curry2(function view2(lens3, x) {
      return lens3(Const)(x).value;
    });
    view_default = view;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/when.js
var when, when_default;
var init_when = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/when.js"() {
    init_curry3();
    when = _curry3(function when2(pred, whenTrueFn, x) {
      return pred(x) ? whenTrueFn(x) : x;
    });
    when_default = when;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/where.js
var where, where_default;
var init_where = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/where.js"() {
    init_curry2();
    init_has();
    where = _curry2(function where2(spec, testObj) {
      for (var prop3 in spec) {
        if (_has(prop3, spec) && !spec[prop3](testObj[prop3])) {
          return false;
        }
      }
      return true;
    });
    where_default = where;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/whereEq.js
var whereEq, whereEq_default;
var init_whereEq = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/whereEq.js"() {
    init_curry2();
    init_equals2();
    init_map2();
    init_where();
    whereEq = _curry2(function whereEq2(spec, testObj) {
      return where_default(map_default(equals_default, spec), testObj);
    });
    whereEq_default = whereEq;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/without.js
var without, without_default;
var init_without = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/without.js"() {
    init_includes();
    init_curry2();
    init_flip();
    init_reject();
    without = _curry2(function(xs, list) {
      return reject_default(flip_default(_includes)(xs), list);
    });
    without_default = without;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/xor.js
var xor, xor_default;
var init_xor = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/xor.js"() {
    init_curry2();
    xor = _curry2(function xor2(a, b) {
      return Boolean(!a ^ !b);
    });
    xor_default = xor;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/xprod.js
var xprod, xprod_default;
var init_xprod = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/xprod.js"() {
    init_curry2();
    xprod = _curry2(function xprod2(a, b) {
      var idx = 0;
      var ilen = a.length;
      var j;
      var jlen = b.length;
      var result = [];
      while (idx < ilen) {
        j = 0;
        while (j < jlen) {
          result[result.length] = [a[idx], b[j]];
          j += 1;
        }
        idx += 1;
      }
      return result;
    });
    xprod_default = xprod;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/zip.js
var zip, zip_default;
var init_zip = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/zip.js"() {
    init_curry2();
    zip = _curry2(function zip2(a, b) {
      var rv = [];
      var idx = 0;
      var len = Math.min(a.length, b.length);
      while (idx < len) {
        rv[idx] = [a[idx], b[idx]];
        idx += 1;
      }
      return rv;
    });
    zip_default = zip;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/zipObj.js
var zipObj, zipObj_default;
var init_zipObj = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/zipObj.js"() {
    init_curry2();
    zipObj = _curry2(function zipObj2(keys4, values3) {
      var idx = 0;
      var len = Math.min(keys4.length, values3.length);
      var out = {};
      while (idx < len) {
        out[keys4[idx]] = values3[idx];
        idx += 1;
      }
      return out;
    });
    zipObj_default = zipObj;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/zipWith.js
var zipWith, zipWith_default;
var init_zipWith = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/zipWith.js"() {
    init_curry3();
    zipWith = _curry3(function zipWith2(fn, a, b) {
      var rv = [];
      var idx = 0;
      var len = Math.min(a.length, b.length);
      while (idx < len) {
        rv[idx] = fn(a[idx], b[idx]);
        idx += 1;
      }
      return rv;
    });
    zipWith_default = zipWith;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/thunkify.js
var thunkify, thunkify_default;
var init_thunkify = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/thunkify.js"() {
    init_curryN2();
    init_curry1();
    thunkify = _curry1(function thunkify2(fn) {
      return curryN_default(fn.length, function createThunk() {
        var fnArgs = arguments;
        return function invokeThunk() {
          return fn.apply(this, fnArgs);
        };
      });
    });
    thunkify_default = thunkify;
  }
});

// node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/index.js
var es_exports2 = {};
__export(es_exports2, {
  F: () => F_default,
  T: () => T_default,
  __: () => __default,
  add: () => add_default,
  addIndex: () => addIndex_default,
  adjust: () => adjust_default,
  all: () => all_default,
  allPass: () => allPass_default,
  always: () => always_default,
  and: () => and_default,
  andThen: () => andThen_default,
  any: () => any_default,
  anyPass: () => anyPass_default,
  ap: () => ap_default,
  aperture: () => aperture_default,
  append: () => append_default,
  apply: () => apply_default,
  applySpec: () => applySpec_default,
  applyTo: () => applyTo_default,
  ascend: () => ascend_default,
  assoc: () => assoc_default,
  assocPath: () => assocPath_default,
  binary: () => binary_default,
  bind: () => bind_default,
  both: () => both_default,
  call: () => call_default,
  chain: () => chain_default,
  clamp: () => clamp_default,
  clone: () => clone_default,
  comparator: () => comparator_default,
  complement: () => complement_default,
  compose: () => compose,
  composeK: () => composeK,
  composeP: () => composeP,
  composeWith: () => composeWith_default,
  concat: () => concat_default,
  cond: () => cond_default,
  construct: () => construct_default,
  constructN: () => constructN_default,
  contains: () => contains_default,
  converge: () => converge_default,
  countBy: () => countBy_default,
  curry: () => curry_default,
  curryN: () => curryN_default,
  dec: () => dec_default,
  defaultTo: () => defaultTo_default,
  descend: () => descend_default,
  difference: () => difference_default,
  differenceWith: () => differenceWith_default,
  dissoc: () => dissoc_default,
  dissocPath: () => dissocPath_default,
  divide: () => divide_default,
  drop: () => drop_default,
  dropLast: () => dropLast_default,
  dropLastWhile: () => dropLastWhile_default,
  dropRepeats: () => dropRepeats_default,
  dropRepeatsWith: () => dropRepeatsWith_default,
  dropWhile: () => dropWhile_default,
  either: () => either_default,
  empty: () => empty_default,
  endsWith: () => endsWith_default,
  eqBy: () => eqBy_default,
  eqProps: () => eqProps_default,
  equals: () => equals_default,
  evolve: () => evolve_default,
  filter: () => filter_default,
  find: () => find_default,
  findIndex: () => findIndex_default,
  findLast: () => findLast_default,
  findLastIndex: () => findLastIndex_default,
  flatten: () => flatten_default,
  flip: () => flip_default,
  forEach: () => forEach_default,
  forEachObjIndexed: () => forEachObjIndexed_default,
  fromPairs: () => fromPairs_default,
  groupBy: () => groupBy_default,
  groupWith: () => groupWith_default,
  gt: () => gt_default,
  gte: () => gte_default,
  has: () => has_default,
  hasIn: () => hasIn_default,
  hasPath: () => hasPath_default,
  head: () => head_default,
  identical: () => identical_default,
  identity: () => identity_default,
  ifElse: () => ifElse_default,
  inc: () => inc_default,
  includes: () => includes_default,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  init: () => init_default,
  innerJoin: () => innerJoin_default,
  insert: () => insert_default,
  insertAll: () => insertAll_default,
  intersection: () => intersection_default,
  intersperse: () => intersperse_default,
  into: () => into_default,
  invert: () => invert_default,
  invertObj: () => invertObj_default,
  invoker: () => invoker_default,
  is: () => is_default,
  isEmpty: () => isEmpty_default,
  isNil: () => isNil_default,
  join: () => join_default,
  juxt: () => juxt_default,
  keys: () => keys_default,
  keysIn: () => keysIn_default,
  last: () => last_default,
  lastIndexOf: () => lastIndexOf_default,
  length: () => length_default,
  lens: () => lens_default,
  lensIndex: () => lensIndex_default,
  lensPath: () => lensPath_default,
  lensProp: () => lensProp_default,
  lift: () => lift_default,
  liftN: () => liftN_default,
  lt: () => lt_default,
  lte: () => lte_default,
  map: () => map_default,
  mapAccum: () => mapAccum_default,
  mapAccumRight: () => mapAccumRight_default,
  mapObjIndexed: () => mapObjIndexed_default,
  match: () => match_default,
  mathMod: () => mathMod_default,
  max: () => max_default,
  maxBy: () => maxBy_default,
  mean: () => mean_default,
  median: () => median_default,
  memoizeWith: () => memoizeWith_default,
  merge: () => merge_default,
  mergeAll: () => mergeAll_default,
  mergeDeepLeft: () => mergeDeepLeft_default,
  mergeDeepRight: () => mergeDeepRight_default,
  mergeDeepWith: () => mergeDeepWith_default,
  mergeDeepWithKey: () => mergeDeepWithKey_default,
  mergeLeft: () => mergeLeft_default,
  mergeRight: () => mergeRight_default,
  mergeWith: () => mergeWith_default,
  mergeWithKey: () => mergeWithKey_default,
  min: () => min_default,
  minBy: () => minBy_default,
  modulo: () => modulo_default,
  move: () => move_default,
  multiply: () => multiply_default,
  nAry: () => nAry_default,
  negate: () => negate_default,
  none: () => none_default,
  not: () => not_default,
  nth: () => nth_default,
  nthArg: () => nthArg_default,
  o: () => o_default,
  objOf: () => objOf_default,
  of: () => of_default,
  omit: () => omit_default,
  once: () => once_default,
  or: () => or_default,
  otherwise: () => otherwise_default,
  over: () => over_default,
  pair: () => pair_default,
  partial: () => partial_default,
  partialRight: () => partialRight_default,
  partition: () => partition_default,
  path: () => path_default,
  pathEq: () => pathEq_default,
  pathOr: () => pathOr_default,
  pathSatisfies: () => pathSatisfies_default,
  paths: () => paths_default,
  pick: () => pick_default,
  pickAll: () => pickAll_default,
  pickBy: () => pickBy_default,
  pipe: () => pipe,
  pipeK: () => pipeK,
  pipeP: () => pipeP,
  pipeWith: () => pipeWith_default,
  pluck: () => pluck_default,
  prepend: () => prepend_default,
  product: () => product_default,
  project: () => project_default,
  prop: () => prop_default,
  propEq: () => propEq_default,
  propIs: () => propIs_default,
  propOr: () => propOr_default,
  propSatisfies: () => propSatisfies_default,
  props: () => props_default,
  range: () => range_default,
  reduce: () => reduce_default,
  reduceBy: () => reduceBy_default,
  reduceRight: () => reduceRight_default,
  reduceWhile: () => reduceWhile_default,
  reduced: () => reduced_default,
  reject: () => reject_default,
  remove: () => remove_default,
  repeat: () => repeat_default,
  replace: () => replace_default,
  reverse: () => reverse_default,
  scan: () => scan_default,
  sequence: () => sequence_default,
  set: () => set_default,
  slice: () => slice_default,
  sort: () => sort_default,
  sortBy: () => sortBy_default,
  sortWith: () => sortWith_default,
  split: () => split_default,
  splitAt: () => splitAt_default,
  splitEvery: () => splitEvery_default,
  splitWhen: () => splitWhen_default,
  startsWith: () => startsWith_default,
  subtract: () => subtract_default,
  sum: () => sum_default,
  symmetricDifference: () => symmetricDifference_default,
  symmetricDifferenceWith: () => symmetricDifferenceWith_default,
  tail: () => tail_default,
  take: () => take_default,
  takeLast: () => takeLast_default,
  takeLastWhile: () => takeLastWhile_default,
  takeWhile: () => takeWhile_default,
  tap: () => tap_default,
  test: () => test_default,
  thunkify: () => thunkify_default,
  times: () => times_default,
  toLower: () => toLower_default,
  toPairs: () => toPairs_default,
  toPairsIn: () => toPairsIn_default,
  toString: () => toString_default,
  toUpper: () => toUpper_default,
  transduce: () => transduce_default,
  transpose: () => transpose_default,
  traverse: () => traverse_default,
  trim: () => trim_default,
  tryCatch: () => tryCatch_default,
  type: () => type_default,
  unapply: () => unapply_default,
  unary: () => unary_default,
  uncurryN: () => uncurryN_default,
  unfold: () => unfold_default,
  union: () => union_default,
  unionWith: () => unionWith_default,
  uniq: () => uniq_default,
  uniqBy: () => uniqBy_default,
  uniqWith: () => uniqWith_default,
  unless: () => unless_default,
  unnest: () => unnest_default,
  until: () => until_default,
  update: () => update_default,
  useWith: () => useWith_default,
  values: () => values_default,
  valuesIn: () => valuesIn_default,
  view: () => view_default,
  when: () => when_default,
  where: () => where_default,
  whereEq: () => whereEq_default,
  without: () => without_default,
  xor: () => xor_default,
  xprod: () => xprod_default,
  zip: () => zip_default,
  zipObj: () => zipObj_default,
  zipWith: () => zipWith_default
});
var init_es2 = __esm({
  "node_modules/.pnpm/ramda@0.27.2/node_modules/ramda/es/index.js"() {
    init_F();
    init_T();
    init__();
    init_add();
    init_addIndex();
    init_adjust();
    init_all();
    init_allPass();
    init_always();
    init_and();
    init_any();
    init_anyPass();
    init_ap();
    init_aperture2();
    init_append();
    init_apply();
    init_applySpec();
    init_applyTo();
    init_ascend();
    init_assoc();
    init_assocPath();
    init_binary();
    init_bind();
    init_both();
    init_call();
    init_chain();
    init_clamp();
    init_clone2();
    init_comparator();
    init_complement();
    init_compose();
    init_composeK();
    init_composeP();
    init_composeWith();
    init_concat2();
    init_cond();
    init_construct();
    init_constructN();
    init_contains();
    init_converge();
    init_countBy();
    init_curry();
    init_curryN2();
    init_dec();
    init_defaultTo();
    init_descend();
    init_difference();
    init_differenceWith();
    init_dissoc();
    init_dissocPath();
    init_divide();
    init_drop();
    init_dropLast2();
    init_dropLastWhile2();
    init_dropRepeats();
    init_dropRepeatsWith();
    init_dropWhile();
    init_either();
    init_empty();
    init_endsWith();
    init_eqBy();
    init_eqProps();
    init_equals2();
    init_evolve();
    init_filter2();
    init_find();
    init_findIndex();
    init_findLast();
    init_findLastIndex();
    init_flatten();
    init_flip();
    init_forEach();
    init_forEachObjIndexed();
    init_fromPairs();
    init_groupBy();
    init_groupWith();
    init_gt();
    init_gte();
    init_has2();
    init_hasIn();
    init_hasPath();
    init_head();
    init_identical();
    init_identity2();
    init_ifElse();
    init_inc();
    init_includes2();
    init_indexBy();
    init_indexOf2();
    init_init();
    init_innerJoin();
    init_insert();
    init_insertAll();
    init_intersection();
    init_intersperse();
    init_into();
    init_invert();
    init_invertObj();
    init_invoker();
    init_is();
    init_isEmpty();
    init_isNil();
    init_join();
    init_juxt();
    init_keys();
    init_keysIn();
    init_last();
    init_lastIndexOf();
    init_length();
    init_lens();
    init_lensIndex();
    init_lensPath();
    init_lensProp();
    init_lift();
    init_liftN();
    init_lt();
    init_lte();
    init_map2();
    init_mapAccum();
    init_mapAccumRight();
    init_mapObjIndexed();
    init_match();
    init_mathMod();
    init_max();
    init_maxBy();
    init_mean();
    init_median();
    init_memoizeWith();
    init_merge();
    init_mergeAll();
    init_mergeDeepLeft();
    init_mergeDeepRight();
    init_mergeDeepWith();
    init_mergeDeepWithKey();
    init_mergeLeft();
    init_mergeRight();
    init_mergeWith();
    init_mergeWithKey();
    init_min();
    init_minBy();
    init_modulo();
    init_move();
    init_multiply();
    init_nAry();
    init_negate();
    init_none();
    init_not();
    init_nth();
    init_nthArg();
    init_o();
    init_objOf();
    init_of2();
    init_omit();
    init_once();
    init_or();
    init_otherwise();
    init_over();
    init_pair();
    init_partial();
    init_partialRight();
    init_partition();
    init_path();
    init_paths();
    init_pathEq();
    init_pathOr();
    init_pathSatisfies();
    init_pick();
    init_pickAll();
    init_pickBy();
    init_pipe2();
    init_pipeK();
    init_pipeP2();
    init_pipeWith();
    init_pluck();
    init_prepend();
    init_product();
    init_project();
    init_prop();
    init_propEq();
    init_propIs();
    init_propOr();
    init_propSatisfies();
    init_props();
    init_range();
    init_reduce2();
    init_reduceBy();
    init_reduceRight();
    init_reduceWhile();
    init_reduced2();
    init_reject();
    init_remove();
    init_repeat();
    init_replace();
    init_reverse();
    init_scan();
    init_sequence();
    init_set();
    init_slice();
    init_sort();
    init_sortBy();
    init_sortWith();
    init_split();
    init_splitAt();
    init_splitEvery();
    init_splitWhen();
    init_startsWith();
    init_subtract();
    init_sum();
    init_symmetricDifference();
    init_symmetricDifferenceWith();
    init_tail();
    init_take();
    init_takeLast();
    init_takeLastWhile();
    init_takeWhile();
    init_tap();
    init_test();
    init_andThen();
    init_times();
    init_toLower();
    init_toPairs();
    init_toPairsIn();
    init_toString2();
    init_toUpper();
    init_transduce();
    init_transpose();
    init_traverse();
    init_trim();
    init_tryCatch();
    init_type();
    init_unapply();
    init_unary();
    init_uncurryN();
    init_unfold();
    init_union();
    init_unionWith();
    init_uniq();
    init_uniqBy();
    init_uniqWith();
    init_unless();
    init_unnest();
    init_until();
    init_update();
    init_useWith();
    init_values();
    init_valuesIn();
    init_view();
    init_when();
    init_where();
    init_whereEq();
    init_without();
    init_xor();
    init_xprod();
    init_zip();
    init_zipObj();
    init_zipWith();
    init_thunkify();
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/utils/shallowEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = shallowEqual;
    function shallowEqual(actual, expected) {
      const keys4 = Object.keys(expected);
      for (const key of keys4) {
        if (actual[key] !== expected[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/utils/deprecationWarning.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = deprecationWarning;
    var warnings = /* @__PURE__ */ new Set();
    function deprecationWarning(oldName, newName, prefix = "") {
      if (warnings.has(oldName))
        return;
      warnings.add(oldName);
      const {
        internal,
        trace
      } = captureShortStackTrace(1, 2);
      if (internal) {
        return;
      }
      console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
    }
    function captureShortStackTrace(skip, length4) {
      const {
        stackTraceLimit,
        prepareStackTrace
      } = Error;
      let stackTrace;
      Error.stackTraceLimit = 1 + skip + length4;
      Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
      };
      new Error().stack;
      Error.stackTraceLimit = stackTraceLimit;
      Error.prepareStackTrace = prepareStackTrace;
      if (!stackTrace)
        return {
          internal: false,
          trace: ""
        };
      const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length4);
      return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n")
      };
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAccessor = isAccessor;
    exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
    exports.isArgumentPlaceholder = isArgumentPlaceholder;
    exports.isArrayExpression = isArrayExpression;
    exports.isArrayPattern = isArrayPattern;
    exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
    exports.isArrowFunctionExpression = isArrowFunctionExpression;
    exports.isAssignmentExpression = isAssignmentExpression;
    exports.isAssignmentPattern = isAssignmentPattern;
    exports.isAwaitExpression = isAwaitExpression;
    exports.isBigIntLiteral = isBigIntLiteral;
    exports.isBinary = isBinary;
    exports.isBinaryExpression = isBinaryExpression;
    exports.isBindExpression = isBindExpression;
    exports.isBlock = isBlock;
    exports.isBlockParent = isBlockParent;
    exports.isBlockStatement = isBlockStatement;
    exports.isBooleanLiteral = isBooleanLiteral;
    exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
    exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
    exports.isBreakStatement = isBreakStatement;
    exports.isCallExpression = isCallExpression;
    exports.isCatchClause = isCatchClause;
    exports.isClass = isClass;
    exports.isClassAccessorProperty = isClassAccessorProperty;
    exports.isClassBody = isClassBody;
    exports.isClassDeclaration = isClassDeclaration;
    exports.isClassExpression = isClassExpression;
    exports.isClassImplements = isClassImplements;
    exports.isClassMethod = isClassMethod;
    exports.isClassPrivateMethod = isClassPrivateMethod;
    exports.isClassPrivateProperty = isClassPrivateProperty;
    exports.isClassProperty = isClassProperty;
    exports.isCompletionStatement = isCompletionStatement;
    exports.isConditional = isConditional;
    exports.isConditionalExpression = isConditionalExpression;
    exports.isContinueStatement = isContinueStatement;
    exports.isDebuggerStatement = isDebuggerStatement;
    exports.isDecimalLiteral = isDecimalLiteral;
    exports.isDeclaration = isDeclaration;
    exports.isDeclareClass = isDeclareClass;
    exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
    exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
    exports.isDeclareFunction = isDeclareFunction;
    exports.isDeclareInterface = isDeclareInterface;
    exports.isDeclareModule = isDeclareModule;
    exports.isDeclareModuleExports = isDeclareModuleExports;
    exports.isDeclareOpaqueType = isDeclareOpaqueType;
    exports.isDeclareTypeAlias = isDeclareTypeAlias;
    exports.isDeclareVariable = isDeclareVariable;
    exports.isDeclaredPredicate = isDeclaredPredicate;
    exports.isDecorator = isDecorator;
    exports.isDirective = isDirective;
    exports.isDirectiveLiteral = isDirectiveLiteral;
    exports.isDoExpression = isDoExpression;
    exports.isDoWhileStatement = isDoWhileStatement;
    exports.isEmptyStatement = isEmptyStatement;
    exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
    exports.isEnumBody = isEnumBody;
    exports.isEnumBooleanBody = isEnumBooleanBody;
    exports.isEnumBooleanMember = isEnumBooleanMember;
    exports.isEnumDeclaration = isEnumDeclaration;
    exports.isEnumDefaultedMember = isEnumDefaultedMember;
    exports.isEnumMember = isEnumMember;
    exports.isEnumNumberBody = isEnumNumberBody;
    exports.isEnumNumberMember = isEnumNumberMember;
    exports.isEnumStringBody = isEnumStringBody;
    exports.isEnumStringMember = isEnumStringMember;
    exports.isEnumSymbolBody = isEnumSymbolBody;
    exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
    exports.isExportAllDeclaration = isExportAllDeclaration;
    exports.isExportDeclaration = isExportDeclaration;
    exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
    exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
    exports.isExportNamedDeclaration = isExportNamedDeclaration;
    exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
    exports.isExportSpecifier = isExportSpecifier;
    exports.isExpression = isExpression;
    exports.isExpressionStatement = isExpressionStatement;
    exports.isExpressionWrapper = isExpressionWrapper;
    exports.isFile = isFile;
    exports.isFlow = isFlow;
    exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
    exports.isFlowDeclaration = isFlowDeclaration;
    exports.isFlowPredicate = isFlowPredicate;
    exports.isFlowType = isFlowType;
    exports.isFor = isFor;
    exports.isForInStatement = isForInStatement;
    exports.isForOfStatement = isForOfStatement;
    exports.isForStatement = isForStatement;
    exports.isForXStatement = isForXStatement;
    exports.isFunction = isFunction;
    exports.isFunctionDeclaration = isFunctionDeclaration;
    exports.isFunctionExpression = isFunctionExpression;
    exports.isFunctionParent = isFunctionParent;
    exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
    exports.isFunctionTypeParam = isFunctionTypeParam;
    exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
    exports.isIdentifier = isIdentifier;
    exports.isIfStatement = isIfStatement;
    exports.isImmutable = isImmutable;
    exports.isImport = isImport;
    exports.isImportAttribute = isImportAttribute;
    exports.isImportDeclaration = isImportDeclaration;
    exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
    exports.isImportExpression = isImportExpression;
    exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
    exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
    exports.isImportSpecifier = isImportSpecifier;
    exports.isIndexedAccessType = isIndexedAccessType;
    exports.isInferredPredicate = isInferredPredicate;
    exports.isInterfaceDeclaration = isInterfaceDeclaration;
    exports.isInterfaceExtends = isInterfaceExtends;
    exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
    exports.isInterpreterDirective = isInterpreterDirective;
    exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
    exports.isJSX = isJSX;
    exports.isJSXAttribute = isJSXAttribute;
    exports.isJSXClosingElement = isJSXClosingElement;
    exports.isJSXClosingFragment = isJSXClosingFragment;
    exports.isJSXElement = isJSXElement;
    exports.isJSXEmptyExpression = isJSXEmptyExpression;
    exports.isJSXExpressionContainer = isJSXExpressionContainer;
    exports.isJSXFragment = isJSXFragment;
    exports.isJSXIdentifier = isJSXIdentifier;
    exports.isJSXMemberExpression = isJSXMemberExpression;
    exports.isJSXNamespacedName = isJSXNamespacedName;
    exports.isJSXOpeningElement = isJSXOpeningElement;
    exports.isJSXOpeningFragment = isJSXOpeningFragment;
    exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
    exports.isJSXSpreadChild = isJSXSpreadChild;
    exports.isJSXText = isJSXText;
    exports.isLVal = isLVal;
    exports.isLabeledStatement = isLabeledStatement;
    exports.isLiteral = isLiteral;
    exports.isLogicalExpression = isLogicalExpression;
    exports.isLoop = isLoop;
    exports.isMemberExpression = isMemberExpression;
    exports.isMetaProperty = isMetaProperty;
    exports.isMethod = isMethod;
    exports.isMiscellaneous = isMiscellaneous;
    exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
    exports.isModuleDeclaration = isModuleDeclaration;
    exports.isModuleExpression = isModuleExpression;
    exports.isModuleSpecifier = isModuleSpecifier;
    exports.isNewExpression = isNewExpression;
    exports.isNoop = isNoop;
    exports.isNullLiteral = isNullLiteral;
    exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
    exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
    exports.isNumberLiteral = isNumberLiteral;
    exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
    exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
    exports.isNumericLiteral = isNumericLiteral;
    exports.isObjectExpression = isObjectExpression;
    exports.isObjectMember = isObjectMember;
    exports.isObjectMethod = isObjectMethod;
    exports.isObjectPattern = isObjectPattern;
    exports.isObjectProperty = isObjectProperty;
    exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
    exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
    exports.isObjectTypeIndexer = isObjectTypeIndexer;
    exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
    exports.isObjectTypeProperty = isObjectTypeProperty;
    exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
    exports.isOpaqueType = isOpaqueType;
    exports.isOptionalCallExpression = isOptionalCallExpression;
    exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
    exports.isOptionalMemberExpression = isOptionalMemberExpression;
    exports.isParenthesizedExpression = isParenthesizedExpression;
    exports.isPattern = isPattern;
    exports.isPatternLike = isPatternLike;
    exports.isPipelineBareFunction = isPipelineBareFunction;
    exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
    exports.isPipelineTopicExpression = isPipelineTopicExpression;
    exports.isPlaceholder = isPlaceholder;
    exports.isPrivate = isPrivate;
    exports.isPrivateName = isPrivateName;
    exports.isProgram = isProgram;
    exports.isProperty = isProperty;
    exports.isPureish = isPureish;
    exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
    exports.isRecordExpression = isRecordExpression;
    exports.isRegExpLiteral = isRegExpLiteral;
    exports.isRegexLiteral = isRegexLiteral;
    exports.isRestElement = isRestElement;
    exports.isRestProperty = isRestProperty;
    exports.isReturnStatement = isReturnStatement;
    exports.isScopable = isScopable;
    exports.isSequenceExpression = isSequenceExpression;
    exports.isSpreadElement = isSpreadElement;
    exports.isSpreadProperty = isSpreadProperty;
    exports.isStandardized = isStandardized;
    exports.isStatement = isStatement;
    exports.isStaticBlock = isStaticBlock;
    exports.isStringLiteral = isStringLiteral;
    exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
    exports.isStringTypeAnnotation = isStringTypeAnnotation;
    exports.isSuper = isSuper;
    exports.isSwitchCase = isSwitchCase;
    exports.isSwitchStatement = isSwitchStatement;
    exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
    exports.isTSAnyKeyword = isTSAnyKeyword;
    exports.isTSArrayType = isTSArrayType;
    exports.isTSAsExpression = isTSAsExpression;
    exports.isTSBaseType = isTSBaseType;
    exports.isTSBigIntKeyword = isTSBigIntKeyword;
    exports.isTSBooleanKeyword = isTSBooleanKeyword;
    exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
    exports.isTSConditionalType = isTSConditionalType;
    exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
    exports.isTSConstructorType = isTSConstructorType;
    exports.isTSDeclareFunction = isTSDeclareFunction;
    exports.isTSDeclareMethod = isTSDeclareMethod;
    exports.isTSEntityName = isTSEntityName;
    exports.isTSEnumDeclaration = isTSEnumDeclaration;
    exports.isTSEnumMember = isTSEnumMember;
    exports.isTSExportAssignment = isTSExportAssignment;
    exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
    exports.isTSExternalModuleReference = isTSExternalModuleReference;
    exports.isTSFunctionType = isTSFunctionType;
    exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
    exports.isTSImportType = isTSImportType;
    exports.isTSIndexSignature = isTSIndexSignature;
    exports.isTSIndexedAccessType = isTSIndexedAccessType;
    exports.isTSInferType = isTSInferType;
    exports.isTSInstantiationExpression = isTSInstantiationExpression;
    exports.isTSInterfaceBody = isTSInterfaceBody;
    exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
    exports.isTSIntersectionType = isTSIntersectionType;
    exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
    exports.isTSLiteralType = isTSLiteralType;
    exports.isTSMappedType = isTSMappedType;
    exports.isTSMethodSignature = isTSMethodSignature;
    exports.isTSModuleBlock = isTSModuleBlock;
    exports.isTSModuleDeclaration = isTSModuleDeclaration;
    exports.isTSNamedTupleMember = isTSNamedTupleMember;
    exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
    exports.isTSNeverKeyword = isTSNeverKeyword;
    exports.isTSNonNullExpression = isTSNonNullExpression;
    exports.isTSNullKeyword = isTSNullKeyword;
    exports.isTSNumberKeyword = isTSNumberKeyword;
    exports.isTSObjectKeyword = isTSObjectKeyword;
    exports.isTSOptionalType = isTSOptionalType;
    exports.isTSParameterProperty = isTSParameterProperty;
    exports.isTSParenthesizedType = isTSParenthesizedType;
    exports.isTSPropertySignature = isTSPropertySignature;
    exports.isTSQualifiedName = isTSQualifiedName;
    exports.isTSRestType = isTSRestType;
    exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
    exports.isTSStringKeyword = isTSStringKeyword;
    exports.isTSSymbolKeyword = isTSSymbolKeyword;
    exports.isTSThisType = isTSThisType;
    exports.isTSTupleType = isTSTupleType;
    exports.isTSType = isTSType;
    exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
    exports.isTSTypeAnnotation = isTSTypeAnnotation;
    exports.isTSTypeAssertion = isTSTypeAssertion;
    exports.isTSTypeElement = isTSTypeElement;
    exports.isTSTypeLiteral = isTSTypeLiteral;
    exports.isTSTypeOperator = isTSTypeOperator;
    exports.isTSTypeParameter = isTSTypeParameter;
    exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
    exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
    exports.isTSTypePredicate = isTSTypePredicate;
    exports.isTSTypeQuery = isTSTypeQuery;
    exports.isTSTypeReference = isTSTypeReference;
    exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
    exports.isTSUnionType = isTSUnionType;
    exports.isTSUnknownKeyword = isTSUnknownKeyword;
    exports.isTSVoidKeyword = isTSVoidKeyword;
    exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
    exports.isTemplateElement = isTemplateElement;
    exports.isTemplateLiteral = isTemplateLiteral;
    exports.isTerminatorless = isTerminatorless;
    exports.isThisExpression = isThisExpression;
    exports.isThisTypeAnnotation = isThisTypeAnnotation;
    exports.isThrowStatement = isThrowStatement;
    exports.isTopicReference = isTopicReference;
    exports.isTryStatement = isTryStatement;
    exports.isTupleExpression = isTupleExpression;
    exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
    exports.isTypeAlias = isTypeAlias;
    exports.isTypeAnnotation = isTypeAnnotation;
    exports.isTypeCastExpression = isTypeCastExpression;
    exports.isTypeParameter = isTypeParameter;
    exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
    exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
    exports.isTypeScript = isTypeScript;
    exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
    exports.isUnaryExpression = isUnaryExpression;
    exports.isUnaryLike = isUnaryLike;
    exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
    exports.isUpdateExpression = isUpdateExpression;
    exports.isUserWhitespacable = isUserWhitespacable;
    exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
    exports.isVariableDeclaration = isVariableDeclaration;
    exports.isVariableDeclarator = isVariableDeclarator;
    exports.isVariance = isVariance;
    exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
    exports.isWhile = isWhile;
    exports.isWhileStatement = isWhileStatement;
    exports.isWithStatement = isWithStatement;
    exports.isYieldExpression = isYieldExpression;
    var _shallowEqual = require_shallowEqual();
    var _deprecationWarning = require_deprecationWarning();
    function isArrayExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ArrayExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAssignmentExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "AssignmentExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBinaryExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BinaryExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterpreterDirective(node, opts) {
      if (!node)
        return false;
      if (node.type !== "InterpreterDirective")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDirective(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Directive")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDirectiveLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DirectiveLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlockStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BlockStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBreakStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BreakStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCallExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "CallExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCatchClause(node, opts) {
      if (!node)
        return false;
      if (node.type !== "CatchClause")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isConditionalExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ConditionalExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isContinueStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ContinueStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDebuggerStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DebuggerStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDoWhileStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DoWhileStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEmptyStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EmptyStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpressionStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExpressionStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFile(node, opts) {
      if (!node)
        return false;
      if (node.type !== "File")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForInStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ForInStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ForStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "FunctionDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "FunctionExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIdentifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Identifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIfStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "IfStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLabeledStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "LabeledStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "StringLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumericLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NumericLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NullLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BooleanLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRegExpLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "RegExpLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLogicalExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "LogicalExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMemberExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "MemberExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNewExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NewExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isProgram(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Program")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectMethod(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRestElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "RestElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isReturnStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ReturnStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSequenceExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "SequenceExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isParenthesizedExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ParenthesizedExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSwitchCase(node, opts) {
      if (!node)
        return false;
      if (node.type !== "SwitchCase")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSwitchStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "SwitchStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThisExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ThisExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThrowStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ThrowStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTryStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TryStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnaryExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "UnaryExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUpdateExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "UpdateExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariableDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "VariableDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariableDeclarator(node, opts) {
      if (!node)
        return false;
      if (node.type !== "VariableDeclarator")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWhileStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "WhileStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWithStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "WithStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAssignmentPattern(node, opts) {
      if (!node)
        return false;
      if (node.type !== "AssignmentPattern")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrayPattern(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ArrayPattern")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrowFunctionExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ArrowFunctionExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportAllDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportAllDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDefaultDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportDefaultDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportNamedDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportNamedDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForOfStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ForOfStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ImportDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportDefaultSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ImportDefaultSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportNamespaceSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ImportNamespaceSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ImportSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ImportExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMetaProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "MetaProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassMethod(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectPattern(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectPattern")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSpreadElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "SpreadElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSuper(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Super")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTaggedTemplateExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TaggedTemplateExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTemplateElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TemplateElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTemplateLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TemplateLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isYieldExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "YieldExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAwaitExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "AwaitExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImport(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Import")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBigIntLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BigIntLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportNamespaceSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportNamespaceSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalMemberExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "OptionalMemberExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalCallExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "OptionalCallExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassAccessorProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassAccessorProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassPrivateProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassPrivateProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassPrivateMethod(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassPrivateMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPrivateName(node, opts) {
      if (!node)
        return false;
      if (node.type !== "PrivateName")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStaticBlock(node, opts) {
      if (!node)
        return false;
      if (node.type !== "StaticBlock")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAnyTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "AnyTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrayTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ArrayTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BooleanTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BooleanLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NullLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassImplements(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassImplements")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareClass(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareClass")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareFunction(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareFunction")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareInterface(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareInterface")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareModule(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareModule")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareModuleExports(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareModuleExports")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareTypeAlias(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareTypeAlias")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareOpaqueType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareOpaqueType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareVariable(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareVariable")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareExportDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareExportDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareExportAllDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareExportAllDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclaredPredicate(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclaredPredicate")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExistsTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExistsTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "FunctionTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionTypeParam(node, opts) {
      if (!node)
        return false;
      if (node.type !== "FunctionTypeParam")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isGenericTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "GenericTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInferredPredicate(node, opts) {
      if (!node)
        return false;
      if (node.type !== "InferredPredicate")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceExtends(node, opts) {
      if (!node)
        return false;
      if (node.type !== "InterfaceExtends")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "InterfaceDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "InterfaceTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIntersectionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "IntersectionTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMixedTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "MixedTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEmptyTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EmptyTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullableTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NullableTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NumberLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NumberTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeInternalSlot(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeInternalSlot")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeCallProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeCallProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeIndexer(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeIndexer")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeSpreadProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeSpreadProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOpaqueType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "OpaqueType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isQualifiedTypeIdentifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "QualifiedTypeIdentifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "StringLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "StringTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSymbolTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "SymbolTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThisTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ThisTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTupleTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TupleTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeofTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeofTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeAlias(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeAlias")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeCastExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeCastExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameter(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeParameter")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameterDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeParameterDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameterInstantiation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeParameterInstantiation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "UnionTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariance(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Variance")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVoidTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "VoidTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBooleanBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumBooleanBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumNumberBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumNumberBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumStringBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumStringBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumSymbolBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumSymbolBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBooleanMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumBooleanMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumNumberMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumNumberMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumStringMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumStringMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumDefaultedMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumDefaultedMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIndexedAccessType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "IndexedAccessType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalIndexedAccessType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "OptionalIndexedAccessType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXAttribute(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXAttribute")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXClosingElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXClosingElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXEmptyExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXEmptyExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXExpressionContainer(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXExpressionContainer")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXSpreadChild(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXSpreadChild")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXIdentifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXIdentifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXMemberExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXMemberExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXNamespacedName(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXNamespacedName")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXOpeningElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXOpeningElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXSpreadAttribute(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXSpreadAttribute")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXText(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXText")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXFragment(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXFragment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXOpeningFragment(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXOpeningFragment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXClosingFragment(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXClosingFragment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNoop(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Noop")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPlaceholder(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Placeholder")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isV8IntrinsicIdentifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "V8IntrinsicIdentifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArgumentPlaceholder(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ArgumentPlaceholder")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBindExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BindExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportAttribute(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ImportAttribute")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDecorator(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Decorator")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDoExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DoExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDefaultSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportDefaultSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRecordExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "RecordExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTupleExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TupleExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDecimalLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DecimalLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ModuleExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTopicReference(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TopicReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelineTopicExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "PipelineTopicExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelineBareFunction(node, opts) {
      if (!node)
        return false;
      if (node.type !== "PipelineBareFunction")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelinePrimaryTopicReference(node, opts) {
      if (!node)
        return false;
      if (node.type !== "PipelinePrimaryTopicReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSParameterProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSParameterProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSDeclareFunction(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSDeclareFunction")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSDeclareMethod(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSDeclareMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSQualifiedName(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSQualifiedName")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSCallSignatureDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSCallSignatureDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConstructSignatureDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSConstructSignatureDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSPropertySignature(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSPropertySignature")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSMethodSignature(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSMethodSignature")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIndexSignature(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSIndexSignature")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSAnyKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSAnyKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBooleanKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSBooleanKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBigIntKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSBigIntKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIntrinsicKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSIntrinsicKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNeverKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNeverKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNullKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNullKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNumberKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNumberKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSObjectKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSObjectKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSStringKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSStringKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSSymbolKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSSymbolKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUndefinedKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSUndefinedKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUnknownKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSUnknownKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSVoidKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSVoidKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSThisType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSThisType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSFunctionType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSFunctionType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConstructorType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSConstructorType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeReference(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypePredicate(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypePredicate")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeQuery(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeQuery")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSArrayType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSArrayType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTupleType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTupleType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSOptionalType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSOptionalType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSRestType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSRestType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNamedTupleMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNamedTupleMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUnionType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSUnionType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIntersectionType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSIntersectionType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConditionalType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSConditionalType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInferType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSInferType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSParenthesizedType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSParenthesizedType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeOperator(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeOperator")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIndexedAccessType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSIndexedAccessType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSMappedType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSMappedType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSLiteralType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSLiteralType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExpressionWithTypeArguments(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSExpressionWithTypeArguments")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInterfaceDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSInterfaceDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInterfaceBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSInterfaceBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAliasDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeAliasDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInstantiationExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSInstantiationExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSAsExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSAsExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSSatisfiesExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSSatisfiesExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAssertion(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeAssertion")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSEnumDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSEnumMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSModuleDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSModuleDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSModuleBlock(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSModuleBlock")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSImportType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSImportType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSImportEqualsDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSImportEqualsDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExternalModuleReference(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSExternalModuleReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNonNullExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNonNullExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExportAssignment(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSExportAssignment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNamespaceExportDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNamespaceExportDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameterInstantiation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeParameterInstantiation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameterDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeParameterDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameter(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeParameter")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStandardized(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "InterpreterDirective":
        case "Directive":
        case "DirectiveLiteral":
        case "BlockStatement":
        case "BreakStatement":
        case "CallExpression":
        case "CatchClause":
        case "ConditionalExpression":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "File":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Identifier":
        case "IfStatement":
        case "LabeledStatement":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "Program":
        case "ObjectExpression":
        case "ObjectMethod":
        case "ObjectProperty":
        case "RestElement":
        case "ReturnStatement":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "SwitchCase":
        case "SwitchStatement":
        case "ThisExpression":
        case "ThrowStatement":
        case "TryStatement":
        case "UnaryExpression":
        case "UpdateExpression":
        case "VariableDeclaration":
        case "VariableDeclarator":
        case "WhileStatement":
        case "WithStatement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ArrowFunctionExpression":
        case "ClassBody":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportSpecifier":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ImportExpression":
        case "MetaProperty":
        case "ClassMethod":
        case "ObjectPattern":
        case "SpreadElement":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "ExportNamespaceSpecifier":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
        case "StaticBlock":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Identifier":
            case "StringLiteral":
            case "BlockStatement":
            case "ClassBody":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpression(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ImportExpression":
        case "MetaProperty":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "TypeCastExpression":
        case "JSXElement":
        case "JSXFragment":
        case "BindExpression":
        case "DoExpression":
        case "RecordExpression":
        case "TupleExpression":
        case "DecimalLiteral":
        case "ModuleExpression":
        case "TopicReference":
        case "PipelineTopicExpression":
        case "PipelineBareFunction":
        case "PipelinePrimaryTopicReference":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Expression":
            case "Identifier":
            case "StringLiteral":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBinary(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BinaryExpression":
        case "LogicalExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isScopable(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlockParent(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlock(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BlockStatement":
        case "Program":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStatement(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Statement":
            case "Declaration":
            case "BlockStatement":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTerminatorless(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "YieldExpression":
        case "AwaitExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCompletionStatement(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isConditional(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ConditionalExpression":
        case "IfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLoop(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWhile(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "DoWhileStatement":
        case "WhileStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpressionWrapper(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ExpressionStatement":
        case "ParenthesizedExpression":
        case "TypeCastExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFor(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ForInStatement":
        case "ForStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForXStatement(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ForInStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunction(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionParent(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPureish(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "ArrowFunctionExpression":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclaration(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "VariableDeclaration":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
          break;
        case "Placeholder":
          if (node.expectedNode === "Declaration")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPatternLike(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "Identifier":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLVal(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSParameterProperty":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEntityName(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "Identifier":
        case "TSQualifiedName":
          break;
        case "Placeholder":
          if (node.expectedNode === "Identifier")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLiteral(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "TemplateLiteral":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImmutable(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "BigIntLiteral":
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXOpeningElement":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUserWhitespacable(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMethod(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectMember(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isProperty(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnaryLike(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "UnaryExpression":
        case "SpreadElement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPattern(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
          break;
        case "Placeholder":
          if (node.expectedNode === "Pattern")
            break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClass(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ClassExpression":
        case "ClassDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportOrExportDeclaration(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDeclaration(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleSpecifier(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ExportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAccessor(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ClassAccessorProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPrivate(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlow(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ClassImplements":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "DeclaredPredicate":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "FunctionTypeParam":
        case "GenericTypeAnnotation":
        case "InferredPredicate":
        case "InterfaceExtends":
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
        case "OpaqueType":
        case "QualifiedTypeIdentifier":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "TypeAlias":
        case "TypeAnnotation":
        case "TypeCastExpression":
        case "TypeParameter":
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
        case "UnionTypeAnnotation":
        case "Variance":
        case "VoidTypeAnnotation":
        case "EnumDeclaration":
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowType(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "GenericTypeAnnotation":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "UnionTypeAnnotation":
        case "VoidTypeAnnotation":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowBaseAnnotation(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "VoidTypeAnnotation":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowDeclaration(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowPredicate(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "DeclaredPredicate":
        case "InferredPredicate":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBody(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumMember(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSX(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXEmptyExpression":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXIdentifier":
        case "JSXMemberExpression":
        case "JSXNamespacedName":
        case "JSXOpeningElement":
        case "JSXSpreadAttribute":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMiscellaneous(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "Noop":
        case "Placeholder":
        case "V8IntrinsicIdentifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeScript(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "TSParameterProperty":
        case "TSDeclareFunction":
        case "TSDeclareMethod":
        case "TSQualifiedName":
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSNamedTupleMember":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSInterfaceDeclaration":
        case "TSInterfaceBody":
        case "TSTypeAliasDeclaration":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSEnumDeclaration":
        case "TSEnumMember":
        case "TSModuleDeclaration":
        case "TSModuleBlock":
        case "TSImportType":
        case "TSImportEqualsDeclaration":
        case "TSExternalModuleReference":
        case "TSNonNullExpression":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
        case "TSTypeAnnotation":
        case "TSTypeParameterInstantiation":
        case "TSTypeParameterDeclaration":
        case "TSTypeParameter":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeElement(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSType(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSImportType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBaseType(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSLiteralType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberLiteral(node, opts) {
      (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
      if (!node)
        return false;
      if (node.type !== "NumberLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRegexLiteral(node, opts) {
      (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
      if (!node)
        return false;
      if (node.type !== "RegexLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRestProperty(node, opts) {
      (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
      if (!node)
        return false;
      if (node.type !== "RestProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSpreadProperty(node, opts) {
      (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
      if (!node)
        return false;
      if (node.type !== "SpreadProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleDeclaration(node, opts) {
      (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
      return isImportOrExportDeclaration(node, opts);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/matchesPattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = matchesPattern;
    var _index = require_generated();
    function matchesPattern(member, match3, allowPartial) {
      if (!(0, _index.isMemberExpression)(member))
        return false;
      const parts = Array.isArray(match3) ? match3 : match3.split(".");
      const nodes = [];
      let node;
      for (node = member; (0, _index.isMemberExpression)(node); node = node.object) {
        nodes.push(node.property);
      }
      nodes.push(node);
      if (nodes.length < parts.length)
        return false;
      if (!allowPartial && nodes.length > parts.length)
        return false;
      for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
        const node2 = nodes[j];
        let value2;
        if ((0, _index.isIdentifier)(node2)) {
          value2 = node2.name;
        } else if ((0, _index.isStringLiteral)(node2)) {
          value2 = node2.value;
        } else if ((0, _index.isThisExpression)(node2)) {
          value2 = "this";
        } else {
          return false;
        }
        if (parts[i] !== value2)
          return false;
      }
      return true;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildMatchMemberExpression;
    var _matchesPattern = require_matchesPattern();
    function buildMatchMemberExpression(match3, allowPartial) {
      const parts = match3.split(".");
      return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/react/isReactComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
    var _default = isReactComponent;
    exports.default = _default;
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/react/isCompatTag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isCompatTag;
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }
  }
});

// node_modules/.pnpm/to-fast-properties@2.0.0/node_modules/to-fast-properties/index.js
var require_to_fast_properties = __commonJS({
  "node_modules/.pnpm/to-fast-properties@2.0.0/node_modules/to-fast-properties/index.js"(exports, module) {
    "use strict";
    var fastProto = null;
    function FastObject(o3) {
      if (fastProto !== null && typeof fastProto.property) {
        const result = fastProto;
        fastProto = FastObject.prototype = null;
        return result;
      }
      fastProto = FastObject.prototype = o3 == null ? /* @__PURE__ */ Object.create(null) : o3;
      return new FastObject();
    }
    FastObject();
    module.exports = function toFastproperties(o3) {
      return FastObject(o3);
    };
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isType;
    var _index = require_definitions();
    function isType(nodeType, targetType) {
      if (nodeType === targetType)
        return true;
      if (nodeType == null)
        return false;
      if (_index.ALIAS_KEYS[targetType])
        return false;
      const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
      if (aliases) {
        if (aliases[0] === nodeType)
          return true;
        for (const alias of aliases) {
          if (nodeType === alias)
            return true;
        }
      }
      return false;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isPlaceholderType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPlaceholderType;
    var _index = require_definitions();
    function isPlaceholderType(placeholderType, targetType) {
      if (placeholderType === targetType)
        return true;
      const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
      if (aliases) {
        for (const alias of aliases) {
          if (targetType === alias)
            return true;
        }
      }
      return false;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = is3;
    var _shallowEqual = require_shallowEqual();
    var _isType = require_isType();
    var _isPlaceholderType = require_isPlaceholderType();
    var _index = require_definitions();
    function is3(type3, node, opts) {
      if (!node)
        return false;
      const matches = (0, _isType.default)(node.type, type3);
      if (!matches) {
        if (!opts && node.type === "Placeholder" && type3 in _index.FLIPPED_ALIAS_KEYS) {
          return (0, _isPlaceholderType.default)(node.expectedNode, type3);
        }
        return false;
      }
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isValidIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValidIdentifier;
    var _helperValidatorIdentifier = require_lib();
    function isValidIdentifier(name, reserved = true) {
      if (typeof name !== "string")
        return false;
      if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
          return false;
        }
      }
      return (0, _helperValidatorIdentifier.isIdentifierName)(name);
    }
  }
});

// node_modules/.pnpm/@babel+helper-string-parser@7.22.5/node_modules/@babel/helper-string-parser/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/.pnpm/@babel+helper-string-parser@7.22.5/node_modules/@babel/helper-string-parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.readCodePoint = readCodePoint;
    exports.readInt = readInt;
    exports.readStringContents = readStringContents;
    var _isDigit = function isDigit(code) {
      return code >= 48 && code <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type3, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length: length4
      } = input;
      for (; ; ) {
        if (pos >= length4) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type3, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type3 === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type3 === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type3, ch, input, pos) {
      if (type3 === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type3 === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code;
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCharCode(code));
        }
        case 117: {
          let code;
          ({
            code,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCodePoint(code));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match3 = input.slice(startPos, pos + 2).match(/^[0-7]+/);
            let octalStr = match3[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code = input.charCodeAt(pos);
        let val;
        if (code === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code;
      if (ch === 123) {
        ++pos;
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code !== null && code > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code,
        pos
      };
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/constants/index.js
var require_constants = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
    var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
    var FLATTENABLE_KEYS = ["body", "expressions"];
    exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
    var FOR_INIT_KEYS = ["left", "init"];
    exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
    var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
    exports.COMMENT_KEYS = COMMENT_KEYS;
    var LOGICAL_OPERATORS = ["||", "&&", "??"];
    exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
    var UPDATE_OPERATORS = ["++", "--"];
    exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
    var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
    exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
    var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
    exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
    var COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
    exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
    var BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
    exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
    var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
    exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
    var BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
    exports.BINARY_OPERATORS = BINARY_OPERATORS;
    var ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
    exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
    var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
    exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
    var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
    exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
    var STRING_UNARY_OPERATORS = ["typeof"];
    exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
    var UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
    exports.UNARY_OPERATORS = UNARY_OPERATORS;
    var INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    exports.INHERIT_KEYS = INHERIT_KEYS;
    var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
    var NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
    exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
    exports.arrayOf = arrayOf;
    exports.arrayOfType = arrayOfType;
    exports.assertEach = assertEach;
    exports.assertNodeOrValueType = assertNodeOrValueType;
    exports.assertNodeType = assertNodeType;
    exports.assertOneOf = assertOneOf;
    exports.assertOptionalChainStart = assertOptionalChainStart;
    exports.assertShape = assertShape;
    exports.assertValueType = assertValueType;
    exports.chain = chain3;
    exports.default = defineType;
    exports.defineAliasedType = defineAliasedType;
    exports.typeIs = typeIs;
    exports.validate = validate;
    exports.validateArrayOfType = validateArrayOfType;
    exports.validateOptional = validateOptional;
    exports.validateOptionalType = validateOptionalType;
    exports.validateType = validateType;
    var _is = require_is();
    var _validate = require_validate2();
    var VISITOR_KEYS = {};
    exports.VISITOR_KEYS = VISITOR_KEYS;
    var ALIAS_KEYS = {};
    exports.ALIAS_KEYS = ALIAS_KEYS;
    var FLIPPED_ALIAS_KEYS = {};
    exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
    var NODE_FIELDS = {};
    exports.NODE_FIELDS = NODE_FIELDS;
    var BUILDER_KEYS = {};
    exports.BUILDER_KEYS = BUILDER_KEYS;
    var DEPRECATED_KEYS = {};
    exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
    var NODE_PARENT_VALIDATIONS = {};
    exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else {
        return typeof val;
      }
    }
    function validate(validate2) {
      return {
        validate: validate2
      };
    }
    function typeIs(typeName) {
      return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
    }
    function validateType(typeName) {
      return validate(typeIs(typeName));
    }
    function validateOptional(validate2) {
      return {
        validate: validate2,
        optional: true
      };
    }
    function validateOptionalType(typeName) {
      return {
        validate: typeIs(typeName),
        optional: true
      };
    }
    function arrayOf(elementType) {
      return chain3(assertValueType("array"), assertEach(elementType));
    }
    function arrayOfType(typeName) {
      return arrayOf(typeIs(typeName));
    }
    function validateArrayOfType(typeName) {
      return validate(arrayOfType(typeName));
    }
    function assertEach(callback) {
      function validator(node, key, val) {
        if (!Array.isArray(val))
          return;
        for (let i = 0; i < val.length; i++) {
          const subkey = `${key}[${i}]`;
          const v = val[i];
          callback(node, subkey, v);
          if (process.env.BABEL_TYPES_8_BREAKING)
            (0, _validate.validateChild)(node, subkey, v);
        }
      }
      validator.each = callback;
      return validator;
    }
    function assertOneOf(...values3) {
      function validate2(node, key, val) {
        if (values3.indexOf(val) < 0) {
          throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values3)} but got ${JSON.stringify(val)}`);
        }
      }
      validate2.oneOf = values3;
      return validate2;
    }
    function assertNodeType(...types) {
      function validate2(node, key, val) {
        for (const type3 of types) {
          if ((0, _is.default)(type3, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeTypes = types;
      return validate2;
    }
    function assertNodeOrValueType(...types) {
      function validate2(node, key, val) {
        for (const type3 of types) {
          if (getType(val) === type3 || (0, _is.default)(type3, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeOrValueTypes = types;
      return validate2;
    }
    function assertValueType(type3) {
      function validate2(node, key, val) {
        const valid = getType(val) === type3;
        if (!valid) {
          throw new TypeError(`Property ${key} expected type of ${type3} but got ${getType(val)}`);
        }
      }
      validate2.type = type3;
      return validate2;
    }
    function assertShape(shape) {
      function validate2(node, key, val) {
        const errors = [];
        for (const property of Object.keys(shape)) {
          try {
            (0, _validate.validateField)(node, property, val[property], shape[property]);
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }
            throw error;
          }
        }
        if (errors.length) {
          throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join("\n")}`);
        }
      }
      validate2.shapeOf = shape;
      return validate2;
    }
    function assertOptionalChainStart() {
      function validate2(node) {
        var _current;
        let current = node;
        while (node) {
          const {
            type: type3
          } = current;
          if (type3 === "OptionalCallExpression") {
            if (current.optional)
              return;
            current = current.callee;
            continue;
          }
          if (type3 === "OptionalMemberExpression") {
            if (current.optional)
              return;
            current = current.object;
            continue;
          }
          break;
        }
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
      }
      return validate2;
    }
    function chain3(...fns) {
      function validate2(...args) {
        for (const fn of fns) {
          fn(...args);
        }
      }
      validate2.chainOf = fns;
      if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
        throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
      }
      return validate2;
    }
    var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
    var validFieldKeys = ["default", "optional", "deprecated", "validate"];
    var store = {};
    function defineAliasedType(...aliases) {
      return (type3, opts = {}) => {
        let defined = opts.aliases;
        if (!defined) {
          var _store$opts$inherits$, _defined;
          if (opts.inherits)
            defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
          (_defined = defined) != null ? _defined : defined = [];
          opts.aliases = defined;
        }
        const additional = aliases.filter((a) => !defined.includes(a));
        defined.unshift(...additional);
        defineType(type3, opts);
      };
    }
    function defineType(type3, opts = {}) {
      const inherits = opts.inherits && store[opts.inherits] || {};
      let fields = opts.fields;
      if (!fields) {
        fields = {};
        if (inherits.fields) {
          const keys4 = Object.getOwnPropertyNames(inherits.fields);
          for (const key of keys4) {
            const field = inherits.fields[key];
            const def = field.default;
            if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
              throw new Error("field defaults can only be primitives or empty arrays currently");
            }
            fields[key] = {
              default: Array.isArray(def) ? [] : def,
              optional: field.optional,
              deprecated: field.deprecated,
              validate: field.validate
            };
          }
        }
      }
      const visitor = opts.visitor || inherits.visitor || [];
      const aliases = opts.aliases || inherits.aliases || [];
      const builder = opts.builder || inherits.builder || opts.visitor || [];
      for (const k of Object.keys(opts)) {
        if (validTypeOpts.indexOf(k) === -1) {
          throw new Error(`Unknown type option "${k}" on ${type3}`);
        }
      }
      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type3;
      }
      for (const key of visitor.concat(builder)) {
        fields[key] = fields[key] || {};
      }
      for (const key of Object.keys(fields)) {
        const field = fields[key];
        if (field.default !== void 0 && builder.indexOf(key) === -1) {
          field.optional = true;
        }
        if (field.default === void 0) {
          field.default = null;
        } else if (!field.validate && field.default != null) {
          field.validate = assertValueType(getType(field.default));
        }
        for (const k of Object.keys(field)) {
          if (validFieldKeys.indexOf(k) === -1) {
            throw new Error(`Unknown field key "${k}" on ${type3}.${key}`);
          }
        }
      }
      VISITOR_KEYS[type3] = opts.visitor = visitor;
      BUILDER_KEYS[type3] = opts.builder = builder;
      NODE_FIELDS[type3] = opts.fields = fields;
      ALIAS_KEYS[type3] = opts.aliases = aliases;
      aliases.forEach((alias) => {
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type3);
      });
      if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type3] = opts.validate;
      }
      store[type3] = opts;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/core.js
var require_core5 = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
    var _is = require_is();
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib();
    var _helperStringParser = require_lib4();
    var _index = require_constants();
    var _utils = require_utils2();
    var defineType = (0, _utils.defineAliasedType)("Standardized");
    defineType("ArrayExpression", {
      fields: {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
          default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    defineType("AssignmentExpression", {
      fields: {
        operator: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertValueType)("string");
            }
            const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
            const pattern = (0, _utils.assertOneOf)("=");
            return function(node, key, val) {
              const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
              validator(node, key, val);
            };
          }()
        },
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"]
    });
    defineType("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
        },
        left: {
          validate: function() {
            const expression = (0, _utils.assertNodeType)("Expression");
            const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.operator === "in" ? inOp : expression;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "PrivateName"]
            });
            return validator;
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"]
    });
    defineType("InterpreterDirective", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("Directive", {
      visitor: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
      }
    });
    defineType("DirectiveLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    defineType("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("CallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
        },
        arguments: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertOneOf)(true, false),
          optional: true
        }
      } : {}, {
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      },
      aliases: ["Scopable", "BlockParent"]
    });
    defineType("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression", "Conditional"]
    });
    defineType("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("DebuggerStatement", {
      aliases: ["Statement"]
    });
    defineType("DoWhileStatement", {
      visitor: ["test", "body"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    defineType("EmptyStatement", {
      aliases: ["Statement"]
    });
    defineType("ExpressionStatement", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Statement", "ExpressionWrapper"]
    });
    defineType("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: {
          validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
          }, {
            each: {
              oneOfNodeTypes: ["CommentBlock", "CommentLine"]
            }
          }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
          optional: true
        },
        tokens: {
          validate: (0, _utils.assertEach)(Object.assign(() => {
          }, {
            type: "any"
          })),
          optional: true
        }
      }
    });
    defineType("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
          optional: true
        },
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        update: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    var functionCommon = () => ({
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
      },
      generator: {
        default: false
      },
      async: {
        default: false
      }
    });
    exports.functionCommon = functionCommon;
    var functionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
    var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    });
    exports.functionDeclarationCommon = functionDeclarationCommon;
    defineType("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "params", "body", "returnType", "typeParameters"],
      fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      }),
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
      validate: function() {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return () => {
          };
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    defineType("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    var patternLikeCommon = () => ({
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    });
    exports.patternLikeCommon = patternLikeCommon;
    defineType("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation", "decorators"],
      aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
      fields: Object.assign({}, patternLikeCommon(), {
        name: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!(0, _isValidIdentifier.default)(val, false)) {
              throw new TypeError(`"${val}" is not a valid identifier name`);
            }
          }, {
            type: "string"
          }))
        }
      }),
      validate(parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const match3 = /\.(\w+)$/.exec(key);
        if (!match3)
          return;
        const [, parentKey] = match3;
        const nonComp = {
          computed: false
        };
        if (parentKey === "property") {
          if ((0, _is.default)("MemberExpression", parent, nonComp))
            return;
          if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
            return;
        } else if (parentKey === "key") {
          if ((0, _is.default)("Property", parent, nonComp))
            return;
          if ((0, _is.default)("Method", parent, nonComp))
            return;
        } else if (parentKey === "exported") {
          if ((0, _is.default)("ExportSpecifier", parent))
            return;
        } else if (parentKey === "imported") {
          if ((0, _is.default)("ImportSpecifier", parent, {
            imported: node
          }))
            return;
        } else if (parentKey === "meta") {
          if ((0, _is.default)("MetaProperty", parent, {
            meta: node
          }))
            return;
        }
        if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
          throw new TypeError(`"${node.name}" is not a valid identifier`);
        }
      }
    });
    defineType("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("StringLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node, key, val) {
            if (1 / val < 0 || !Number.isFinite(val)) {
              const error = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${val}) instead.`);
              {
              }
            }
          }, {
            type: "number"
          }))
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("BooleanLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("boolean")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Pureish", "Literal"],
      fields: {
        pattern: {
          validate: (0, _utils.assertValueType)("string")
        },
        flags: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            const invalid = /[^gimsuy]/.exec(val);
            if (invalid) {
              throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
            }
          }, {
            type: "string"
          })),
          default: ""
        }
      }
    });
    defineType("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
        },
        left: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("MemberExpression", {
      builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal"],
      fields: Object.assign({
        object: {
          validate: (0, _utils.assertNodeType)("Expression", "Super")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
            return validator;
          }()
        },
        computed: {
          default: false
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertOneOf)(true, false),
          optional: true
        }
      } : {})
    });
    defineType("NewExpression", {
      inherits: "CallExpression"
    });
    defineType("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives", "sourceType", "interpreter"],
      fields: {
        sourceFile: {
          validate: (0, _utils.assertValueType)("string")
        },
        sourceType: {
          validate: (0, _utils.assertOneOf)("script", "module"),
          default: "script"
        },
        interpreter: {
          validate: (0, _utils.assertNodeType)("InterpreterDirective"),
          default: null,
          optional: true
        },
        directives: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block"]
    });
    defineType("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
        }
      }
    });
    defineType("ObjectMethod", {
      builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        kind: Object.assign({
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          default: "method"
        } : {}),
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
            return validator;
          }()
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }),
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    });
    defineType("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
      fields: {
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
            });
            return validator;
          }()
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.computed) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            }
          }, {
            type: "boolean"
          }), function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !(0, _is.default)("Identifier", node.key)) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            }
          }),
          default: false
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      },
      visitor: ["key", "value", "decorators"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"],
      validate: function() {
        const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
          validator(node, "value", node.value);
        };
      }()
    });
    defineType("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      builder: ["argument"],
      aliases: ["LVal", "PatternLike"],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, patternLikeCommon(), {
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        }
      }),
      validate(parent, key) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const match3 = /(\w+)\[(\d+)\]/.exec(key);
        if (!match3)
          throw new Error("Internal Babel error: malformed key.");
        const [, listKey, index] = match3;
        if (parent[listKey].length > +index + 1) {
          throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
      }
    });
    defineType("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
        }
      },
      aliases: ["Expression"]
    });
    defineType("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        consequent: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      }
    });
    defineType("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
        }
      }
    });
    defineType("ThisExpression", {
      aliases: ["Expression"]
    });
    defineType("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        block: {
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!node.handler && !node.finalizer) {
              throw new TypeError("TryStatement expects either a handler or finalizer, or both");
            }
          }, {
            oneOfNodeTypes: ["BlockStatement"]
          }))
        },
        handler: {
          optional: true,
          validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
          optional: true,
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }
    });
    defineType("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: true
        },
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"]
    });
    defineType("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: false
        },
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["Expression"]
    });
    defineType("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        kind: {
          validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
        },
        declarations: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
        }
      },
      validate(parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        if (!(0, _is.default)("ForXStatement", parent, {
          left: node
        }))
          return;
        if (node.declarations.length !== 1) {
          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
        }
      }
    });
    defineType("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("LVal");
            }
            const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
            const without2 = (0, _utils.assertNodeType)("Identifier");
            return function(node, key, val) {
              const validator = node.init ? normal : without2;
              validator(node, key, val);
            };
          }()
        },
        definite: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("AssignmentPattern", {
      visitor: ["left", "right", "decorators"],
      builder: ["left", "right"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        left: {
          validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      })
    });
    defineType("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      builder: ["elements"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
        }
      })
    });
    defineType("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["params", "body", "returnType", "typeParameters"],
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        expression: {
          validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    defineType("ClassBody", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
        }
      }
    });
    defineType("ClassExpression", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
      aliases: ["Scopable", "Class", "Expression"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        }
      }
    });
    defineType("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: ["Scopable", "Class", "Statement", "Declaration"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      },
      validate: function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    defineType("ExportAllDeclaration", {
      builder: ["source"],
      visitor: ["source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
        attributes: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        }
      }
    });
    defineType("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
      }
    });
    defineType("ExportNamedDeclaration", {
      builder: ["declaration", "specifiers", "source"],
      visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.specifiers.length) {
              throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            }
          }, {
            oneOfNodeTypes: ["Declaration"]
          }), function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          })
        },
        attributes: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
          default: [],
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
            const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
            const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return sourced;
            return function(node, key, val) {
              const validator = node.source ? sourced : sourceless;
              validator(node, key, val);
            };
          }()))
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral"),
          optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }
    });
    defineType("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    defineType("ForOfStatement", {
      visitor: ["left", "right", "body"],
      builder: ["left", "right", "body", "await"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }
            const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
            const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
            return function(node, key, val) {
              if ((0, _is.default)("VariableDeclaration", val)) {
                declaration(node, key, val);
              } else {
                lval(node, key, val);
              }
            };
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
          default: false
        }
      }
    });
    defineType("ImportDeclaration", {
      builder: ["specifiers", "source"],
      visitor: ["specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
      fields: {
        attributes: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        module: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        specifiers: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportSpecifier", {
      visitor: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("ImportExpression", {
      visitor: ["source", "options"],
      aliases: ["Expression"],
      fields: {
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        source: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        options: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            let property;
            switch (val.name) {
              case "function":
                property = "sent";
                break;
              case "new":
                property = "target";
                break;
              case "import":
                property = "meta";
                break;
            }
            if (!(0, _is.default)("Identifier", node.property, {
              name: property
            })) {
              throw new TypeError("Unrecognised MetaProperty");
            }
          }, {
            oneOfNodeTypes: ["Identifier"]
          }))
        },
        property: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    var classMethodOrPropertyCommon = () => ({
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      static: {
        default: false
      },
      override: {
        default: false
      },
      computed: {
        default: false
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
      }
    });
    exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
    var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
      },
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
      },
      access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    });
    exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
    defineType("ClassMethod", {
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
      builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("ObjectPattern", {
      visitor: ["properties", "typeAnnotation", "decorators"],
      builder: ["properties"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
        }
      })
    });
    defineType("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      deprecatedAlias: "SpreadProperty",
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Super", {
      aliases: ["Expression"]
    });
    defineType("TaggedTemplateExpression", {
      visitor: ["tag", "quasi", "typeParameters"],
      builder: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
          validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertShape)({
            raw: {
              validate: (0, _utils.assertValueType)("string")
            },
            cooked: {
              validate: (0, _utils.assertValueType)("string"),
              optional: true
            }
          }), function templateElementCookedValidator(node) {
            const raw = node.value.raw;
            let unterminatedCalled = false;
            const error = () => {
              throw new Error("Internal @babel/types error.");
            };
            const {
              str,
              firstInvalidLoc
            } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
              unterminated() {
                unterminatedCalled = true;
              },
              strictNumericEscape: error,
              invalidEscapeSequence: error,
              numericSeparatorInEscapeSequence: error,
              unexpectedNumericSeparator: error,
              invalidDigit: error,
              invalidCodePoint: error
            });
            if (!unterminatedCalled)
              throw new Error("Invalid raw");
            node.value.cooked = firstInvalidLoc ? null : str;
          })
        },
        tail: {
          default: false
        }
      }
    });
    defineType("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
        },
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
            if (node.quasis.length !== val.length + 1) {
              throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
            }
          })
        }
      }
    });
    defineType("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !node.argument) {
              throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
            }
          }, {
            type: "boolean"
          })),
          default: false
        },
        argument: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Import", {
      aliases: ["Expression"]
    });
    defineType("BigIntLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("OptionalMemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier"]
            });
            return validator;
          }()
        },
        computed: {
          default: false
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        }
      }
    });
    defineType("OptionalCallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments", "optional"],
      aliases: ["Expression"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        },
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("ClassProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassAccessorProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property", "Accessor"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        key: {
          validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            return function(node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassPrivateProperty", {
      visitor: ["key", "value", "decorators", "typeAnnotation"],
      builder: ["key", "value", "decorators", "static"],
      aliases: ["Property", "Private"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        static: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      }
    });
    defineType("ClassPrivateMethod", {
      builder: ["kind", "key", "params", "body", "static"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method"),
          default: "method"
        },
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("PrivateName", {
      visitor: ["id"],
      aliases: ["Private"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("StaticBlock", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "FunctionParent"]
    });
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/flow.js"() {
    "use strict";
    var _utils = require_utils2();
    var defineType = (0, _utils.defineAliasedType)("Flow");
    var defineInterfaceishType = (name) => {
      const isDeclareClass = name === "DeclareClass";
      defineType(name, {
        builder: ["id", "typeParameters", "extends", "body"],
        visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: Object.assign({
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
        }, isDeclareClass ? {
          mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
        } : {}, {
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        })
      });
    };
    defineType("AnyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ArrayTypeAnnotation", {
      visitor: ["elementType"],
      aliases: ["FlowType"],
      fields: {
        elementType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("BooleanTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("BooleanLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("NullLiteralTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ClassImplements", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("DeclareClass");
    defineType("DeclareFunction", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
      }
    });
    defineInterfaceishType("DeclareInterface");
    defineType("DeclareModule", {
      builder: ["id", "body", "kind"],
      visitor: ["id", "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
      }
    });
    defineType("DeclareModuleExports", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("DeclareTypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("DeclareOpaqueType", {
      visitor: ["id", "typeParameters", "supertype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
      }
    });
    defineType("DeclareVariable", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("DeclareExportDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("DeclareExportAllDeclaration", {
      visitor: ["source"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }
    });
    defineType("DeclaredPredicate", {
      visitor: ["value"],
      aliases: ["FlowPredicate"],
      fields: {
        value: (0, _utils.validateType)("Flow")
      }
    });
    defineType("ExistsTypeAnnotation", {
      aliases: ["FlowType"]
    });
    defineType("FunctionTypeAnnotation", {
      visitor: ["typeParameters", "params", "rest", "returnType"],
      aliases: ["FlowType"],
      fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("FunctionTypeParam", {
      visitor: ["name", "typeAnnotation"],
      fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("GenericTypeAnnotation", {
      visitor: ["id", "typeParameters"],
      aliases: ["FlowType"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineType("InferredPredicate", {
      aliases: ["FlowPredicate"]
    });
    defineType("InterfaceExtends", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("InterfaceDeclaration");
    defineType("InterfaceTypeAnnotation", {
      visitor: ["extends", "body"],
      aliases: ["FlowType"],
      fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      }
    });
    defineType("IntersectionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("MixedTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EmptyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("NullableTypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowType"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("NumberLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
      }
    });
    defineType("NumberTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ObjectTypeAnnotation", {
      visitor: ["properties", "indexers", "callProperties", "internalSlots"],
      aliases: ["FlowType"],
      builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
      fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
        indexers: {
          validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
          optional: true,
          default: []
        },
        callProperties: {
          validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
          optional: true,
          default: []
        },
        internalSlots: {
          validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
          optional: true,
          default: []
        },
        exact: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeInternalSlot", {
      visitor: ["id", "value", "optional", "static", "method"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeCallProperty", {
      visitor: ["value"],
      aliases: ["UserWhitespacable"],
      fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeIndexer", {
      visitor: ["id", "key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("ObjectTypeProperty", {
      visitor: ["key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeSpreadProperty", {
      visitor: ["argument"],
      aliases: ["UserWhitespacable"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OpaqueType", {
      visitor: ["id", "typeParameters", "supertype", "impltype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("QualifiedTypeIdentifier", {
      visitor: ["id", "qualification"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
      }
    });
    defineType("StringLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
      }
    });
    defineType("StringTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("SymbolTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ThisTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("TupleTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("TypeofTypeAnnotation", {
      visitor: ["argument"],
      aliases: ["FlowType"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeCastExpression", {
      visitor: ["expression", "typeAnnotation"],
      aliases: ["ExpressionWrapper", "Expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("TypeParameter", {
      visitor: ["bound", "default", "variance"],
      fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("TypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
      }
    });
    defineType("TypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("UnionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("Variance", {
      builder: ["kind"],
      fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
      }
    });
    defineType("VoidTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
      }
    });
    defineType("EnumBooleanBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumNumberBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumStringBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumSymbolBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumBooleanMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
      }
    });
    defineType("EnumNumberMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
      }
    });
    defineType("EnumStringMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("EnumDefaultedMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("IndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OptionalIndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/jsx.js"() {
    "use strict";
    var _utils = require_utils2();
    var defineType = (0, _utils.defineAliasedType)("JSX");
    defineType("JSXAttribute", {
      visitor: ["name", "value"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    defineType("JSXClosingElement", {
      visitor: ["name"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
      }
    });
    defineType("JSXElement", {
      builder: ["openingElement", "closingElement", "children", "selfClosing"],
      visitor: ["openingElement", "children", "closingElement"],
      aliases: ["Immutable", "Expression"],
      fields: Object.assign({
        openingElement: {
          validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }, {
        selfClosing: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      })
    });
    defineType("JSXEmptyExpression", {});
    defineType("JSXExpressionContainer", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
      }
    });
    defineType("JSXSpreadChild", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXMemberExpression", {
      visitor: ["object", "property"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXNamespacedName", {
      visitor: ["namespace", "name"],
      fields: {
        namespace: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXOpeningElement", {
      builder: ["name", "attributes", "selfClosing"],
      visitor: ["name", "attributes"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
          default: false
        },
        attributes: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("JSXSpreadAttribute", {
      visitor: ["argument"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXText", {
      aliases: ["Immutable"],
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXFragment", {
      builder: ["openingFragment", "closingFragment", "children"],
      visitor: ["openingFragment", "children", "closingFragment"],
      aliases: ["Immutable", "Expression"],
      fields: {
        openingFragment: {
          validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
          validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }
    });
    defineType("JSXOpeningFragment", {
      aliases: ["Immutable"]
    });
    defineType("JSXClosingFragment", {
      aliases: ["Immutable"]
    });
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/placeholders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
    var _utils = require_utils2();
    var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
    exports.PLACEHOLDERS = PLACEHOLDERS;
    var PLACEHOLDERS_ALIAS = {
      Declaration: ["Statement"],
      Pattern: ["PatternLike", "LVal"]
    };
    exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
    for (const type3 of PLACEHOLDERS) {
      const alias = _utils.ALIAS_KEYS[type3];
      if (alias != null && alias.length)
        PLACEHOLDERS_ALIAS[type3] = alias;
    }
    var PLACEHOLDERS_FLIPPED_ALIAS = {};
    exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
    Object.keys(PLACEHOLDERS_ALIAS).forEach((type3) => {
      PLACEHOLDERS_ALIAS[type3].forEach((alias) => {
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
          PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        }
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type3);
      });
    });
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/misc.js"() {
    "use strict";
    var _utils = require_utils2();
    var _placeholders = require_placeholders();
    var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
    {
      defineType("Noop", {
        visitor: []
      });
    }
    defineType("Placeholder", {
      visitor: [],
      builder: ["expectedNode", "name"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
          validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
      }
    });
    defineType("V8IntrinsicIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/experimental.js"() {
    "use strict";
    var _utils = require_utils2();
    (0, _utils.default)("ArgumentPlaceholder", {});
    (0, _utils.default)("BindExpression", {
      visitor: ["object", "callee"],
      aliases: ["Expression"],
      fields: !process.env.BABEL_TYPES_8_BREAKING ? {
        object: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        },
        callee: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        }
      } : {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("ImportAttribute", {
      visitor: ["key", "value"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        }
      }
    });
    (0, _utils.default)("Decorator", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("DoExpression", {
      visitor: ["body"],
      builder: ["body", "async"],
      aliases: ["Expression"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        }
      }
    });
    (0, _utils.default)("ExportDefaultSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("RecordExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
        }
      }
    });
    (0, _utils.default)("TupleExpression", {
      fields: {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
          default: []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    (0, _utils.default)("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("ModuleExpression", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("Program")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("TopicReference", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineTopicExpression", {
      builder: ["expression"],
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineBareFunction", {
      builder: ["callee"],
      visitor: ["callee"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelinePrimaryTopicReference", {
      aliases: ["Expression"]
    });
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript2 = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/typescript.js"() {
    "use strict";
    var _utils = require_utils2();
    var _core = require_core5();
    var _is = require_is();
    var defineType = (0, _utils.defineAliasedType)("TypeScript");
    var bool = (0, _utils.assertValueType)("boolean");
    var tSFunctionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    defineType("TSParameterProperty", {
      aliases: ["LVal"],
      visitor: ["parameter"],
      fields: {
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        parameter: {
          validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      }
    });
    defineType("TSDeclareFunction", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSDeclareMethod", {
      visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSQualifiedName", {
      aliases: ["TSEntityName"],
      visitor: ["left", "right"],
      fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
      }
    });
    var signatureDeclarationCommon = () => ({
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      ["parameters"]: (0, _utils.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
      ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    });
    var callConstructSignatureDeclaration = {
      aliases: ["TSTypeElement"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"],
      fields: signatureDeclarationCommon()
    };
    defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    var namedTypeElementCommon = () => ({
      key: (0, _utils.validateType)("Expression"),
      computed: {
        default: false
      },
      optional: (0, _utils.validateOptional)(bool)
    });
    defineType("TSPropertySignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeAnnotation", "initializer"],
      fields: Object.assign({}, namedTypeElementCommon(), {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set")
        }
      })
    });
    defineType("TSMethodSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
      fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
      })
    });
    defineType("TSIndexSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["parameters", "typeAnnotation"],
      fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      }
    });
    var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
    for (const type3 of tsKeywordTypes) {
      defineType(type3, {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
    }
    defineType("TSThisType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
    var fnOrCtrBase = {
      aliases: ["TSType"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"]
    };
    defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
      fields: signatureDeclarationCommon()
    }));
    defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: (0, _utils.validateOptional)(bool)
      })
    }));
    defineType("TSTypeReference", {
      aliases: ["TSType"],
      visitor: ["typeName", "typeParameters"],
      fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypePredicate", {
      aliases: ["TSType"],
      visitor: ["parameterName", "typeAnnotation"],
      builder: ["parameterName", "typeAnnotation", "asserts"],
      fields: {
        parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
      }
    });
    defineType("TSTypeQuery", {
      aliases: ["TSType"],
      visitor: ["exprName", "typeParameters"],
      fields: {
        exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypeLiteral", {
      aliases: ["TSType"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSArrayType", {
      aliases: ["TSType"],
      visitor: ["elementType"],
      fields: {
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTupleType", {
      aliases: ["TSType"],
      visitor: ["elementTypes"],
      fields: {
        elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
      }
    });
    defineType("TSOptionalType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSRestType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSNamedTupleMember", {
      visitor: ["label", "elementType"],
      builder: ["label", "elementType", "optional"],
      fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
          validate: bool,
          default: false
        },
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    var unionOrIntersection = {
      aliases: ["TSType"],
      visitor: ["types"],
      fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
      }
    };
    defineType("TSUnionType", unionOrIntersection);
    defineType("TSIntersectionType", unionOrIntersection);
    defineType("TSConditionalType", {
      aliases: ["TSType"],
      visitor: ["checkType", "extendsType", "trueType", "falseType"],
      fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInferType", {
      aliases: ["TSType"],
      visitor: ["typeParameter"],
      fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }
    });
    defineType("TSParenthesizedType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTypeOperator", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSIndexedAccessType", {
      aliases: ["TSType"],
      visitor: ["objectType", "indexType"],
      fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSMappedType", {
      aliases: ["TSType"],
      visitor: ["typeParameter", "typeAnnotation", "nameType"],
      fields: {
        readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeParameter: (0, _utils.validateType)("TSTypeParameter"),
        optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
      }
    });
    defineType("TSLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["literal"],
      fields: {
        literal: {
          validate: function() {
            const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
            const unaryOperator = (0, _utils.assertOneOf)("-");
            const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
            function validator(parent, key, node) {
              if ((0, _is.default)("UnaryExpression", node)) {
                unaryOperator(node, "operator", node.operator);
                unaryExpression(node, "argument", node.argument);
              } else {
                literal(parent, key, node);
              }
            }
            validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
            return validator;
          }()
        }
      }
    });
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSInterfaceDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "extends", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
      }
    });
    defineType("TSInterfaceBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSTypeAliasDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "typeAnnotation"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInstantiationExpression", {
      aliases: ["Expression"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    var TSTypeExpression = {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression", "typeAnnotation"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    };
    defineType("TSAsExpression", TSTypeExpression);
    defineType("TSSatisfiesExpression", TSTypeExpression);
    defineType("TSTypeAssertion", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["typeAnnotation", "expression"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSEnumMember", {
      visitor: ["id", "initializer"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSModuleDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        global: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
      }
    });
    defineType("TSModuleBlock", {
      aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("TSImportType", {
      aliases: ["TSType"],
      visitor: ["argument", "qualifier", "typeParameters"],
      fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSImportEqualsDeclaration", {
      aliases: ["Statement"],
      visitor: ["id", "moduleReference"],
      fields: {
        isExport: (0, _utils.validate)(bool),
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]),
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    defineType("TSExternalModuleReference", {
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("TSNonNullExpression", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSExportAssignment", {
      aliases: ["Statement"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSNamespaceExportDeclaration", {
      aliases: ["Statement"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("TSTypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TSType")
        }
      }
    });
    defineType("TSTypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
        }
      }
    });
    defineType("TSTypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
        }
      }
    });
    defineType("TSTypeParameter", {
      builder: ["constraint", "default", "name"],
      visitor: ["constraint", "default"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        },
        in: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        out: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        const: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        constraint: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        },
        default: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        }
      }
    });
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/deprecated-aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DEPRECATED_ALIASES = void 0;
    var DEPRECATED_ALIASES = {
      ModuleDeclaration: "ImportOrExportDeclaration"
    };
    exports.DEPRECATED_ALIASES = DEPRECATED_ALIASES;
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/definitions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "BUILDER_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_ALIASES", {
      enumerable: true,
      get: function() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "NODE_FIELDS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports.TYPES = void 0;
    Object.defineProperty(exports, "VISITOR_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.VISITOR_KEYS;
      }
    });
    var _toFastProperties = require_to_fast_properties();
    require_core5();
    require_flow();
    require_jsx();
    require_misc();
    require_experimental();
    require_typescript2();
    var _utils = require_utils2();
    var _placeholders = require_placeholders();
    var _deprecatedAliases = require_deprecated_aliases();
    Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
      _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    });
    _toFastProperties(_utils.VISITOR_KEYS);
    _toFastProperties(_utils.ALIAS_KEYS);
    _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
    _toFastProperties(_utils.NODE_FIELDS);
    _toFastProperties(_utils.BUILDER_KEYS);
    _toFastProperties(_utils.DEPRECATED_KEYS);
    _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
    _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
    var TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
    exports.TYPES = TYPES;
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/validate.js
var require_validate2 = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = validate;
    exports.validateChild = validateChild;
    exports.validateField = validateField;
    var _index = require_definitions();
    function validate(node, key, val) {
      if (!node)
        return;
      const fields = _index.NODE_FIELDS[node.type];
      if (!fields)
        return;
      const field = fields[key];
      validateField(node, key, val, field);
      validateChild(node, key, val);
    }
    function validateField(node, key, val, field) {
      if (!(field != null && field.validate))
        return;
      if (field.optional && val == null)
        return;
      field.validate(node, key, val);
    }
    function validateChild(node, key, val) {
      if (val == null)
        return;
      const validate2 = _index.NODE_PARENT_VALIDATIONS[val.type];
      if (!validate2)
        return;
      validate2(node, key, val);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/validateNode.js
var require_validateNode = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/validateNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = validateNode;
    var _validate = require_validate2();
    var _index = require_lib5();
    function validateNode(node) {
      const keys4 = _index.BUILDER_KEYS[node.type];
      for (const key of keys4) {
        (0, _validate.default)(node, key, node[key]);
      }
      return node;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.anyTypeAnnotation = anyTypeAnnotation;
    exports.argumentPlaceholder = argumentPlaceholder;
    exports.arrayExpression = arrayExpression;
    exports.arrayPattern = arrayPattern;
    exports.arrayTypeAnnotation = arrayTypeAnnotation;
    exports.arrowFunctionExpression = arrowFunctionExpression;
    exports.assignmentExpression = assignmentExpression;
    exports.assignmentPattern = assignmentPattern;
    exports.awaitExpression = awaitExpression;
    exports.bigIntLiteral = bigIntLiteral;
    exports.binaryExpression = binaryExpression;
    exports.bindExpression = bindExpression;
    exports.blockStatement = blockStatement;
    exports.booleanLiteral = booleanLiteral;
    exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    exports.booleanTypeAnnotation = booleanTypeAnnotation;
    exports.breakStatement = breakStatement;
    exports.callExpression = callExpression;
    exports.catchClause = catchClause;
    exports.classAccessorProperty = classAccessorProperty;
    exports.classBody = classBody;
    exports.classDeclaration = classDeclaration;
    exports.classExpression = classExpression;
    exports.classImplements = classImplements;
    exports.classMethod = classMethod;
    exports.classPrivateMethod = classPrivateMethod;
    exports.classPrivateProperty = classPrivateProperty;
    exports.classProperty = classProperty;
    exports.conditionalExpression = conditionalExpression;
    exports.continueStatement = continueStatement;
    exports.debuggerStatement = debuggerStatement;
    exports.decimalLiteral = decimalLiteral;
    exports.declareClass = declareClass;
    exports.declareExportAllDeclaration = declareExportAllDeclaration;
    exports.declareExportDeclaration = declareExportDeclaration;
    exports.declareFunction = declareFunction;
    exports.declareInterface = declareInterface;
    exports.declareModule = declareModule;
    exports.declareModuleExports = declareModuleExports;
    exports.declareOpaqueType = declareOpaqueType;
    exports.declareTypeAlias = declareTypeAlias;
    exports.declareVariable = declareVariable;
    exports.declaredPredicate = declaredPredicate;
    exports.decorator = decorator;
    exports.directive = directive;
    exports.directiveLiteral = directiveLiteral;
    exports.doExpression = doExpression;
    exports.doWhileStatement = doWhileStatement;
    exports.emptyStatement = emptyStatement;
    exports.emptyTypeAnnotation = emptyTypeAnnotation;
    exports.enumBooleanBody = enumBooleanBody;
    exports.enumBooleanMember = enumBooleanMember;
    exports.enumDeclaration = enumDeclaration;
    exports.enumDefaultedMember = enumDefaultedMember;
    exports.enumNumberBody = enumNumberBody;
    exports.enumNumberMember = enumNumberMember;
    exports.enumStringBody = enumStringBody;
    exports.enumStringMember = enumStringMember;
    exports.enumSymbolBody = enumSymbolBody;
    exports.existsTypeAnnotation = existsTypeAnnotation;
    exports.exportAllDeclaration = exportAllDeclaration;
    exports.exportDefaultDeclaration = exportDefaultDeclaration;
    exports.exportDefaultSpecifier = exportDefaultSpecifier;
    exports.exportNamedDeclaration = exportNamedDeclaration;
    exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
    exports.exportSpecifier = exportSpecifier;
    exports.expressionStatement = expressionStatement;
    exports.file = file;
    exports.forInStatement = forInStatement;
    exports.forOfStatement = forOfStatement;
    exports.forStatement = forStatement;
    exports.functionDeclaration = functionDeclaration;
    exports.functionExpression = functionExpression;
    exports.functionTypeAnnotation = functionTypeAnnotation;
    exports.functionTypeParam = functionTypeParam;
    exports.genericTypeAnnotation = genericTypeAnnotation;
    exports.identifier = identifier;
    exports.ifStatement = ifStatement;
    exports.import = _import;
    exports.importAttribute = importAttribute;
    exports.importDeclaration = importDeclaration;
    exports.importDefaultSpecifier = importDefaultSpecifier;
    exports.importExpression = importExpression;
    exports.importNamespaceSpecifier = importNamespaceSpecifier;
    exports.importSpecifier = importSpecifier;
    exports.indexedAccessType = indexedAccessType;
    exports.inferredPredicate = inferredPredicate;
    exports.interfaceDeclaration = interfaceDeclaration;
    exports.interfaceExtends = interfaceExtends;
    exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
    exports.interpreterDirective = interpreterDirective;
    exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
    exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
    exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
    exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
    exports.jSXElement = exports.jsxElement = jsxElement;
    exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
    exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
    exports.jSXFragment = exports.jsxFragment = jsxFragment;
    exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
    exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
    exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
    exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
    exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
    exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
    exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
    exports.jSXText = exports.jsxText = jsxText;
    exports.labeledStatement = labeledStatement;
    exports.logicalExpression = logicalExpression;
    exports.memberExpression = memberExpression;
    exports.metaProperty = metaProperty;
    exports.mixedTypeAnnotation = mixedTypeAnnotation;
    exports.moduleExpression = moduleExpression;
    exports.newExpression = newExpression;
    exports.noop = noop3;
    exports.nullLiteral = nullLiteral;
    exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    exports.nullableTypeAnnotation = nullableTypeAnnotation;
    exports.numberLiteral = NumberLiteral;
    exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    exports.numberTypeAnnotation = numberTypeAnnotation;
    exports.numericLiteral = numericLiteral;
    exports.objectExpression = objectExpression;
    exports.objectMethod = objectMethod;
    exports.objectPattern = objectPattern;
    exports.objectProperty = objectProperty;
    exports.objectTypeAnnotation = objectTypeAnnotation;
    exports.objectTypeCallProperty = objectTypeCallProperty;
    exports.objectTypeIndexer = objectTypeIndexer;
    exports.objectTypeInternalSlot = objectTypeInternalSlot;
    exports.objectTypeProperty = objectTypeProperty;
    exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
    exports.opaqueType = opaqueType;
    exports.optionalCallExpression = optionalCallExpression;
    exports.optionalIndexedAccessType = optionalIndexedAccessType;
    exports.optionalMemberExpression = optionalMemberExpression;
    exports.parenthesizedExpression = parenthesizedExpression;
    exports.pipelineBareFunction = pipelineBareFunction;
    exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    exports.pipelineTopicExpression = pipelineTopicExpression;
    exports.placeholder = placeholder;
    exports.privateName = privateName;
    exports.program = program;
    exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    exports.recordExpression = recordExpression;
    exports.regExpLiteral = regExpLiteral;
    exports.regexLiteral = RegexLiteral;
    exports.restElement = restElement;
    exports.restProperty = RestProperty;
    exports.returnStatement = returnStatement;
    exports.sequenceExpression = sequenceExpression;
    exports.spreadElement = spreadElement;
    exports.spreadProperty = SpreadProperty;
    exports.staticBlock = staticBlock;
    exports.stringLiteral = stringLiteral;
    exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    exports.stringTypeAnnotation = stringTypeAnnotation;
    exports.super = _super;
    exports.switchCase = switchCase;
    exports.switchStatement = switchStatement;
    exports.symbolTypeAnnotation = symbolTypeAnnotation;
    exports.taggedTemplateExpression = taggedTemplateExpression;
    exports.templateElement = templateElement;
    exports.templateLiteral = templateLiteral;
    exports.thisExpression = thisExpression;
    exports.thisTypeAnnotation = thisTypeAnnotation;
    exports.throwStatement = throwStatement;
    exports.topicReference = topicReference;
    exports.tryStatement = tryStatement;
    exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
    exports.tSArrayType = exports.tsArrayType = tsArrayType;
    exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
    exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
    exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
    exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
    exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
    exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
    exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
    exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
    exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
    exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
    exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
    exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
    exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
    exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    exports.tSImportType = exports.tsImportType = tsImportType;
    exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
    exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
    exports.tSInferType = exports.tsInferType = tsInferType;
    exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
    exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
    exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
    exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
    exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
    exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
    exports.tSMappedType = exports.tsMappedType = tsMappedType;
    exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
    exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
    exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
    exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
    exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
    exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
    exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
    exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
    exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
    exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
    exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
    exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
    exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
    exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
    exports.tSRestType = exports.tsRestType = tsRestType;
    exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
    exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
    exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
    exports.tSThisType = exports.tsThisType = tsThisType;
    exports.tSTupleType = exports.tsTupleType = tsTupleType;
    exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
    exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
    exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
    exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
    exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
    exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
    exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
    exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
    exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
    exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
    exports.tSUnionType = exports.tsUnionType = tsUnionType;
    exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
    exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
    exports.tupleExpression = tupleExpression;
    exports.tupleTypeAnnotation = tupleTypeAnnotation;
    exports.typeAlias = typeAlias;
    exports.typeAnnotation = typeAnnotation;
    exports.typeCastExpression = typeCastExpression;
    exports.typeParameter = typeParameter;
    exports.typeParameterDeclaration = typeParameterDeclaration;
    exports.typeParameterInstantiation = typeParameterInstantiation;
    exports.typeofTypeAnnotation = typeofTypeAnnotation;
    exports.unaryExpression = unaryExpression;
    exports.unionTypeAnnotation = unionTypeAnnotation;
    exports.updateExpression = updateExpression;
    exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    exports.variableDeclaration = variableDeclaration;
    exports.variableDeclarator = variableDeclarator;
    exports.variance = variance;
    exports.voidTypeAnnotation = voidTypeAnnotation;
    exports.whileStatement = whileStatement;
    exports.withStatement = withStatement;
    exports.yieldExpression = yieldExpression;
    var _validateNode = require_validateNode();
    var _deprecationWarning = require_deprecationWarning();
    function arrayExpression(elements = []) {
      return (0, _validateNode.default)({
        type: "ArrayExpression",
        elements
      });
    }
    function assignmentExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "AssignmentExpression",
        operator,
        left,
        right
      });
    }
    function binaryExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "BinaryExpression",
        operator,
        left,
        right
      });
    }
    function interpreterDirective(value2) {
      return (0, _validateNode.default)({
        type: "InterpreterDirective",
        value: value2
      });
    }
    function directive(value2) {
      return (0, _validateNode.default)({
        type: "Directive",
        value: value2
      });
    }
    function directiveLiteral(value2) {
      return (0, _validateNode.default)({
        type: "DirectiveLiteral",
        value: value2
      });
    }
    function blockStatement(body, directives = []) {
      return (0, _validateNode.default)({
        type: "BlockStatement",
        body,
        directives
      });
    }
    function breakStatement(label = null) {
      return (0, _validateNode.default)({
        type: "BreakStatement",
        label
      });
    }
    function callExpression(callee, _arguments) {
      return (0, _validateNode.default)({
        type: "CallExpression",
        callee,
        arguments: _arguments
      });
    }
    function catchClause(param = null, body) {
      return (0, _validateNode.default)({
        type: "CatchClause",
        param,
        body
      });
    }
    function conditionalExpression(test3, consequent, alternate) {
      return (0, _validateNode.default)({
        type: "ConditionalExpression",
        test: test3,
        consequent,
        alternate
      });
    }
    function continueStatement(label = null) {
      return (0, _validateNode.default)({
        type: "ContinueStatement",
        label
      });
    }
    function debuggerStatement() {
      return {
        type: "DebuggerStatement"
      };
    }
    function doWhileStatement(test3, body) {
      return (0, _validateNode.default)({
        type: "DoWhileStatement",
        test: test3,
        body
      });
    }
    function emptyStatement() {
      return {
        type: "EmptyStatement"
      };
    }
    function expressionStatement(expression) {
      return (0, _validateNode.default)({
        type: "ExpressionStatement",
        expression
      });
    }
    function file(program2, comments = null, tokens = null) {
      return (0, _validateNode.default)({
        type: "File",
        program: program2,
        comments,
        tokens
      });
    }
    function forInStatement(left, right, body) {
      return (0, _validateNode.default)({
        type: "ForInStatement",
        left,
        right,
        body
      });
    }
    function forStatement(init2 = null, test3 = null, update3 = null, body) {
      return (0, _validateNode.default)({
        type: "ForStatement",
        init: init2,
        test: test3,
        update: update3,
        body
      });
    }
    function functionDeclaration(id = null, params, body, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "FunctionDeclaration",
        id,
        params,
        body,
        generator,
        async
      });
    }
    function functionExpression(id = null, params, body, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "FunctionExpression",
        id,
        params,
        body,
        generator,
        async
      });
    }
    function identifier(name) {
      return (0, _validateNode.default)({
        type: "Identifier",
        name
      });
    }
    function ifStatement(test3, consequent, alternate = null) {
      return (0, _validateNode.default)({
        type: "IfStatement",
        test: test3,
        consequent,
        alternate
      });
    }
    function labeledStatement(label, body) {
      return (0, _validateNode.default)({
        type: "LabeledStatement",
        label,
        body
      });
    }
    function stringLiteral(value2) {
      return (0, _validateNode.default)({
        type: "StringLiteral",
        value: value2
      });
    }
    function numericLiteral(value2) {
      return (0, _validateNode.default)({
        type: "NumericLiteral",
        value: value2
      });
    }
    function nullLiteral() {
      return {
        type: "NullLiteral"
      };
    }
    function booleanLiteral(value2) {
      return (0, _validateNode.default)({
        type: "BooleanLiteral",
        value: value2
      });
    }
    function regExpLiteral(pattern, flags = "") {
      return (0, _validateNode.default)({
        type: "RegExpLiteral",
        pattern,
        flags
      });
    }
    function logicalExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "LogicalExpression",
        operator,
        left,
        right
      });
    }
    function memberExpression(object, property, computed = false, optional = null) {
      return (0, _validateNode.default)({
        type: "MemberExpression",
        object,
        property,
        computed,
        optional
      });
    }
    function newExpression(callee, _arguments) {
      return (0, _validateNode.default)({
        type: "NewExpression",
        callee,
        arguments: _arguments
      });
    }
    function program(body, directives = [], sourceType = "script", interpreter = null) {
      return (0, _validateNode.default)({
        type: "Program",
        body,
        directives,
        sourceType,
        interpreter,
        sourceFile: null
      });
    }
    function objectExpression(properties) {
      return (0, _validateNode.default)({
        type: "ObjectExpression",
        properties
      });
    }
    function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async
      });
    }
    function objectProperty(key, value2, computed = false, shorthand = false, decorators = null) {
      return (0, _validateNode.default)({
        type: "ObjectProperty",
        key,
        value: value2,
        computed,
        shorthand,
        decorators
      });
    }
    function restElement(argument) {
      return (0, _validateNode.default)({
        type: "RestElement",
        argument
      });
    }
    function returnStatement(argument = null) {
      return (0, _validateNode.default)({
        type: "ReturnStatement",
        argument
      });
    }
    function sequenceExpression(expressions) {
      return (0, _validateNode.default)({
        type: "SequenceExpression",
        expressions
      });
    }
    function parenthesizedExpression(expression) {
      return (0, _validateNode.default)({
        type: "ParenthesizedExpression",
        expression
      });
    }
    function switchCase(test3 = null, consequent) {
      return (0, _validateNode.default)({
        type: "SwitchCase",
        test: test3,
        consequent
      });
    }
    function switchStatement(discriminant, cases) {
      return (0, _validateNode.default)({
        type: "SwitchStatement",
        discriminant,
        cases
      });
    }
    function thisExpression() {
      return {
        type: "ThisExpression"
      };
    }
    function throwStatement(argument) {
      return (0, _validateNode.default)({
        type: "ThrowStatement",
        argument
      });
    }
    function tryStatement(block, handler = null, finalizer = null) {
      return (0, _validateNode.default)({
        type: "TryStatement",
        block,
        handler,
        finalizer
      });
    }
    function unaryExpression(operator, argument, prefix = true) {
      return (0, _validateNode.default)({
        type: "UnaryExpression",
        operator,
        argument,
        prefix
      });
    }
    function updateExpression(operator, argument, prefix = false) {
      return (0, _validateNode.default)({
        type: "UpdateExpression",
        operator,
        argument,
        prefix
      });
    }
    function variableDeclaration(kind, declarations) {
      return (0, _validateNode.default)({
        type: "VariableDeclaration",
        kind,
        declarations
      });
    }
    function variableDeclarator(id, init2 = null) {
      return (0, _validateNode.default)({
        type: "VariableDeclarator",
        id,
        init: init2
      });
    }
    function whileStatement(test3, body) {
      return (0, _validateNode.default)({
        type: "WhileStatement",
        test: test3,
        body
      });
    }
    function withStatement(object, body) {
      return (0, _validateNode.default)({
        type: "WithStatement",
        object,
        body
      });
    }
    function assignmentPattern(left, right) {
      return (0, _validateNode.default)({
        type: "AssignmentPattern",
        left,
        right
      });
    }
    function arrayPattern(elements) {
      return (0, _validateNode.default)({
        type: "ArrayPattern",
        elements
      });
    }
    function arrowFunctionExpression(params, body, async = false) {
      return (0, _validateNode.default)({
        type: "ArrowFunctionExpression",
        params,
        body,
        async,
        expression: null
      });
    }
    function classBody(body) {
      return (0, _validateNode.default)({
        type: "ClassBody",
        body
      });
    }
    function classExpression(id = null, superClass = null, body, decorators = null) {
      return (0, _validateNode.default)({
        type: "ClassExpression",
        id,
        superClass,
        body,
        decorators
      });
    }
    function classDeclaration(id = null, superClass = null, body, decorators = null) {
      return (0, _validateNode.default)({
        type: "ClassDeclaration",
        id,
        superClass,
        body,
        decorators
      });
    }
    function exportAllDeclaration(source) {
      return (0, _validateNode.default)({
        type: "ExportAllDeclaration",
        source
      });
    }
    function exportDefaultDeclaration(declaration) {
      return (0, _validateNode.default)({
        type: "ExportDefaultDeclaration",
        declaration
      });
    }
    function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
      return (0, _validateNode.default)({
        type: "ExportNamedDeclaration",
        declaration,
        specifiers,
        source
      });
    }
    function exportSpecifier(local, exported) {
      return (0, _validateNode.default)({
        type: "ExportSpecifier",
        local,
        exported
      });
    }
    function forOfStatement(left, right, body, _await = false) {
      return (0, _validateNode.default)({
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
      });
    }
    function importDeclaration(specifiers, source) {
      return (0, _validateNode.default)({
        type: "ImportDeclaration",
        specifiers,
        source
      });
    }
    function importDefaultSpecifier(local) {
      return (0, _validateNode.default)({
        type: "ImportDefaultSpecifier",
        local
      });
    }
    function importNamespaceSpecifier(local) {
      return (0, _validateNode.default)({
        type: "ImportNamespaceSpecifier",
        local
      });
    }
    function importSpecifier(local, imported) {
      return (0, _validateNode.default)({
        type: "ImportSpecifier",
        local,
        imported
      });
    }
    function importExpression(source, options = null) {
      return (0, _validateNode.default)({
        type: "ImportExpression",
        source,
        options
      });
    }
    function metaProperty(meta, property) {
      return (0, _validateNode.default)({
        type: "MetaProperty",
        meta,
        property
      });
    }
    function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "ClassMethod",
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async
      });
    }
    function objectPattern(properties) {
      return (0, _validateNode.default)({
        type: "ObjectPattern",
        properties
      });
    }
    function spreadElement(argument) {
      return (0, _validateNode.default)({
        type: "SpreadElement",
        argument
      });
    }
    function _super() {
      return {
        type: "Super"
      };
    }
    function taggedTemplateExpression(tag, quasi) {
      return (0, _validateNode.default)({
        type: "TaggedTemplateExpression",
        tag,
        quasi
      });
    }
    function templateElement(value2, tail2 = false) {
      return (0, _validateNode.default)({
        type: "TemplateElement",
        value: value2,
        tail: tail2
      });
    }
    function templateLiteral(quasis, expressions) {
      return (0, _validateNode.default)({
        type: "TemplateLiteral",
        quasis,
        expressions
      });
    }
    function yieldExpression(argument = null, delegate = false) {
      return (0, _validateNode.default)({
        type: "YieldExpression",
        argument,
        delegate
      });
    }
    function awaitExpression(argument) {
      return (0, _validateNode.default)({
        type: "AwaitExpression",
        argument
      });
    }
    function _import() {
      return {
        type: "Import"
      };
    }
    function bigIntLiteral(value2) {
      return (0, _validateNode.default)({
        type: "BigIntLiteral",
        value: value2
      });
    }
    function exportNamespaceSpecifier(exported) {
      return (0, _validateNode.default)({
        type: "ExportNamespaceSpecifier",
        exported
      });
    }
    function optionalMemberExpression(object, property, computed = false, optional) {
      return (0, _validateNode.default)({
        type: "OptionalMemberExpression",
        object,
        property,
        computed,
        optional
      });
    }
    function optionalCallExpression(callee, _arguments, optional) {
      return (0, _validateNode.default)({
        type: "OptionalCallExpression",
        callee,
        arguments: _arguments,
        optional
      });
    }
    function classProperty(key, value2 = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassProperty",
        key,
        value: value2,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      });
    }
    function classAccessorProperty(key, value2 = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassAccessorProperty",
        key,
        value: value2,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      });
    }
    function classPrivateProperty(key, value2 = null, decorators = null, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassPrivateProperty",
        key,
        value: value2,
        decorators,
        static: _static
      });
    }
    function classPrivateMethod(kind = "method", key, params, body, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassPrivateMethod",
        kind,
        key,
        params,
        body,
        static: _static
      });
    }
    function privateName(id) {
      return (0, _validateNode.default)({
        type: "PrivateName",
        id
      });
    }
    function staticBlock(body) {
      return (0, _validateNode.default)({
        type: "StaticBlock",
        body
      });
    }
    function anyTypeAnnotation() {
      return {
        type: "AnyTypeAnnotation"
      };
    }
    function arrayTypeAnnotation(elementType) {
      return (0, _validateNode.default)({
        type: "ArrayTypeAnnotation",
        elementType
      });
    }
    function booleanTypeAnnotation() {
      return {
        type: "BooleanTypeAnnotation"
      };
    }
    function booleanLiteralTypeAnnotation(value2) {
      return (0, _validateNode.default)({
        type: "BooleanLiteralTypeAnnotation",
        value: value2
      });
    }
    function nullLiteralTypeAnnotation() {
      return {
        type: "NullLiteralTypeAnnotation"
      };
    }
    function classImplements(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "ClassImplements",
        id,
        typeParameters
      });
    }
    function declareClass(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "DeclareClass",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function declareFunction(id) {
      return (0, _validateNode.default)({
        type: "DeclareFunction",
        id
      });
    }
    function declareInterface(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "DeclareInterface",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function declareModule(id, body, kind = null) {
      return (0, _validateNode.default)({
        type: "DeclareModule",
        id,
        body,
        kind
      });
    }
    function declareModuleExports(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "DeclareModuleExports",
        typeAnnotation: typeAnnotation2
      });
    }
    function declareTypeAlias(id, typeParameters = null, right) {
      return (0, _validateNode.default)({
        type: "DeclareTypeAlias",
        id,
        typeParameters,
        right
      });
    }
    function declareOpaqueType(id, typeParameters = null, supertype = null) {
      return (0, _validateNode.default)({
        type: "DeclareOpaqueType",
        id,
        typeParameters,
        supertype
      });
    }
    function declareVariable(id) {
      return (0, _validateNode.default)({
        type: "DeclareVariable",
        id
      });
    }
    function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
      return (0, _validateNode.default)({
        type: "DeclareExportDeclaration",
        declaration,
        specifiers,
        source
      });
    }
    function declareExportAllDeclaration(source) {
      return (0, _validateNode.default)({
        type: "DeclareExportAllDeclaration",
        source
      });
    }
    function declaredPredicate(value2) {
      return (0, _validateNode.default)({
        type: "DeclaredPredicate",
        value: value2
      });
    }
    function existsTypeAnnotation() {
      return {
        type: "ExistsTypeAnnotation"
      };
    }
    function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
      return (0, _validateNode.default)({
        type: "FunctionTypeAnnotation",
        typeParameters,
        params,
        rest,
        returnType
      });
    }
    function functionTypeParam(name = null, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "FunctionTypeParam",
        name,
        typeAnnotation: typeAnnotation2
      });
    }
    function genericTypeAnnotation(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "GenericTypeAnnotation",
        id,
        typeParameters
      });
    }
    function inferredPredicate() {
      return {
        type: "InferredPredicate"
      };
    }
    function interfaceExtends(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "InterfaceExtends",
        id,
        typeParameters
      });
    }
    function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "InterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function interfaceTypeAnnotation(_extends = null, body) {
      return (0, _validateNode.default)({
        type: "InterfaceTypeAnnotation",
        extends: _extends,
        body
      });
    }
    function intersectionTypeAnnotation(types) {
      return (0, _validateNode.default)({
        type: "IntersectionTypeAnnotation",
        types
      });
    }
    function mixedTypeAnnotation() {
      return {
        type: "MixedTypeAnnotation"
      };
    }
    function emptyTypeAnnotation() {
      return {
        type: "EmptyTypeAnnotation"
      };
    }
    function nullableTypeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "NullableTypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function numberLiteralTypeAnnotation(value2) {
      return (0, _validateNode.default)({
        type: "NumberLiteralTypeAnnotation",
        value: value2
      });
    }
    function numberTypeAnnotation() {
      return {
        type: "NumberTypeAnnotation"
      };
    }
    function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
      return (0, _validateNode.default)({
        type: "ObjectTypeAnnotation",
        properties,
        indexers,
        callProperties,
        internalSlots,
        exact
      });
    }
    function objectTypeInternalSlot(id, value2, optional, _static, method2) {
      return (0, _validateNode.default)({
        type: "ObjectTypeInternalSlot",
        id,
        value: value2,
        optional,
        static: _static,
        method: method2
      });
    }
    function objectTypeCallProperty(value2) {
      return (0, _validateNode.default)({
        type: "ObjectTypeCallProperty",
        value: value2,
        static: null
      });
    }
    function objectTypeIndexer(id = null, key, value2, variance2 = null) {
      return (0, _validateNode.default)({
        type: "ObjectTypeIndexer",
        id,
        key,
        value: value2,
        variance: variance2,
        static: null
      });
    }
    function objectTypeProperty(key, value2, variance2 = null) {
      return (0, _validateNode.default)({
        type: "ObjectTypeProperty",
        key,
        value: value2,
        variance: variance2,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null
      });
    }
    function objectTypeSpreadProperty(argument) {
      return (0, _validateNode.default)({
        type: "ObjectTypeSpreadProperty",
        argument
      });
    }
    function opaqueType(id, typeParameters = null, supertype = null, impltype) {
      return (0, _validateNode.default)({
        type: "OpaqueType",
        id,
        typeParameters,
        supertype,
        impltype
      });
    }
    function qualifiedTypeIdentifier(id, qualification) {
      return (0, _validateNode.default)({
        type: "QualifiedTypeIdentifier",
        id,
        qualification
      });
    }
    function stringLiteralTypeAnnotation(value2) {
      return (0, _validateNode.default)({
        type: "StringLiteralTypeAnnotation",
        value: value2
      });
    }
    function stringTypeAnnotation() {
      return {
        type: "StringTypeAnnotation"
      };
    }
    function symbolTypeAnnotation() {
      return {
        type: "SymbolTypeAnnotation"
      };
    }
    function thisTypeAnnotation() {
      return {
        type: "ThisTypeAnnotation"
      };
    }
    function tupleTypeAnnotation(types) {
      return (0, _validateNode.default)({
        type: "TupleTypeAnnotation",
        types
      });
    }
    function typeofTypeAnnotation(argument) {
      return (0, _validateNode.default)({
        type: "TypeofTypeAnnotation",
        argument
      });
    }
    function typeAlias(id, typeParameters = null, right) {
      return (0, _validateNode.default)({
        type: "TypeAlias",
        id,
        typeParameters,
        right
      });
    }
    function typeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function typeCastExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TypeCastExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function typeParameter(bound = null, _default = null, variance2 = null) {
      return (0, _validateNode.default)({
        type: "TypeParameter",
        bound,
        default: _default,
        variance: variance2,
        name: null
      });
    }
    function typeParameterDeclaration(params) {
      return (0, _validateNode.default)({
        type: "TypeParameterDeclaration",
        params
      });
    }
    function typeParameterInstantiation(params) {
      return (0, _validateNode.default)({
        type: "TypeParameterInstantiation",
        params
      });
    }
    function unionTypeAnnotation(types) {
      return (0, _validateNode.default)({
        type: "UnionTypeAnnotation",
        types
      });
    }
    function variance(kind) {
      return (0, _validateNode.default)({
        type: "Variance",
        kind
      });
    }
    function voidTypeAnnotation() {
      return {
        type: "VoidTypeAnnotation"
      };
    }
    function enumDeclaration(id, body) {
      return (0, _validateNode.default)({
        type: "EnumDeclaration",
        id,
        body
      });
    }
    function enumBooleanBody(members) {
      return (0, _validateNode.default)({
        type: "EnumBooleanBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumNumberBody(members) {
      return (0, _validateNode.default)({
        type: "EnumNumberBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumStringBody(members) {
      return (0, _validateNode.default)({
        type: "EnumStringBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumSymbolBody(members) {
      return (0, _validateNode.default)({
        type: "EnumSymbolBody",
        members,
        hasUnknownMembers: null
      });
    }
    function enumBooleanMember(id) {
      return (0, _validateNode.default)({
        type: "EnumBooleanMember",
        id,
        init: null
      });
    }
    function enumNumberMember(id, init2) {
      return (0, _validateNode.default)({
        type: "EnumNumberMember",
        id,
        init: init2
      });
    }
    function enumStringMember(id, init2) {
      return (0, _validateNode.default)({
        type: "EnumStringMember",
        id,
        init: init2
      });
    }
    function enumDefaultedMember(id) {
      return (0, _validateNode.default)({
        type: "EnumDefaultedMember",
        id
      });
    }
    function indexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "IndexedAccessType",
        objectType,
        indexType
      });
    }
    function optionalIndexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "OptionalIndexedAccessType",
        objectType,
        indexType,
        optional: null
      });
    }
    function jsxAttribute(name, value2 = null) {
      return (0, _validateNode.default)({
        type: "JSXAttribute",
        name,
        value: value2
      });
    }
    function jsxClosingElement(name) {
      return (0, _validateNode.default)({
        type: "JSXClosingElement",
        name
      });
    }
    function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
      return (0, _validateNode.default)({
        type: "JSXElement",
        openingElement,
        closingElement,
        children,
        selfClosing
      });
    }
    function jsxEmptyExpression() {
      return {
        type: "JSXEmptyExpression"
      };
    }
    function jsxExpressionContainer(expression) {
      return (0, _validateNode.default)({
        type: "JSXExpressionContainer",
        expression
      });
    }
    function jsxSpreadChild(expression) {
      return (0, _validateNode.default)({
        type: "JSXSpreadChild",
        expression
      });
    }
    function jsxIdentifier(name) {
      return (0, _validateNode.default)({
        type: "JSXIdentifier",
        name
      });
    }
    function jsxMemberExpression(object, property) {
      return (0, _validateNode.default)({
        type: "JSXMemberExpression",
        object,
        property
      });
    }
    function jsxNamespacedName(namespace, name) {
      return (0, _validateNode.default)({
        type: "JSXNamespacedName",
        namespace,
        name
      });
    }
    function jsxOpeningElement(name, attributes, selfClosing = false) {
      return (0, _validateNode.default)({
        type: "JSXOpeningElement",
        name,
        attributes,
        selfClosing
      });
    }
    function jsxSpreadAttribute(argument) {
      return (0, _validateNode.default)({
        type: "JSXSpreadAttribute",
        argument
      });
    }
    function jsxText(value2) {
      return (0, _validateNode.default)({
        type: "JSXText",
        value: value2
      });
    }
    function jsxFragment(openingFragment, closingFragment, children) {
      return (0, _validateNode.default)({
        type: "JSXFragment",
        openingFragment,
        closingFragment,
        children
      });
    }
    function jsxOpeningFragment() {
      return {
        type: "JSXOpeningFragment"
      };
    }
    function jsxClosingFragment() {
      return {
        type: "JSXClosingFragment"
      };
    }
    function noop3() {
      return {
        type: "Noop"
      };
    }
    function placeholder(expectedNode, name) {
      return (0, _validateNode.default)({
        type: "Placeholder",
        expectedNode,
        name
      });
    }
    function v8IntrinsicIdentifier(name) {
      return (0, _validateNode.default)({
        type: "V8IntrinsicIdentifier",
        name
      });
    }
    function argumentPlaceholder() {
      return {
        type: "ArgumentPlaceholder"
      };
    }
    function bindExpression(object, callee) {
      return (0, _validateNode.default)({
        type: "BindExpression",
        object,
        callee
      });
    }
    function importAttribute(key, value2) {
      return (0, _validateNode.default)({
        type: "ImportAttribute",
        key,
        value: value2
      });
    }
    function decorator(expression) {
      return (0, _validateNode.default)({
        type: "Decorator",
        expression
      });
    }
    function doExpression(body, async = false) {
      return (0, _validateNode.default)({
        type: "DoExpression",
        body,
        async
      });
    }
    function exportDefaultSpecifier(exported) {
      return (0, _validateNode.default)({
        type: "ExportDefaultSpecifier",
        exported
      });
    }
    function recordExpression(properties) {
      return (0, _validateNode.default)({
        type: "RecordExpression",
        properties
      });
    }
    function tupleExpression(elements = []) {
      return (0, _validateNode.default)({
        type: "TupleExpression",
        elements
      });
    }
    function decimalLiteral(value2) {
      return (0, _validateNode.default)({
        type: "DecimalLiteral",
        value: value2
      });
    }
    function moduleExpression(body) {
      return (0, _validateNode.default)({
        type: "ModuleExpression",
        body
      });
    }
    function topicReference() {
      return {
        type: "TopicReference"
      };
    }
    function pipelineTopicExpression(expression) {
      return (0, _validateNode.default)({
        type: "PipelineTopicExpression",
        expression
      });
    }
    function pipelineBareFunction(callee) {
      return (0, _validateNode.default)({
        type: "PipelineBareFunction",
        callee
      });
    }
    function pipelinePrimaryTopicReference() {
      return {
        type: "PipelinePrimaryTopicReference"
      };
    }
    function tsParameterProperty(parameter) {
      return (0, _validateNode.default)({
        type: "TSParameterProperty",
        parameter
      });
    }
    function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
      return (0, _validateNode.default)({
        type: "TSDeclareFunction",
        id,
        typeParameters,
        params,
        returnType
      });
    }
    function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
      return (0, _validateNode.default)({
        type: "TSDeclareMethod",
        decorators,
        key,
        typeParameters,
        params,
        returnType
      });
    }
    function tsQualifiedName(left, right) {
      return (0, _validateNode.default)({
        type: "TSQualifiedName",
        left,
        right
      });
    }
    function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSCallSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSConstructSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsPropertySignature(key, typeAnnotation2 = null, initializer = null) {
      return (0, _validateNode.default)({
        type: "TSPropertySignature",
        key,
        typeAnnotation: typeAnnotation2,
        initializer,
        kind: null
      });
    }
    function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSMethodSignature",
        key,
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2,
        kind: null
      });
    }
    function tsIndexSignature(parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSIndexSignature",
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsAnyKeyword() {
      return {
        type: "TSAnyKeyword"
      };
    }
    function tsBooleanKeyword() {
      return {
        type: "TSBooleanKeyword"
      };
    }
    function tsBigIntKeyword() {
      return {
        type: "TSBigIntKeyword"
      };
    }
    function tsIntrinsicKeyword() {
      return {
        type: "TSIntrinsicKeyword"
      };
    }
    function tsNeverKeyword() {
      return {
        type: "TSNeverKeyword"
      };
    }
    function tsNullKeyword() {
      return {
        type: "TSNullKeyword"
      };
    }
    function tsNumberKeyword() {
      return {
        type: "TSNumberKeyword"
      };
    }
    function tsObjectKeyword() {
      return {
        type: "TSObjectKeyword"
      };
    }
    function tsStringKeyword() {
      return {
        type: "TSStringKeyword"
      };
    }
    function tsSymbolKeyword() {
      return {
        type: "TSSymbolKeyword"
      };
    }
    function tsUndefinedKeyword() {
      return {
        type: "TSUndefinedKeyword"
      };
    }
    function tsUnknownKeyword() {
      return {
        type: "TSUnknownKeyword"
      };
    }
    function tsVoidKeyword() {
      return {
        type: "TSVoidKeyword"
      };
    }
    function tsThisType() {
      return {
        type: "TSThisType"
      };
    }
    function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSFunctionType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSConstructorType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeReference(typeName, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSTypeReference",
        typeName,
        typeParameters
      });
    }
    function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
      return (0, _validateNode.default)({
        type: "TSTypePredicate",
        parameterName,
        typeAnnotation: typeAnnotation2,
        asserts
      });
    }
    function tsTypeQuery(exprName, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSTypeQuery",
        exprName,
        typeParameters
      });
    }
    function tsTypeLiteral(members) {
      return (0, _validateNode.default)({
        type: "TSTypeLiteral",
        members
      });
    }
    function tsArrayType(elementType) {
      return (0, _validateNode.default)({
        type: "TSArrayType",
        elementType
      });
    }
    function tsTupleType(elementTypes) {
      return (0, _validateNode.default)({
        type: "TSTupleType",
        elementTypes
      });
    }
    function tsOptionalType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSOptionalType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsRestType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSRestType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsNamedTupleMember(label, elementType, optional = false) {
      return (0, _validateNode.default)({
        type: "TSNamedTupleMember",
        label,
        elementType,
        optional
      });
    }
    function tsUnionType(types) {
      return (0, _validateNode.default)({
        type: "TSUnionType",
        types
      });
    }
    function tsIntersectionType(types) {
      return (0, _validateNode.default)({
        type: "TSIntersectionType",
        types
      });
    }
    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      return (0, _validateNode.default)({
        type: "TSConditionalType",
        checkType,
        extendsType,
        trueType,
        falseType
      });
    }
    function tsInferType(typeParameter2) {
      return (0, _validateNode.default)({
        type: "TSInferType",
        typeParameter: typeParameter2
      });
    }
    function tsParenthesizedType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSParenthesizedType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeOperator(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeOperator",
        typeAnnotation: typeAnnotation2,
        operator: null
      });
    }
    function tsIndexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "TSIndexedAccessType",
        objectType,
        indexType
      });
    }
    function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
      return (0, _validateNode.default)({
        type: "TSMappedType",
        typeParameter: typeParameter2,
        typeAnnotation: typeAnnotation2,
        nameType
      });
    }
    function tsLiteralType(literal) {
      return (0, _validateNode.default)({
        type: "TSLiteralType",
        literal
      });
    }
    function tsExpressionWithTypeArguments(expression, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSExpressionWithTypeArguments",
        expression,
        typeParameters
      });
    }
    function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "TSInterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function tsInterfaceBody(body) {
      return (0, _validateNode.default)({
        type: "TSInterfaceBody",
        body
      });
    }
    function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeAliasDeclaration",
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsInstantiationExpression(expression, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSInstantiationExpression",
        expression,
        typeParameters
      });
    }
    function tsAsExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSAsExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsSatisfiesExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSSatisfiesExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeAssertion(typeAnnotation2, expression) {
      return (0, _validateNode.default)({
        type: "TSTypeAssertion",
        typeAnnotation: typeAnnotation2,
        expression
      });
    }
    function tsEnumDeclaration(id, members) {
      return (0, _validateNode.default)({
        type: "TSEnumDeclaration",
        id,
        members
      });
    }
    function tsEnumMember(id, initializer = null) {
      return (0, _validateNode.default)({
        type: "TSEnumMember",
        id,
        initializer
      });
    }
    function tsModuleDeclaration(id, body) {
      return (0, _validateNode.default)({
        type: "TSModuleDeclaration",
        id,
        body
      });
    }
    function tsModuleBlock(body) {
      return (0, _validateNode.default)({
        type: "TSModuleBlock",
        body
      });
    }
    function tsImportType(argument, qualifier = null, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSImportType",
        argument,
        qualifier,
        typeParameters
      });
    }
    function tsImportEqualsDeclaration(id, moduleReference) {
      return (0, _validateNode.default)({
        type: "TSImportEqualsDeclaration",
        id,
        moduleReference,
        isExport: null
      });
    }
    function tsExternalModuleReference(expression) {
      return (0, _validateNode.default)({
        type: "TSExternalModuleReference",
        expression
      });
    }
    function tsNonNullExpression(expression) {
      return (0, _validateNode.default)({
        type: "TSNonNullExpression",
        expression
      });
    }
    function tsExportAssignment(expression) {
      return (0, _validateNode.default)({
        type: "TSExportAssignment",
        expression
      });
    }
    function tsNamespaceExportDeclaration(id) {
      return (0, _validateNode.default)({
        type: "TSNamespaceExportDeclaration",
        id
      });
    }
    function tsTypeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeParameterInstantiation(params) {
      return (0, _validateNode.default)({
        type: "TSTypeParameterInstantiation",
        params
      });
    }
    function tsTypeParameterDeclaration(params) {
      return (0, _validateNode.default)({
        type: "TSTypeParameterDeclaration",
        params
      });
    }
    function tsTypeParameter(constraint = null, _default = null, name) {
      return (0, _validateNode.default)({
        type: "TSTypeParameter",
        constraint,
        default: _default,
        name
      });
    }
    function NumberLiteral(value2) {
      (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
      return numericLiteral(value2);
    }
    function RegexLiteral(pattern, flags = "") {
      (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
      return regExpLiteral(pattern, flags);
    }
    function RestProperty(argument) {
      (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
      return restElement(argument);
    }
    function SpreadProperty(argument) {
      (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
      return spreadElement(argument);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cleanJSXElementLiteralChild;
    var _index = require_generated2();
    var _index2 = require_lib5();
    function cleanJSXElementLiteralChild(child, args) {
      const lines = child.value.split(/\r\n|\n|\r/);
      let lastNonEmptyLine = 0;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].match(/[^ \t]/)) {
          lastNonEmptyLine = i;
        }
      }
      let str = "";
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isFirstLine = i === 0;
        const isLastLine = i === lines.length - 1;
        const isLastNonEmptyLine = i === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        }
        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        }
        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }
          str += trimmedLine;
        }
      }
      if (str)
        args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/react/buildChildren.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildChildren;
    var _index = require_generated();
    var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
    function buildChildren(node) {
      const elements = [];
      for (let i = 0; i < node.children.length; i++) {
        let child = node.children[i];
        if ((0, _index.isJSXText)(child)) {
          (0, _cleanJSXElementLiteralChild.default)(child, elements);
          continue;
        }
        if ((0, _index.isJSXExpressionContainer)(child))
          child = child.expression;
        if ((0, _index.isJSXEmptyExpression)(child))
          continue;
        elements.push(child);
      }
      return elements;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNode;
    var _index = require_definitions();
    function isNode(node) {
      return !!(node && _index.VISITOR_KEYS[node.type]);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/asserts/assertNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = assertNode;
    var _isNode = require_isNode();
    function assertNode(node) {
      if (!(0, _isNode.default)(node)) {
        var _node$type;
        const type3 = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type3}"`);
      }
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/asserts/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assertAccessor = assertAccessor;
    exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
    exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
    exports.assertArrayExpression = assertArrayExpression;
    exports.assertArrayPattern = assertArrayPattern;
    exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
    exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
    exports.assertAssignmentExpression = assertAssignmentExpression;
    exports.assertAssignmentPattern = assertAssignmentPattern;
    exports.assertAwaitExpression = assertAwaitExpression;
    exports.assertBigIntLiteral = assertBigIntLiteral;
    exports.assertBinary = assertBinary;
    exports.assertBinaryExpression = assertBinaryExpression;
    exports.assertBindExpression = assertBindExpression;
    exports.assertBlock = assertBlock;
    exports.assertBlockParent = assertBlockParent;
    exports.assertBlockStatement = assertBlockStatement;
    exports.assertBooleanLiteral = assertBooleanLiteral;
    exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
    exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
    exports.assertBreakStatement = assertBreakStatement;
    exports.assertCallExpression = assertCallExpression;
    exports.assertCatchClause = assertCatchClause;
    exports.assertClass = assertClass;
    exports.assertClassAccessorProperty = assertClassAccessorProperty;
    exports.assertClassBody = assertClassBody;
    exports.assertClassDeclaration = assertClassDeclaration;
    exports.assertClassExpression = assertClassExpression;
    exports.assertClassImplements = assertClassImplements;
    exports.assertClassMethod = assertClassMethod;
    exports.assertClassPrivateMethod = assertClassPrivateMethod;
    exports.assertClassPrivateProperty = assertClassPrivateProperty;
    exports.assertClassProperty = assertClassProperty;
    exports.assertCompletionStatement = assertCompletionStatement;
    exports.assertConditional = assertConditional;
    exports.assertConditionalExpression = assertConditionalExpression;
    exports.assertContinueStatement = assertContinueStatement;
    exports.assertDebuggerStatement = assertDebuggerStatement;
    exports.assertDecimalLiteral = assertDecimalLiteral;
    exports.assertDeclaration = assertDeclaration;
    exports.assertDeclareClass = assertDeclareClass;
    exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
    exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
    exports.assertDeclareFunction = assertDeclareFunction;
    exports.assertDeclareInterface = assertDeclareInterface;
    exports.assertDeclareModule = assertDeclareModule;
    exports.assertDeclareModuleExports = assertDeclareModuleExports;
    exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
    exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
    exports.assertDeclareVariable = assertDeclareVariable;
    exports.assertDeclaredPredicate = assertDeclaredPredicate;
    exports.assertDecorator = assertDecorator;
    exports.assertDirective = assertDirective;
    exports.assertDirectiveLiteral = assertDirectiveLiteral;
    exports.assertDoExpression = assertDoExpression;
    exports.assertDoWhileStatement = assertDoWhileStatement;
    exports.assertEmptyStatement = assertEmptyStatement;
    exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
    exports.assertEnumBody = assertEnumBody;
    exports.assertEnumBooleanBody = assertEnumBooleanBody;
    exports.assertEnumBooleanMember = assertEnumBooleanMember;
    exports.assertEnumDeclaration = assertEnumDeclaration;
    exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
    exports.assertEnumMember = assertEnumMember;
    exports.assertEnumNumberBody = assertEnumNumberBody;
    exports.assertEnumNumberMember = assertEnumNumberMember;
    exports.assertEnumStringBody = assertEnumStringBody;
    exports.assertEnumStringMember = assertEnumStringMember;
    exports.assertEnumSymbolBody = assertEnumSymbolBody;
    exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
    exports.assertExportAllDeclaration = assertExportAllDeclaration;
    exports.assertExportDeclaration = assertExportDeclaration;
    exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
    exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
    exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
    exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
    exports.assertExportSpecifier = assertExportSpecifier;
    exports.assertExpression = assertExpression;
    exports.assertExpressionStatement = assertExpressionStatement;
    exports.assertExpressionWrapper = assertExpressionWrapper;
    exports.assertFile = assertFile;
    exports.assertFlow = assertFlow;
    exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
    exports.assertFlowDeclaration = assertFlowDeclaration;
    exports.assertFlowPredicate = assertFlowPredicate;
    exports.assertFlowType = assertFlowType;
    exports.assertFor = assertFor;
    exports.assertForInStatement = assertForInStatement;
    exports.assertForOfStatement = assertForOfStatement;
    exports.assertForStatement = assertForStatement;
    exports.assertForXStatement = assertForXStatement;
    exports.assertFunction = assertFunction;
    exports.assertFunctionDeclaration = assertFunctionDeclaration;
    exports.assertFunctionExpression = assertFunctionExpression;
    exports.assertFunctionParent = assertFunctionParent;
    exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
    exports.assertFunctionTypeParam = assertFunctionTypeParam;
    exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
    exports.assertIdentifier = assertIdentifier;
    exports.assertIfStatement = assertIfStatement;
    exports.assertImmutable = assertImmutable;
    exports.assertImport = assertImport;
    exports.assertImportAttribute = assertImportAttribute;
    exports.assertImportDeclaration = assertImportDeclaration;
    exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
    exports.assertImportExpression = assertImportExpression;
    exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
    exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
    exports.assertImportSpecifier = assertImportSpecifier;
    exports.assertIndexedAccessType = assertIndexedAccessType;
    exports.assertInferredPredicate = assertInferredPredicate;
    exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
    exports.assertInterfaceExtends = assertInterfaceExtends;
    exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
    exports.assertInterpreterDirective = assertInterpreterDirective;
    exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
    exports.assertJSX = assertJSX;
    exports.assertJSXAttribute = assertJSXAttribute;
    exports.assertJSXClosingElement = assertJSXClosingElement;
    exports.assertJSXClosingFragment = assertJSXClosingFragment;
    exports.assertJSXElement = assertJSXElement;
    exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
    exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
    exports.assertJSXFragment = assertJSXFragment;
    exports.assertJSXIdentifier = assertJSXIdentifier;
    exports.assertJSXMemberExpression = assertJSXMemberExpression;
    exports.assertJSXNamespacedName = assertJSXNamespacedName;
    exports.assertJSXOpeningElement = assertJSXOpeningElement;
    exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
    exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
    exports.assertJSXSpreadChild = assertJSXSpreadChild;
    exports.assertJSXText = assertJSXText;
    exports.assertLVal = assertLVal;
    exports.assertLabeledStatement = assertLabeledStatement;
    exports.assertLiteral = assertLiteral;
    exports.assertLogicalExpression = assertLogicalExpression;
    exports.assertLoop = assertLoop;
    exports.assertMemberExpression = assertMemberExpression;
    exports.assertMetaProperty = assertMetaProperty;
    exports.assertMethod = assertMethod;
    exports.assertMiscellaneous = assertMiscellaneous;
    exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
    exports.assertModuleDeclaration = assertModuleDeclaration;
    exports.assertModuleExpression = assertModuleExpression;
    exports.assertModuleSpecifier = assertModuleSpecifier;
    exports.assertNewExpression = assertNewExpression;
    exports.assertNoop = assertNoop;
    exports.assertNullLiteral = assertNullLiteral;
    exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
    exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
    exports.assertNumberLiteral = assertNumberLiteral;
    exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
    exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
    exports.assertNumericLiteral = assertNumericLiteral;
    exports.assertObjectExpression = assertObjectExpression;
    exports.assertObjectMember = assertObjectMember;
    exports.assertObjectMethod = assertObjectMethod;
    exports.assertObjectPattern = assertObjectPattern;
    exports.assertObjectProperty = assertObjectProperty;
    exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
    exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
    exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
    exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
    exports.assertObjectTypeProperty = assertObjectTypeProperty;
    exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
    exports.assertOpaqueType = assertOpaqueType;
    exports.assertOptionalCallExpression = assertOptionalCallExpression;
    exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
    exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
    exports.assertParenthesizedExpression = assertParenthesizedExpression;
    exports.assertPattern = assertPattern;
    exports.assertPatternLike = assertPatternLike;
    exports.assertPipelineBareFunction = assertPipelineBareFunction;
    exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
    exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
    exports.assertPlaceholder = assertPlaceholder;
    exports.assertPrivate = assertPrivate;
    exports.assertPrivateName = assertPrivateName;
    exports.assertProgram = assertProgram;
    exports.assertProperty = assertProperty;
    exports.assertPureish = assertPureish;
    exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
    exports.assertRecordExpression = assertRecordExpression;
    exports.assertRegExpLiteral = assertRegExpLiteral;
    exports.assertRegexLiteral = assertRegexLiteral;
    exports.assertRestElement = assertRestElement;
    exports.assertRestProperty = assertRestProperty;
    exports.assertReturnStatement = assertReturnStatement;
    exports.assertScopable = assertScopable;
    exports.assertSequenceExpression = assertSequenceExpression;
    exports.assertSpreadElement = assertSpreadElement;
    exports.assertSpreadProperty = assertSpreadProperty;
    exports.assertStandardized = assertStandardized;
    exports.assertStatement = assertStatement;
    exports.assertStaticBlock = assertStaticBlock;
    exports.assertStringLiteral = assertStringLiteral;
    exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
    exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
    exports.assertSuper = assertSuper;
    exports.assertSwitchCase = assertSwitchCase;
    exports.assertSwitchStatement = assertSwitchStatement;
    exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
    exports.assertTSAnyKeyword = assertTSAnyKeyword;
    exports.assertTSArrayType = assertTSArrayType;
    exports.assertTSAsExpression = assertTSAsExpression;
    exports.assertTSBaseType = assertTSBaseType;
    exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
    exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
    exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
    exports.assertTSConditionalType = assertTSConditionalType;
    exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
    exports.assertTSConstructorType = assertTSConstructorType;
    exports.assertTSDeclareFunction = assertTSDeclareFunction;
    exports.assertTSDeclareMethod = assertTSDeclareMethod;
    exports.assertTSEntityName = assertTSEntityName;
    exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
    exports.assertTSEnumMember = assertTSEnumMember;
    exports.assertTSExportAssignment = assertTSExportAssignment;
    exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
    exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
    exports.assertTSFunctionType = assertTSFunctionType;
    exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
    exports.assertTSImportType = assertTSImportType;
    exports.assertTSIndexSignature = assertTSIndexSignature;
    exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
    exports.assertTSInferType = assertTSInferType;
    exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
    exports.assertTSInterfaceBody = assertTSInterfaceBody;
    exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
    exports.assertTSIntersectionType = assertTSIntersectionType;
    exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
    exports.assertTSLiteralType = assertTSLiteralType;
    exports.assertTSMappedType = assertTSMappedType;
    exports.assertTSMethodSignature = assertTSMethodSignature;
    exports.assertTSModuleBlock = assertTSModuleBlock;
    exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
    exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
    exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
    exports.assertTSNeverKeyword = assertTSNeverKeyword;
    exports.assertTSNonNullExpression = assertTSNonNullExpression;
    exports.assertTSNullKeyword = assertTSNullKeyword;
    exports.assertTSNumberKeyword = assertTSNumberKeyword;
    exports.assertTSObjectKeyword = assertTSObjectKeyword;
    exports.assertTSOptionalType = assertTSOptionalType;
    exports.assertTSParameterProperty = assertTSParameterProperty;
    exports.assertTSParenthesizedType = assertTSParenthesizedType;
    exports.assertTSPropertySignature = assertTSPropertySignature;
    exports.assertTSQualifiedName = assertTSQualifiedName;
    exports.assertTSRestType = assertTSRestType;
    exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
    exports.assertTSStringKeyword = assertTSStringKeyword;
    exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
    exports.assertTSThisType = assertTSThisType;
    exports.assertTSTupleType = assertTSTupleType;
    exports.assertTSType = assertTSType;
    exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
    exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
    exports.assertTSTypeAssertion = assertTSTypeAssertion;
    exports.assertTSTypeElement = assertTSTypeElement;
    exports.assertTSTypeLiteral = assertTSTypeLiteral;
    exports.assertTSTypeOperator = assertTSTypeOperator;
    exports.assertTSTypeParameter = assertTSTypeParameter;
    exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
    exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
    exports.assertTSTypePredicate = assertTSTypePredicate;
    exports.assertTSTypeQuery = assertTSTypeQuery;
    exports.assertTSTypeReference = assertTSTypeReference;
    exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
    exports.assertTSUnionType = assertTSUnionType;
    exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
    exports.assertTSVoidKeyword = assertTSVoidKeyword;
    exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
    exports.assertTemplateElement = assertTemplateElement;
    exports.assertTemplateLiteral = assertTemplateLiteral;
    exports.assertTerminatorless = assertTerminatorless;
    exports.assertThisExpression = assertThisExpression;
    exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
    exports.assertThrowStatement = assertThrowStatement;
    exports.assertTopicReference = assertTopicReference;
    exports.assertTryStatement = assertTryStatement;
    exports.assertTupleExpression = assertTupleExpression;
    exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
    exports.assertTypeAlias = assertTypeAlias;
    exports.assertTypeAnnotation = assertTypeAnnotation;
    exports.assertTypeCastExpression = assertTypeCastExpression;
    exports.assertTypeParameter = assertTypeParameter;
    exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
    exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
    exports.assertTypeScript = assertTypeScript;
    exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
    exports.assertUnaryExpression = assertUnaryExpression;
    exports.assertUnaryLike = assertUnaryLike;
    exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
    exports.assertUpdateExpression = assertUpdateExpression;
    exports.assertUserWhitespacable = assertUserWhitespacable;
    exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
    exports.assertVariableDeclaration = assertVariableDeclaration;
    exports.assertVariableDeclarator = assertVariableDeclarator;
    exports.assertVariance = assertVariance;
    exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
    exports.assertWhile = assertWhile;
    exports.assertWhileStatement = assertWhileStatement;
    exports.assertWithStatement = assertWithStatement;
    exports.assertYieldExpression = assertYieldExpression;
    var _is = require_is();
    var _deprecationWarning = require_deprecationWarning();
    function assert(type3, node, opts) {
      if (!(0, _is.default)(type3, node, opts)) {
        throw new Error(`Expected type "${type3}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
      }
    }
    function assertArrayExpression(node, opts) {
      assert("ArrayExpression", node, opts);
    }
    function assertAssignmentExpression(node, opts) {
      assert("AssignmentExpression", node, opts);
    }
    function assertBinaryExpression(node, opts) {
      assert("BinaryExpression", node, opts);
    }
    function assertInterpreterDirective(node, opts) {
      assert("InterpreterDirective", node, opts);
    }
    function assertDirective(node, opts) {
      assert("Directive", node, opts);
    }
    function assertDirectiveLiteral(node, opts) {
      assert("DirectiveLiteral", node, opts);
    }
    function assertBlockStatement(node, opts) {
      assert("BlockStatement", node, opts);
    }
    function assertBreakStatement(node, opts) {
      assert("BreakStatement", node, opts);
    }
    function assertCallExpression(node, opts) {
      assert("CallExpression", node, opts);
    }
    function assertCatchClause(node, opts) {
      assert("CatchClause", node, opts);
    }
    function assertConditionalExpression(node, opts) {
      assert("ConditionalExpression", node, opts);
    }
    function assertContinueStatement(node, opts) {
      assert("ContinueStatement", node, opts);
    }
    function assertDebuggerStatement(node, opts) {
      assert("DebuggerStatement", node, opts);
    }
    function assertDoWhileStatement(node, opts) {
      assert("DoWhileStatement", node, opts);
    }
    function assertEmptyStatement(node, opts) {
      assert("EmptyStatement", node, opts);
    }
    function assertExpressionStatement(node, opts) {
      assert("ExpressionStatement", node, opts);
    }
    function assertFile(node, opts) {
      assert("File", node, opts);
    }
    function assertForInStatement(node, opts) {
      assert("ForInStatement", node, opts);
    }
    function assertForStatement(node, opts) {
      assert("ForStatement", node, opts);
    }
    function assertFunctionDeclaration(node, opts) {
      assert("FunctionDeclaration", node, opts);
    }
    function assertFunctionExpression(node, opts) {
      assert("FunctionExpression", node, opts);
    }
    function assertIdentifier(node, opts) {
      assert("Identifier", node, opts);
    }
    function assertIfStatement(node, opts) {
      assert("IfStatement", node, opts);
    }
    function assertLabeledStatement(node, opts) {
      assert("LabeledStatement", node, opts);
    }
    function assertStringLiteral(node, opts) {
      assert("StringLiteral", node, opts);
    }
    function assertNumericLiteral(node, opts) {
      assert("NumericLiteral", node, opts);
    }
    function assertNullLiteral(node, opts) {
      assert("NullLiteral", node, opts);
    }
    function assertBooleanLiteral(node, opts) {
      assert("BooleanLiteral", node, opts);
    }
    function assertRegExpLiteral(node, opts) {
      assert("RegExpLiteral", node, opts);
    }
    function assertLogicalExpression(node, opts) {
      assert("LogicalExpression", node, opts);
    }
    function assertMemberExpression(node, opts) {
      assert("MemberExpression", node, opts);
    }
    function assertNewExpression(node, opts) {
      assert("NewExpression", node, opts);
    }
    function assertProgram(node, opts) {
      assert("Program", node, opts);
    }
    function assertObjectExpression(node, opts) {
      assert("ObjectExpression", node, opts);
    }
    function assertObjectMethod(node, opts) {
      assert("ObjectMethod", node, opts);
    }
    function assertObjectProperty(node, opts) {
      assert("ObjectProperty", node, opts);
    }
    function assertRestElement(node, opts) {
      assert("RestElement", node, opts);
    }
    function assertReturnStatement(node, opts) {
      assert("ReturnStatement", node, opts);
    }
    function assertSequenceExpression(node, opts) {
      assert("SequenceExpression", node, opts);
    }
    function assertParenthesizedExpression(node, opts) {
      assert("ParenthesizedExpression", node, opts);
    }
    function assertSwitchCase(node, opts) {
      assert("SwitchCase", node, opts);
    }
    function assertSwitchStatement(node, opts) {
      assert("SwitchStatement", node, opts);
    }
    function assertThisExpression(node, opts) {
      assert("ThisExpression", node, opts);
    }
    function assertThrowStatement(node, opts) {
      assert("ThrowStatement", node, opts);
    }
    function assertTryStatement(node, opts) {
      assert("TryStatement", node, opts);
    }
    function assertUnaryExpression(node, opts) {
      assert("UnaryExpression", node, opts);
    }
    function assertUpdateExpression(node, opts) {
      assert("UpdateExpression", node, opts);
    }
    function assertVariableDeclaration(node, opts) {
      assert("VariableDeclaration", node, opts);
    }
    function assertVariableDeclarator(node, opts) {
      assert("VariableDeclarator", node, opts);
    }
    function assertWhileStatement(node, opts) {
      assert("WhileStatement", node, opts);
    }
    function assertWithStatement(node, opts) {
      assert("WithStatement", node, opts);
    }
    function assertAssignmentPattern(node, opts) {
      assert("AssignmentPattern", node, opts);
    }
    function assertArrayPattern(node, opts) {
      assert("ArrayPattern", node, opts);
    }
    function assertArrowFunctionExpression(node, opts) {
      assert("ArrowFunctionExpression", node, opts);
    }
    function assertClassBody(node, opts) {
      assert("ClassBody", node, opts);
    }
    function assertClassExpression(node, opts) {
      assert("ClassExpression", node, opts);
    }
    function assertClassDeclaration(node, opts) {
      assert("ClassDeclaration", node, opts);
    }
    function assertExportAllDeclaration(node, opts) {
      assert("ExportAllDeclaration", node, opts);
    }
    function assertExportDefaultDeclaration(node, opts) {
      assert("ExportDefaultDeclaration", node, opts);
    }
    function assertExportNamedDeclaration(node, opts) {
      assert("ExportNamedDeclaration", node, opts);
    }
    function assertExportSpecifier(node, opts) {
      assert("ExportSpecifier", node, opts);
    }
    function assertForOfStatement(node, opts) {
      assert("ForOfStatement", node, opts);
    }
    function assertImportDeclaration(node, opts) {
      assert("ImportDeclaration", node, opts);
    }
    function assertImportDefaultSpecifier(node, opts) {
      assert("ImportDefaultSpecifier", node, opts);
    }
    function assertImportNamespaceSpecifier(node, opts) {
      assert("ImportNamespaceSpecifier", node, opts);
    }
    function assertImportSpecifier(node, opts) {
      assert("ImportSpecifier", node, opts);
    }
    function assertImportExpression(node, opts) {
      assert("ImportExpression", node, opts);
    }
    function assertMetaProperty(node, opts) {
      assert("MetaProperty", node, opts);
    }
    function assertClassMethod(node, opts) {
      assert("ClassMethod", node, opts);
    }
    function assertObjectPattern(node, opts) {
      assert("ObjectPattern", node, opts);
    }
    function assertSpreadElement(node, opts) {
      assert("SpreadElement", node, opts);
    }
    function assertSuper(node, opts) {
      assert("Super", node, opts);
    }
    function assertTaggedTemplateExpression(node, opts) {
      assert("TaggedTemplateExpression", node, opts);
    }
    function assertTemplateElement(node, opts) {
      assert("TemplateElement", node, opts);
    }
    function assertTemplateLiteral(node, opts) {
      assert("TemplateLiteral", node, opts);
    }
    function assertYieldExpression(node, opts) {
      assert("YieldExpression", node, opts);
    }
    function assertAwaitExpression(node, opts) {
      assert("AwaitExpression", node, opts);
    }
    function assertImport(node, opts) {
      assert("Import", node, opts);
    }
    function assertBigIntLiteral(node, opts) {
      assert("BigIntLiteral", node, opts);
    }
    function assertExportNamespaceSpecifier(node, opts) {
      assert("ExportNamespaceSpecifier", node, opts);
    }
    function assertOptionalMemberExpression(node, opts) {
      assert("OptionalMemberExpression", node, opts);
    }
    function assertOptionalCallExpression(node, opts) {
      assert("OptionalCallExpression", node, opts);
    }
    function assertClassProperty(node, opts) {
      assert("ClassProperty", node, opts);
    }
    function assertClassAccessorProperty(node, opts) {
      assert("ClassAccessorProperty", node, opts);
    }
    function assertClassPrivateProperty(node, opts) {
      assert("ClassPrivateProperty", node, opts);
    }
    function assertClassPrivateMethod(node, opts) {
      assert("ClassPrivateMethod", node, opts);
    }
    function assertPrivateName(node, opts) {
      assert("PrivateName", node, opts);
    }
    function assertStaticBlock(node, opts) {
      assert("StaticBlock", node, opts);
    }
    function assertAnyTypeAnnotation(node, opts) {
      assert("AnyTypeAnnotation", node, opts);
    }
    function assertArrayTypeAnnotation(node, opts) {
      assert("ArrayTypeAnnotation", node, opts);
    }
    function assertBooleanTypeAnnotation(node, opts) {
      assert("BooleanTypeAnnotation", node, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node, opts) {
      assert("BooleanLiteralTypeAnnotation", node, opts);
    }
    function assertNullLiteralTypeAnnotation(node, opts) {
      assert("NullLiteralTypeAnnotation", node, opts);
    }
    function assertClassImplements(node, opts) {
      assert("ClassImplements", node, opts);
    }
    function assertDeclareClass(node, opts) {
      assert("DeclareClass", node, opts);
    }
    function assertDeclareFunction(node, opts) {
      assert("DeclareFunction", node, opts);
    }
    function assertDeclareInterface(node, opts) {
      assert("DeclareInterface", node, opts);
    }
    function assertDeclareModule(node, opts) {
      assert("DeclareModule", node, opts);
    }
    function assertDeclareModuleExports(node, opts) {
      assert("DeclareModuleExports", node, opts);
    }
    function assertDeclareTypeAlias(node, opts) {
      assert("DeclareTypeAlias", node, opts);
    }
    function assertDeclareOpaqueType(node, opts) {
      assert("DeclareOpaqueType", node, opts);
    }
    function assertDeclareVariable(node, opts) {
      assert("DeclareVariable", node, opts);
    }
    function assertDeclareExportDeclaration(node, opts) {
      assert("DeclareExportDeclaration", node, opts);
    }
    function assertDeclareExportAllDeclaration(node, opts) {
      assert("DeclareExportAllDeclaration", node, opts);
    }
    function assertDeclaredPredicate(node, opts) {
      assert("DeclaredPredicate", node, opts);
    }
    function assertExistsTypeAnnotation(node, opts) {
      assert("ExistsTypeAnnotation", node, opts);
    }
    function assertFunctionTypeAnnotation(node, opts) {
      assert("FunctionTypeAnnotation", node, opts);
    }
    function assertFunctionTypeParam(node, opts) {
      assert("FunctionTypeParam", node, opts);
    }
    function assertGenericTypeAnnotation(node, opts) {
      assert("GenericTypeAnnotation", node, opts);
    }
    function assertInferredPredicate(node, opts) {
      assert("InferredPredicate", node, opts);
    }
    function assertInterfaceExtends(node, opts) {
      assert("InterfaceExtends", node, opts);
    }
    function assertInterfaceDeclaration(node, opts) {
      assert("InterfaceDeclaration", node, opts);
    }
    function assertInterfaceTypeAnnotation(node, opts) {
      assert("InterfaceTypeAnnotation", node, opts);
    }
    function assertIntersectionTypeAnnotation(node, opts) {
      assert("IntersectionTypeAnnotation", node, opts);
    }
    function assertMixedTypeAnnotation(node, opts) {
      assert("MixedTypeAnnotation", node, opts);
    }
    function assertEmptyTypeAnnotation(node, opts) {
      assert("EmptyTypeAnnotation", node, opts);
    }
    function assertNullableTypeAnnotation(node, opts) {
      assert("NullableTypeAnnotation", node, opts);
    }
    function assertNumberLiteralTypeAnnotation(node, opts) {
      assert("NumberLiteralTypeAnnotation", node, opts);
    }
    function assertNumberTypeAnnotation(node, opts) {
      assert("NumberTypeAnnotation", node, opts);
    }
    function assertObjectTypeAnnotation(node, opts) {
      assert("ObjectTypeAnnotation", node, opts);
    }
    function assertObjectTypeInternalSlot(node, opts) {
      assert("ObjectTypeInternalSlot", node, opts);
    }
    function assertObjectTypeCallProperty(node, opts) {
      assert("ObjectTypeCallProperty", node, opts);
    }
    function assertObjectTypeIndexer(node, opts) {
      assert("ObjectTypeIndexer", node, opts);
    }
    function assertObjectTypeProperty(node, opts) {
      assert("ObjectTypeProperty", node, opts);
    }
    function assertObjectTypeSpreadProperty(node, opts) {
      assert("ObjectTypeSpreadProperty", node, opts);
    }
    function assertOpaqueType(node, opts) {
      assert("OpaqueType", node, opts);
    }
    function assertQualifiedTypeIdentifier(node, opts) {
      assert("QualifiedTypeIdentifier", node, opts);
    }
    function assertStringLiteralTypeAnnotation(node, opts) {
      assert("StringLiteralTypeAnnotation", node, opts);
    }
    function assertStringTypeAnnotation(node, opts) {
      assert("StringTypeAnnotation", node, opts);
    }
    function assertSymbolTypeAnnotation(node, opts) {
      assert("SymbolTypeAnnotation", node, opts);
    }
    function assertThisTypeAnnotation(node, opts) {
      assert("ThisTypeAnnotation", node, opts);
    }
    function assertTupleTypeAnnotation(node, opts) {
      assert("TupleTypeAnnotation", node, opts);
    }
    function assertTypeofTypeAnnotation(node, opts) {
      assert("TypeofTypeAnnotation", node, opts);
    }
    function assertTypeAlias(node, opts) {
      assert("TypeAlias", node, opts);
    }
    function assertTypeAnnotation(node, opts) {
      assert("TypeAnnotation", node, opts);
    }
    function assertTypeCastExpression(node, opts) {
      assert("TypeCastExpression", node, opts);
    }
    function assertTypeParameter(node, opts) {
      assert("TypeParameter", node, opts);
    }
    function assertTypeParameterDeclaration(node, opts) {
      assert("TypeParameterDeclaration", node, opts);
    }
    function assertTypeParameterInstantiation(node, opts) {
      assert("TypeParameterInstantiation", node, opts);
    }
    function assertUnionTypeAnnotation(node, opts) {
      assert("UnionTypeAnnotation", node, opts);
    }
    function assertVariance(node, opts) {
      assert("Variance", node, opts);
    }
    function assertVoidTypeAnnotation(node, opts) {
      assert("VoidTypeAnnotation", node, opts);
    }
    function assertEnumDeclaration(node, opts) {
      assert("EnumDeclaration", node, opts);
    }
    function assertEnumBooleanBody(node, opts) {
      assert("EnumBooleanBody", node, opts);
    }
    function assertEnumNumberBody(node, opts) {
      assert("EnumNumberBody", node, opts);
    }
    function assertEnumStringBody(node, opts) {
      assert("EnumStringBody", node, opts);
    }
    function assertEnumSymbolBody(node, opts) {
      assert("EnumSymbolBody", node, opts);
    }
    function assertEnumBooleanMember(node, opts) {
      assert("EnumBooleanMember", node, opts);
    }
    function assertEnumNumberMember(node, opts) {
      assert("EnumNumberMember", node, opts);
    }
    function assertEnumStringMember(node, opts) {
      assert("EnumStringMember", node, opts);
    }
    function assertEnumDefaultedMember(node, opts) {
      assert("EnumDefaultedMember", node, opts);
    }
    function assertIndexedAccessType(node, opts) {
      assert("IndexedAccessType", node, opts);
    }
    function assertOptionalIndexedAccessType(node, opts) {
      assert("OptionalIndexedAccessType", node, opts);
    }
    function assertJSXAttribute(node, opts) {
      assert("JSXAttribute", node, opts);
    }
    function assertJSXClosingElement(node, opts) {
      assert("JSXClosingElement", node, opts);
    }
    function assertJSXElement(node, opts) {
      assert("JSXElement", node, opts);
    }
    function assertJSXEmptyExpression(node, opts) {
      assert("JSXEmptyExpression", node, opts);
    }
    function assertJSXExpressionContainer(node, opts) {
      assert("JSXExpressionContainer", node, opts);
    }
    function assertJSXSpreadChild(node, opts) {
      assert("JSXSpreadChild", node, opts);
    }
    function assertJSXIdentifier(node, opts) {
      assert("JSXIdentifier", node, opts);
    }
    function assertJSXMemberExpression(node, opts) {
      assert("JSXMemberExpression", node, opts);
    }
    function assertJSXNamespacedName(node, opts) {
      assert("JSXNamespacedName", node, opts);
    }
    function assertJSXOpeningElement(node, opts) {
      assert("JSXOpeningElement", node, opts);
    }
    function assertJSXSpreadAttribute(node, opts) {
      assert("JSXSpreadAttribute", node, opts);
    }
    function assertJSXText(node, opts) {
      assert("JSXText", node, opts);
    }
    function assertJSXFragment(node, opts) {
      assert("JSXFragment", node, opts);
    }
    function assertJSXOpeningFragment(node, opts) {
      assert("JSXOpeningFragment", node, opts);
    }
    function assertJSXClosingFragment(node, opts) {
      assert("JSXClosingFragment", node, opts);
    }
    function assertNoop(node, opts) {
      assert("Noop", node, opts);
    }
    function assertPlaceholder(node, opts) {
      assert("Placeholder", node, opts);
    }
    function assertV8IntrinsicIdentifier(node, opts) {
      assert("V8IntrinsicIdentifier", node, opts);
    }
    function assertArgumentPlaceholder(node, opts) {
      assert("ArgumentPlaceholder", node, opts);
    }
    function assertBindExpression(node, opts) {
      assert("BindExpression", node, opts);
    }
    function assertImportAttribute(node, opts) {
      assert("ImportAttribute", node, opts);
    }
    function assertDecorator(node, opts) {
      assert("Decorator", node, opts);
    }
    function assertDoExpression(node, opts) {
      assert("DoExpression", node, opts);
    }
    function assertExportDefaultSpecifier(node, opts) {
      assert("ExportDefaultSpecifier", node, opts);
    }
    function assertRecordExpression(node, opts) {
      assert("RecordExpression", node, opts);
    }
    function assertTupleExpression(node, opts) {
      assert("TupleExpression", node, opts);
    }
    function assertDecimalLiteral(node, opts) {
      assert("DecimalLiteral", node, opts);
    }
    function assertModuleExpression(node, opts) {
      assert("ModuleExpression", node, opts);
    }
    function assertTopicReference(node, opts) {
      assert("TopicReference", node, opts);
    }
    function assertPipelineTopicExpression(node, opts) {
      assert("PipelineTopicExpression", node, opts);
    }
    function assertPipelineBareFunction(node, opts) {
      assert("PipelineBareFunction", node, opts);
    }
    function assertPipelinePrimaryTopicReference(node, opts) {
      assert("PipelinePrimaryTopicReference", node, opts);
    }
    function assertTSParameterProperty(node, opts) {
      assert("TSParameterProperty", node, opts);
    }
    function assertTSDeclareFunction(node, opts) {
      assert("TSDeclareFunction", node, opts);
    }
    function assertTSDeclareMethod(node, opts) {
      assert("TSDeclareMethod", node, opts);
    }
    function assertTSQualifiedName(node, opts) {
      assert("TSQualifiedName", node, opts);
    }
    function assertTSCallSignatureDeclaration(node, opts) {
      assert("TSCallSignatureDeclaration", node, opts);
    }
    function assertTSConstructSignatureDeclaration(node, opts) {
      assert("TSConstructSignatureDeclaration", node, opts);
    }
    function assertTSPropertySignature(node, opts) {
      assert("TSPropertySignature", node, opts);
    }
    function assertTSMethodSignature(node, opts) {
      assert("TSMethodSignature", node, opts);
    }
    function assertTSIndexSignature(node, opts) {
      assert("TSIndexSignature", node, opts);
    }
    function assertTSAnyKeyword(node, opts) {
      assert("TSAnyKeyword", node, opts);
    }
    function assertTSBooleanKeyword(node, opts) {
      assert("TSBooleanKeyword", node, opts);
    }
    function assertTSBigIntKeyword(node, opts) {
      assert("TSBigIntKeyword", node, opts);
    }
    function assertTSIntrinsicKeyword(node, opts) {
      assert("TSIntrinsicKeyword", node, opts);
    }
    function assertTSNeverKeyword(node, opts) {
      assert("TSNeverKeyword", node, opts);
    }
    function assertTSNullKeyword(node, opts) {
      assert("TSNullKeyword", node, opts);
    }
    function assertTSNumberKeyword(node, opts) {
      assert("TSNumberKeyword", node, opts);
    }
    function assertTSObjectKeyword(node, opts) {
      assert("TSObjectKeyword", node, opts);
    }
    function assertTSStringKeyword(node, opts) {
      assert("TSStringKeyword", node, opts);
    }
    function assertTSSymbolKeyword(node, opts) {
      assert("TSSymbolKeyword", node, opts);
    }
    function assertTSUndefinedKeyword(node, opts) {
      assert("TSUndefinedKeyword", node, opts);
    }
    function assertTSUnknownKeyword(node, opts) {
      assert("TSUnknownKeyword", node, opts);
    }
    function assertTSVoidKeyword(node, opts) {
      assert("TSVoidKeyword", node, opts);
    }
    function assertTSThisType(node, opts) {
      assert("TSThisType", node, opts);
    }
    function assertTSFunctionType(node, opts) {
      assert("TSFunctionType", node, opts);
    }
    function assertTSConstructorType(node, opts) {
      assert("TSConstructorType", node, opts);
    }
    function assertTSTypeReference(node, opts) {
      assert("TSTypeReference", node, opts);
    }
    function assertTSTypePredicate(node, opts) {
      assert("TSTypePredicate", node, opts);
    }
    function assertTSTypeQuery(node, opts) {
      assert("TSTypeQuery", node, opts);
    }
    function assertTSTypeLiteral(node, opts) {
      assert("TSTypeLiteral", node, opts);
    }
    function assertTSArrayType(node, opts) {
      assert("TSArrayType", node, opts);
    }
    function assertTSTupleType(node, opts) {
      assert("TSTupleType", node, opts);
    }
    function assertTSOptionalType(node, opts) {
      assert("TSOptionalType", node, opts);
    }
    function assertTSRestType(node, opts) {
      assert("TSRestType", node, opts);
    }
    function assertTSNamedTupleMember(node, opts) {
      assert("TSNamedTupleMember", node, opts);
    }
    function assertTSUnionType(node, opts) {
      assert("TSUnionType", node, opts);
    }
    function assertTSIntersectionType(node, opts) {
      assert("TSIntersectionType", node, opts);
    }
    function assertTSConditionalType(node, opts) {
      assert("TSConditionalType", node, opts);
    }
    function assertTSInferType(node, opts) {
      assert("TSInferType", node, opts);
    }
    function assertTSParenthesizedType(node, opts) {
      assert("TSParenthesizedType", node, opts);
    }
    function assertTSTypeOperator(node, opts) {
      assert("TSTypeOperator", node, opts);
    }
    function assertTSIndexedAccessType(node, opts) {
      assert("TSIndexedAccessType", node, opts);
    }
    function assertTSMappedType(node, opts) {
      assert("TSMappedType", node, opts);
    }
    function assertTSLiteralType(node, opts) {
      assert("TSLiteralType", node, opts);
    }
    function assertTSExpressionWithTypeArguments(node, opts) {
      assert("TSExpressionWithTypeArguments", node, opts);
    }
    function assertTSInterfaceDeclaration(node, opts) {
      assert("TSInterfaceDeclaration", node, opts);
    }
    function assertTSInterfaceBody(node, opts) {
      assert("TSInterfaceBody", node, opts);
    }
    function assertTSTypeAliasDeclaration(node, opts) {
      assert("TSTypeAliasDeclaration", node, opts);
    }
    function assertTSInstantiationExpression(node, opts) {
      assert("TSInstantiationExpression", node, opts);
    }
    function assertTSAsExpression(node, opts) {
      assert("TSAsExpression", node, opts);
    }
    function assertTSSatisfiesExpression(node, opts) {
      assert("TSSatisfiesExpression", node, opts);
    }
    function assertTSTypeAssertion(node, opts) {
      assert("TSTypeAssertion", node, opts);
    }
    function assertTSEnumDeclaration(node, opts) {
      assert("TSEnumDeclaration", node, opts);
    }
    function assertTSEnumMember(node, opts) {
      assert("TSEnumMember", node, opts);
    }
    function assertTSModuleDeclaration(node, opts) {
      assert("TSModuleDeclaration", node, opts);
    }
    function assertTSModuleBlock(node, opts) {
      assert("TSModuleBlock", node, opts);
    }
    function assertTSImportType(node, opts) {
      assert("TSImportType", node, opts);
    }
    function assertTSImportEqualsDeclaration(node, opts) {
      assert("TSImportEqualsDeclaration", node, opts);
    }
    function assertTSExternalModuleReference(node, opts) {
      assert("TSExternalModuleReference", node, opts);
    }
    function assertTSNonNullExpression(node, opts) {
      assert("TSNonNullExpression", node, opts);
    }
    function assertTSExportAssignment(node, opts) {
      assert("TSExportAssignment", node, opts);
    }
    function assertTSNamespaceExportDeclaration(node, opts) {
      assert("TSNamespaceExportDeclaration", node, opts);
    }
    function assertTSTypeAnnotation(node, opts) {
      assert("TSTypeAnnotation", node, opts);
    }
    function assertTSTypeParameterInstantiation(node, opts) {
      assert("TSTypeParameterInstantiation", node, opts);
    }
    function assertTSTypeParameterDeclaration(node, opts) {
      assert("TSTypeParameterDeclaration", node, opts);
    }
    function assertTSTypeParameter(node, opts) {
      assert("TSTypeParameter", node, opts);
    }
    function assertStandardized(node, opts) {
      assert("Standardized", node, opts);
    }
    function assertExpression(node, opts) {
      assert("Expression", node, opts);
    }
    function assertBinary(node, opts) {
      assert("Binary", node, opts);
    }
    function assertScopable(node, opts) {
      assert("Scopable", node, opts);
    }
    function assertBlockParent(node, opts) {
      assert("BlockParent", node, opts);
    }
    function assertBlock(node, opts) {
      assert("Block", node, opts);
    }
    function assertStatement(node, opts) {
      assert("Statement", node, opts);
    }
    function assertTerminatorless(node, opts) {
      assert("Terminatorless", node, opts);
    }
    function assertCompletionStatement(node, opts) {
      assert("CompletionStatement", node, opts);
    }
    function assertConditional(node, opts) {
      assert("Conditional", node, opts);
    }
    function assertLoop(node, opts) {
      assert("Loop", node, opts);
    }
    function assertWhile(node, opts) {
      assert("While", node, opts);
    }
    function assertExpressionWrapper(node, opts) {
      assert("ExpressionWrapper", node, opts);
    }
    function assertFor(node, opts) {
      assert("For", node, opts);
    }
    function assertForXStatement(node, opts) {
      assert("ForXStatement", node, opts);
    }
    function assertFunction(node, opts) {
      assert("Function", node, opts);
    }
    function assertFunctionParent(node, opts) {
      assert("FunctionParent", node, opts);
    }
    function assertPureish(node, opts) {
      assert("Pureish", node, opts);
    }
    function assertDeclaration(node, opts) {
      assert("Declaration", node, opts);
    }
    function assertPatternLike(node, opts) {
      assert("PatternLike", node, opts);
    }
    function assertLVal(node, opts) {
      assert("LVal", node, opts);
    }
    function assertTSEntityName(node, opts) {
      assert("TSEntityName", node, opts);
    }
    function assertLiteral(node, opts) {
      assert("Literal", node, opts);
    }
    function assertImmutable(node, opts) {
      assert("Immutable", node, opts);
    }
    function assertUserWhitespacable(node, opts) {
      assert("UserWhitespacable", node, opts);
    }
    function assertMethod(node, opts) {
      assert("Method", node, opts);
    }
    function assertObjectMember(node, opts) {
      assert("ObjectMember", node, opts);
    }
    function assertProperty(node, opts) {
      assert("Property", node, opts);
    }
    function assertUnaryLike(node, opts) {
      assert("UnaryLike", node, opts);
    }
    function assertPattern(node, opts) {
      assert("Pattern", node, opts);
    }
    function assertClass(node, opts) {
      assert("Class", node, opts);
    }
    function assertImportOrExportDeclaration(node, opts) {
      assert("ImportOrExportDeclaration", node, opts);
    }
    function assertExportDeclaration(node, opts) {
      assert("ExportDeclaration", node, opts);
    }
    function assertModuleSpecifier(node, opts) {
      assert("ModuleSpecifier", node, opts);
    }
    function assertAccessor(node, opts) {
      assert("Accessor", node, opts);
    }
    function assertPrivate(node, opts) {
      assert("Private", node, opts);
    }
    function assertFlow(node, opts) {
      assert("Flow", node, opts);
    }
    function assertFlowType(node, opts) {
      assert("FlowType", node, opts);
    }
    function assertFlowBaseAnnotation(node, opts) {
      assert("FlowBaseAnnotation", node, opts);
    }
    function assertFlowDeclaration(node, opts) {
      assert("FlowDeclaration", node, opts);
    }
    function assertFlowPredicate(node, opts) {
      assert("FlowPredicate", node, opts);
    }
    function assertEnumBody(node, opts) {
      assert("EnumBody", node, opts);
    }
    function assertEnumMember(node, opts) {
      assert("EnumMember", node, opts);
    }
    function assertJSX(node, opts) {
      assert("JSX", node, opts);
    }
    function assertMiscellaneous(node, opts) {
      assert("Miscellaneous", node, opts);
    }
    function assertTypeScript(node, opts) {
      assert("TypeScript", node, opts);
    }
    function assertTSTypeElement(node, opts) {
      assert("TSTypeElement", node, opts);
    }
    function assertTSType(node, opts) {
      assert("TSType", node, opts);
    }
    function assertTSBaseType(node, opts) {
      assert("TSBaseType", node, opts);
    }
    function assertNumberLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
      assert("NumberLiteral", node, opts);
    }
    function assertRegexLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
      assert("RegexLiteral", node, opts);
    }
    function assertRestProperty(node, opts) {
      (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
      assert("RestProperty", node, opts);
    }
    function assertSpreadProperty(node, opts) {
      (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
      assert("SpreadProperty", node, opts);
    }
    function assertModuleDeclaration(node, opts) {
      (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
      assert("ModuleDeclaration", node, opts);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = require_generated2();
    var _default = createTypeAnnotationBasedOnTypeof;
    exports.default = _default;
    function createTypeAnnotationBasedOnTypeof(type3) {
      switch (type3) {
        case "string":
          return (0, _index.stringTypeAnnotation)();
        case "number":
          return (0, _index.numberTypeAnnotation)();
        case "undefined":
          return (0, _index.voidTypeAnnotation)();
        case "boolean":
          return (0, _index.booleanTypeAnnotation)();
        case "function":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
        case "object":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
        case "symbol":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
        case "bigint":
          return (0, _index.anyTypeAnnotation)();
      }
      throw new Error("Invalid typeof value: " + type3);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node) {
      return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!node)
          continue;
        if (types.indexOf(node) >= 0) {
          continue;
        }
        if ((0, _index.isAnyTypeAnnotation)(node)) {
          return [node];
        }
        if ((0, _index.isFlowBaseAnnotation)(node)) {
          bases.set(node.type, node);
          continue;
        }
        if ((0, _index.isUnionTypeAnnotation)(node)) {
          if (!typeGroups.has(node.types)) {
            nodes.push(...node.types);
            typeGroups.add(node.types);
          }
          continue;
        }
        if ((0, _index.isGenericTypeAnnotation)(node)) {
          const name = getQualifiedName(node.id);
          if (generics.has(name)) {
            let existing = generics.get(name);
            if (existing.typeParameters) {
              if (node.typeParameters) {
                existing.typeParameters.params.push(...node.typeParameters.params);
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
              }
            } else {
              existing = node.typeParameters;
            }
          } else {
            generics.set(name, node);
          }
          continue;
        }
        types.push(node);
      }
      for (const [, baseType] of bases) {
        types.push(baseType);
      }
      for (const [, genericName] of generics) {
        types.push(genericName);
      }
      return types;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createFlowUnionType;
    var _index = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    function createFlowUnionType(types) {
      const flattened = (0, _removeTypeDuplicates.default)(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index.unionTypeAnnotation)(flattened);
      }
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node) {
      return (0, _index.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!node)
          continue;
        if (types.indexOf(node) >= 0) {
          continue;
        }
        if ((0, _index.isTSAnyKeyword)(node)) {
          return [node];
        }
        if ((0, _index.isTSBaseType)(node)) {
          bases.set(node.type, node);
          continue;
        }
        if ((0, _index.isTSUnionType)(node)) {
          if (!typeGroups.has(node.types)) {
            nodes.push(...node.types);
            typeGroups.add(node.types);
          }
          continue;
        }
        if ((0, _index.isTSTypeReference)(node) && node.typeParameters) {
          const name = getQualifiedName(node.typeName);
          if (generics.has(name)) {
            let existing = generics.get(name);
            if (existing.typeParameters) {
              if (node.typeParameters) {
                existing.typeParameters.params.push(...node.typeParameters.params);
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
              }
            } else {
              existing = node.typeParameters;
            }
          } else {
            generics.set(name, node);
          }
          continue;
        }
        types.push(node);
      }
      for (const [, baseType] of bases) {
        types.push(baseType);
      }
      for (const [, genericName] of generics) {
        types.push(genericName);
      }
      return types;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createTSUnionType;
    var _index = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates2();
    var _index2 = require_generated();
    function createTSUnionType(typeAnnotations) {
      const types = typeAnnotations.map((type3) => {
        return (0, _index2.isTSTypeAnnotation)(type3) ? type3.typeAnnotation : type3;
      });
      const flattened = (0, _removeTypeDuplicates.default)(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index.tsUnionType)(flattened);
      }
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/generated/uppercase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AnyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.anyTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ArgumentPlaceholder", {
      enumerable: true,
      get: function() {
        return _index.argumentPlaceholder;
      }
    });
    Object.defineProperty(exports, "ArrayExpression", {
      enumerable: true,
      get: function() {
        return _index.arrayExpression;
      }
    });
    Object.defineProperty(exports, "ArrayPattern", {
      enumerable: true,
      get: function() {
        return _index.arrayPattern;
      }
    });
    Object.defineProperty(exports, "ArrayTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.arrayTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ArrowFunctionExpression", {
      enumerable: true,
      get: function() {
        return _index.arrowFunctionExpression;
      }
    });
    Object.defineProperty(exports, "AssignmentExpression", {
      enumerable: true,
      get: function() {
        return _index.assignmentExpression;
      }
    });
    Object.defineProperty(exports, "AssignmentPattern", {
      enumerable: true,
      get: function() {
        return _index.assignmentPattern;
      }
    });
    Object.defineProperty(exports, "AwaitExpression", {
      enumerable: true,
      get: function() {
        return _index.awaitExpression;
      }
    });
    Object.defineProperty(exports, "BigIntLiteral", {
      enumerable: true,
      get: function() {
        return _index.bigIntLiteral;
      }
    });
    Object.defineProperty(exports, "BinaryExpression", {
      enumerable: true,
      get: function() {
        return _index.binaryExpression;
      }
    });
    Object.defineProperty(exports, "BindExpression", {
      enumerable: true,
      get: function() {
        return _index.bindExpression;
      }
    });
    Object.defineProperty(exports, "BlockStatement", {
      enumerable: true,
      get: function() {
        return _index.blockStatement;
      }
    });
    Object.defineProperty(exports, "BooleanLiteral", {
      enumerable: true,
      get: function() {
        return _index.booleanLiteral;
      }
    });
    Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.booleanLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "BooleanTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.booleanTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "BreakStatement", {
      enumerable: true,
      get: function() {
        return _index.breakStatement;
      }
    });
    Object.defineProperty(exports, "CallExpression", {
      enumerable: true,
      get: function() {
        return _index.callExpression;
      }
    });
    Object.defineProperty(exports, "CatchClause", {
      enumerable: true,
      get: function() {
        return _index.catchClause;
      }
    });
    Object.defineProperty(exports, "ClassAccessorProperty", {
      enumerable: true,
      get: function() {
        return _index.classAccessorProperty;
      }
    });
    Object.defineProperty(exports, "ClassBody", {
      enumerable: true,
      get: function() {
        return _index.classBody;
      }
    });
    Object.defineProperty(exports, "ClassDeclaration", {
      enumerable: true,
      get: function() {
        return _index.classDeclaration;
      }
    });
    Object.defineProperty(exports, "ClassExpression", {
      enumerable: true,
      get: function() {
        return _index.classExpression;
      }
    });
    Object.defineProperty(exports, "ClassImplements", {
      enumerable: true,
      get: function() {
        return _index.classImplements;
      }
    });
    Object.defineProperty(exports, "ClassMethod", {
      enumerable: true,
      get: function() {
        return _index.classMethod;
      }
    });
    Object.defineProperty(exports, "ClassPrivateMethod", {
      enumerable: true,
      get: function() {
        return _index.classPrivateMethod;
      }
    });
    Object.defineProperty(exports, "ClassPrivateProperty", {
      enumerable: true,
      get: function() {
        return _index.classPrivateProperty;
      }
    });
    Object.defineProperty(exports, "ClassProperty", {
      enumerable: true,
      get: function() {
        return _index.classProperty;
      }
    });
    Object.defineProperty(exports, "ConditionalExpression", {
      enumerable: true,
      get: function() {
        return _index.conditionalExpression;
      }
    });
    Object.defineProperty(exports, "ContinueStatement", {
      enumerable: true,
      get: function() {
        return _index.continueStatement;
      }
    });
    Object.defineProperty(exports, "DebuggerStatement", {
      enumerable: true,
      get: function() {
        return _index.debuggerStatement;
      }
    });
    Object.defineProperty(exports, "DecimalLiteral", {
      enumerable: true,
      get: function() {
        return _index.decimalLiteral;
      }
    });
    Object.defineProperty(exports, "DeclareClass", {
      enumerable: true,
      get: function() {
        return _index.declareClass;
      }
    });
    Object.defineProperty(exports, "DeclareExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _index.declareExportAllDeclaration;
      }
    });
    Object.defineProperty(exports, "DeclareExportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.declareExportDeclaration;
      }
    });
    Object.defineProperty(exports, "DeclareFunction", {
      enumerable: true,
      get: function() {
        return _index.declareFunction;
      }
    });
    Object.defineProperty(exports, "DeclareInterface", {
      enumerable: true,
      get: function() {
        return _index.declareInterface;
      }
    });
    Object.defineProperty(exports, "DeclareModule", {
      enumerable: true,
      get: function() {
        return _index.declareModule;
      }
    });
    Object.defineProperty(exports, "DeclareModuleExports", {
      enumerable: true,
      get: function() {
        return _index.declareModuleExports;
      }
    });
    Object.defineProperty(exports, "DeclareOpaqueType", {
      enumerable: true,
      get: function() {
        return _index.declareOpaqueType;
      }
    });
    Object.defineProperty(exports, "DeclareTypeAlias", {
      enumerable: true,
      get: function() {
        return _index.declareTypeAlias;
      }
    });
    Object.defineProperty(exports, "DeclareVariable", {
      enumerable: true,
      get: function() {
        return _index.declareVariable;
      }
    });
    Object.defineProperty(exports, "DeclaredPredicate", {
      enumerable: true,
      get: function() {
        return _index.declaredPredicate;
      }
    });
    Object.defineProperty(exports, "Decorator", {
      enumerable: true,
      get: function() {
        return _index.decorator;
      }
    });
    Object.defineProperty(exports, "Directive", {
      enumerable: true,
      get: function() {
        return _index.directive;
      }
    });
    Object.defineProperty(exports, "DirectiveLiteral", {
      enumerable: true,
      get: function() {
        return _index.directiveLiteral;
      }
    });
    Object.defineProperty(exports, "DoExpression", {
      enumerable: true,
      get: function() {
        return _index.doExpression;
      }
    });
    Object.defineProperty(exports, "DoWhileStatement", {
      enumerable: true,
      get: function() {
        return _index.doWhileStatement;
      }
    });
    Object.defineProperty(exports, "EmptyStatement", {
      enumerable: true,
      get: function() {
        return _index.emptyStatement;
      }
    });
    Object.defineProperty(exports, "EmptyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.emptyTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "EnumBooleanBody", {
      enumerable: true,
      get: function() {
        return _index.enumBooleanBody;
      }
    });
    Object.defineProperty(exports, "EnumBooleanMember", {
      enumerable: true,
      get: function() {
        return _index.enumBooleanMember;
      }
    });
    Object.defineProperty(exports, "EnumDeclaration", {
      enumerable: true,
      get: function() {
        return _index.enumDeclaration;
      }
    });
    Object.defineProperty(exports, "EnumDefaultedMember", {
      enumerable: true,
      get: function() {
        return _index.enumDefaultedMember;
      }
    });
    Object.defineProperty(exports, "EnumNumberBody", {
      enumerable: true,
      get: function() {
        return _index.enumNumberBody;
      }
    });
    Object.defineProperty(exports, "EnumNumberMember", {
      enumerable: true,
      get: function() {
        return _index.enumNumberMember;
      }
    });
    Object.defineProperty(exports, "EnumStringBody", {
      enumerable: true,
      get: function() {
        return _index.enumStringBody;
      }
    });
    Object.defineProperty(exports, "EnumStringMember", {
      enumerable: true,
      get: function() {
        return _index.enumStringMember;
      }
    });
    Object.defineProperty(exports, "EnumSymbolBody", {
      enumerable: true,
      get: function() {
        return _index.enumSymbolBody;
      }
    });
    Object.defineProperty(exports, "ExistsTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.existsTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportAllDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportDefaultDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportDefaultDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportDefaultSpecifier;
      }
    });
    Object.defineProperty(exports, "ExportNamedDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportNamedDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports, "ExportSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportSpecifier;
      }
    });
    Object.defineProperty(exports, "ExpressionStatement", {
      enumerable: true,
      get: function() {
        return _index.expressionStatement;
      }
    });
    Object.defineProperty(exports, "File", {
      enumerable: true,
      get: function() {
        return _index.file;
      }
    });
    Object.defineProperty(exports, "ForInStatement", {
      enumerable: true,
      get: function() {
        return _index.forInStatement;
      }
    });
    Object.defineProperty(exports, "ForOfStatement", {
      enumerable: true,
      get: function() {
        return _index.forOfStatement;
      }
    });
    Object.defineProperty(exports, "ForStatement", {
      enumerable: true,
      get: function() {
        return _index.forStatement;
      }
    });
    Object.defineProperty(exports, "FunctionDeclaration", {
      enumerable: true,
      get: function() {
        return _index.functionDeclaration;
      }
    });
    Object.defineProperty(exports, "FunctionExpression", {
      enumerable: true,
      get: function() {
        return _index.functionExpression;
      }
    });
    Object.defineProperty(exports, "FunctionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.functionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "FunctionTypeParam", {
      enumerable: true,
      get: function() {
        return _index.functionTypeParam;
      }
    });
    Object.defineProperty(exports, "GenericTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.genericTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "Identifier", {
      enumerable: true,
      get: function() {
        return _index.identifier;
      }
    });
    Object.defineProperty(exports, "IfStatement", {
      enumerable: true,
      get: function() {
        return _index.ifStatement;
      }
    });
    Object.defineProperty(exports, "Import", {
      enumerable: true,
      get: function() {
        return _index.import;
      }
    });
    Object.defineProperty(exports, "ImportAttribute", {
      enumerable: true,
      get: function() {
        return _index.importAttribute;
      }
    });
    Object.defineProperty(exports, "ImportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.importDeclaration;
      }
    });
    Object.defineProperty(exports, "ImportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importDefaultSpecifier;
      }
    });
    Object.defineProperty(exports, "ImportExpression", {
      enumerable: true,
      get: function() {
        return _index.importExpression;
      }
    });
    Object.defineProperty(exports, "ImportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports, "ImportSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importSpecifier;
      }
    });
    Object.defineProperty(exports, "IndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.indexedAccessType;
      }
    });
    Object.defineProperty(exports, "InferredPredicate", {
      enumerable: true,
      get: function() {
        return _index.inferredPredicate;
      }
    });
    Object.defineProperty(exports, "InterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _index.interfaceDeclaration;
      }
    });
    Object.defineProperty(exports, "InterfaceExtends", {
      enumerable: true,
      get: function() {
        return _index.interfaceExtends;
      }
    });
    Object.defineProperty(exports, "InterfaceTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.interfaceTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "InterpreterDirective", {
      enumerable: true,
      get: function() {
        return _index.interpreterDirective;
      }
    });
    Object.defineProperty(exports, "IntersectionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.intersectionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "JSXAttribute", {
      enumerable: true,
      get: function() {
        return _index.jsxAttribute;
      }
    });
    Object.defineProperty(exports, "JSXClosingElement", {
      enumerable: true,
      get: function() {
        return _index.jsxClosingElement;
      }
    });
    Object.defineProperty(exports, "JSXClosingFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxClosingFragment;
      }
    });
    Object.defineProperty(exports, "JSXElement", {
      enumerable: true,
      get: function() {
        return _index.jsxElement;
      }
    });
    Object.defineProperty(exports, "JSXEmptyExpression", {
      enumerable: true,
      get: function() {
        return _index.jsxEmptyExpression;
      }
    });
    Object.defineProperty(exports, "JSXExpressionContainer", {
      enumerable: true,
      get: function() {
        return _index.jsxExpressionContainer;
      }
    });
    Object.defineProperty(exports, "JSXFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxFragment;
      }
    });
    Object.defineProperty(exports, "JSXIdentifier", {
      enumerable: true,
      get: function() {
        return _index.jsxIdentifier;
      }
    });
    Object.defineProperty(exports, "JSXMemberExpression", {
      enumerable: true,
      get: function() {
        return _index.jsxMemberExpression;
      }
    });
    Object.defineProperty(exports, "JSXNamespacedName", {
      enumerable: true,
      get: function() {
        return _index.jsxNamespacedName;
      }
    });
    Object.defineProperty(exports, "JSXOpeningElement", {
      enumerable: true,
      get: function() {
        return _index.jsxOpeningElement;
      }
    });
    Object.defineProperty(exports, "JSXOpeningFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxOpeningFragment;
      }
    });
    Object.defineProperty(exports, "JSXSpreadAttribute", {
      enumerable: true,
      get: function() {
        return _index.jsxSpreadAttribute;
      }
    });
    Object.defineProperty(exports, "JSXSpreadChild", {
      enumerable: true,
      get: function() {
        return _index.jsxSpreadChild;
      }
    });
    Object.defineProperty(exports, "JSXText", {
      enumerable: true,
      get: function() {
        return _index.jsxText;
      }
    });
    Object.defineProperty(exports, "LabeledStatement", {
      enumerable: true,
      get: function() {
        return _index.labeledStatement;
      }
    });
    Object.defineProperty(exports, "LogicalExpression", {
      enumerable: true,
      get: function() {
        return _index.logicalExpression;
      }
    });
    Object.defineProperty(exports, "MemberExpression", {
      enumerable: true,
      get: function() {
        return _index.memberExpression;
      }
    });
    Object.defineProperty(exports, "MetaProperty", {
      enumerable: true,
      get: function() {
        return _index.metaProperty;
      }
    });
    Object.defineProperty(exports, "MixedTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.mixedTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ModuleExpression", {
      enumerable: true,
      get: function() {
        return _index.moduleExpression;
      }
    });
    Object.defineProperty(exports, "NewExpression", {
      enumerable: true,
      get: function() {
        return _index.newExpression;
      }
    });
    Object.defineProperty(exports, "Noop", {
      enumerable: true,
      get: function() {
        return _index.noop;
      }
    });
    Object.defineProperty(exports, "NullLiteral", {
      enumerable: true,
      get: function() {
        return _index.nullLiteral;
      }
    });
    Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.nullLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NullableTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.nullableTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumberLiteral", {
      enumerable: true,
      get: function() {
        return _index.numberLiteral;
      }
    });
    Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.numberLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumberTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.numberTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumericLiteral", {
      enumerable: true,
      get: function() {
        return _index.numericLiteral;
      }
    });
    Object.defineProperty(exports, "ObjectExpression", {
      enumerable: true,
      get: function() {
        return _index.objectExpression;
      }
    });
    Object.defineProperty(exports, "ObjectMethod", {
      enumerable: true,
      get: function() {
        return _index.objectMethod;
      }
    });
    Object.defineProperty(exports, "ObjectPattern", {
      enumerable: true,
      get: function() {
        return _index.objectPattern;
      }
    });
    Object.defineProperty(exports, "ObjectProperty", {
      enumerable: true,
      get: function() {
        return _index.objectProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.objectTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ObjectTypeCallProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeCallProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeIndexer", {
      enumerable: true,
      get: function() {
        return _index.objectTypeIndexer;
      }
    });
    Object.defineProperty(exports, "ObjectTypeInternalSlot", {
      enumerable: true,
      get: function() {
        return _index.objectTypeInternalSlot;
      }
    });
    Object.defineProperty(exports, "ObjectTypeProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeSpreadProperty;
      }
    });
    Object.defineProperty(exports, "OpaqueType", {
      enumerable: true,
      get: function() {
        return _index.opaqueType;
      }
    });
    Object.defineProperty(exports, "OptionalCallExpression", {
      enumerable: true,
      get: function() {
        return _index.optionalCallExpression;
      }
    });
    Object.defineProperty(exports, "OptionalIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.optionalIndexedAccessType;
      }
    });
    Object.defineProperty(exports, "OptionalMemberExpression", {
      enumerable: true,
      get: function() {
        return _index.optionalMemberExpression;
      }
    });
    Object.defineProperty(exports, "ParenthesizedExpression", {
      enumerable: true,
      get: function() {
        return _index.parenthesizedExpression;
      }
    });
    Object.defineProperty(exports, "PipelineBareFunction", {
      enumerable: true,
      get: function() {
        return _index.pipelineBareFunction;
      }
    });
    Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
      enumerable: true,
      get: function() {
        return _index.pipelinePrimaryTopicReference;
      }
    });
    Object.defineProperty(exports, "PipelineTopicExpression", {
      enumerable: true,
      get: function() {
        return _index.pipelineTopicExpression;
      }
    });
    Object.defineProperty(exports, "Placeholder", {
      enumerable: true,
      get: function() {
        return _index.placeholder;
      }
    });
    Object.defineProperty(exports, "PrivateName", {
      enumerable: true,
      get: function() {
        return _index.privateName;
      }
    });
    Object.defineProperty(exports, "Program", {
      enumerable: true,
      get: function() {
        return _index.program;
      }
    });
    Object.defineProperty(exports, "QualifiedTypeIdentifier", {
      enumerable: true,
      get: function() {
        return _index.qualifiedTypeIdentifier;
      }
    });
    Object.defineProperty(exports, "RecordExpression", {
      enumerable: true,
      get: function() {
        return _index.recordExpression;
      }
    });
    Object.defineProperty(exports, "RegExpLiteral", {
      enumerable: true,
      get: function() {
        return _index.regExpLiteral;
      }
    });
    Object.defineProperty(exports, "RegexLiteral", {
      enumerable: true,
      get: function() {
        return _index.regexLiteral;
      }
    });
    Object.defineProperty(exports, "RestElement", {
      enumerable: true,
      get: function() {
        return _index.restElement;
      }
    });
    Object.defineProperty(exports, "RestProperty", {
      enumerable: true,
      get: function() {
        return _index.restProperty;
      }
    });
    Object.defineProperty(exports, "ReturnStatement", {
      enumerable: true,
      get: function() {
        return _index.returnStatement;
      }
    });
    Object.defineProperty(exports, "SequenceExpression", {
      enumerable: true,
      get: function() {
        return _index.sequenceExpression;
      }
    });
    Object.defineProperty(exports, "SpreadElement", {
      enumerable: true,
      get: function() {
        return _index.spreadElement;
      }
    });
    Object.defineProperty(exports, "SpreadProperty", {
      enumerable: true,
      get: function() {
        return _index.spreadProperty;
      }
    });
    Object.defineProperty(exports, "StaticBlock", {
      enumerable: true,
      get: function() {
        return _index.staticBlock;
      }
    });
    Object.defineProperty(exports, "StringLiteral", {
      enumerable: true,
      get: function() {
        return _index.stringLiteral;
      }
    });
    Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.stringLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "StringTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.stringTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "Super", {
      enumerable: true,
      get: function() {
        return _index.super;
      }
    });
    Object.defineProperty(exports, "SwitchCase", {
      enumerable: true,
      get: function() {
        return _index.switchCase;
      }
    });
    Object.defineProperty(exports, "SwitchStatement", {
      enumerable: true,
      get: function() {
        return _index.switchStatement;
      }
    });
    Object.defineProperty(exports, "SymbolTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.symbolTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TSAnyKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsAnyKeyword;
      }
    });
    Object.defineProperty(exports, "TSArrayType", {
      enumerable: true,
      get: function() {
        return _index.tsArrayType;
      }
    });
    Object.defineProperty(exports, "TSAsExpression", {
      enumerable: true,
      get: function() {
        return _index.tsAsExpression;
      }
    });
    Object.defineProperty(exports, "TSBigIntKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsBigIntKeyword;
      }
    });
    Object.defineProperty(exports, "TSBooleanKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsBooleanKeyword;
      }
    });
    Object.defineProperty(exports, "TSCallSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsCallSignatureDeclaration;
      }
    });
    Object.defineProperty(exports, "TSConditionalType", {
      enumerable: true,
      get: function() {
        return _index.tsConditionalType;
      }
    });
    Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsConstructSignatureDeclaration;
      }
    });
    Object.defineProperty(exports, "TSConstructorType", {
      enumerable: true,
      get: function() {
        return _index.tsConstructorType;
      }
    });
    Object.defineProperty(exports, "TSDeclareFunction", {
      enumerable: true,
      get: function() {
        return _index.tsDeclareFunction;
      }
    });
    Object.defineProperty(exports, "TSDeclareMethod", {
      enumerable: true,
      get: function() {
        return _index.tsDeclareMethod;
      }
    });
    Object.defineProperty(exports, "TSEnumDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsEnumDeclaration;
      }
    });
    Object.defineProperty(exports, "TSEnumMember", {
      enumerable: true,
      get: function() {
        return _index.tsEnumMember;
      }
    });
    Object.defineProperty(exports, "TSExportAssignment", {
      enumerable: true,
      get: function() {
        return _index.tsExportAssignment;
      }
    });
    Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
      enumerable: true,
      get: function() {
        return _index.tsExpressionWithTypeArguments;
      }
    });
    Object.defineProperty(exports, "TSExternalModuleReference", {
      enumerable: true,
      get: function() {
        return _index.tsExternalModuleReference;
      }
    });
    Object.defineProperty(exports, "TSFunctionType", {
      enumerable: true,
      get: function() {
        return _index.tsFunctionType;
      }
    });
    Object.defineProperty(exports, "TSImportEqualsDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsImportEqualsDeclaration;
      }
    });
    Object.defineProperty(exports, "TSImportType", {
      enumerable: true,
      get: function() {
        return _index.tsImportType;
      }
    });
    Object.defineProperty(exports, "TSIndexSignature", {
      enumerable: true,
      get: function() {
        return _index.tsIndexSignature;
      }
    });
    Object.defineProperty(exports, "TSIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.tsIndexedAccessType;
      }
    });
    Object.defineProperty(exports, "TSInferType", {
      enumerable: true,
      get: function() {
        return _index.tsInferType;
      }
    });
    Object.defineProperty(exports, "TSInstantiationExpression", {
      enumerable: true,
      get: function() {
        return _index.tsInstantiationExpression;
      }
    });
    Object.defineProperty(exports, "TSInterfaceBody", {
      enumerable: true,
      get: function() {
        return _index.tsInterfaceBody;
      }
    });
    Object.defineProperty(exports, "TSInterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsInterfaceDeclaration;
      }
    });
    Object.defineProperty(exports, "TSIntersectionType", {
      enumerable: true,
      get: function() {
        return _index.tsIntersectionType;
      }
    });
    Object.defineProperty(exports, "TSIntrinsicKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsIntrinsicKeyword;
      }
    });
    Object.defineProperty(exports, "TSLiteralType", {
      enumerable: true,
      get: function() {
        return _index.tsLiteralType;
      }
    });
    Object.defineProperty(exports, "TSMappedType", {
      enumerable: true,
      get: function() {
        return _index.tsMappedType;
      }
    });
    Object.defineProperty(exports, "TSMethodSignature", {
      enumerable: true,
      get: function() {
        return _index.tsMethodSignature;
      }
    });
    Object.defineProperty(exports, "TSModuleBlock", {
      enumerable: true,
      get: function() {
        return _index.tsModuleBlock;
      }
    });
    Object.defineProperty(exports, "TSModuleDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsModuleDeclaration;
      }
    });
    Object.defineProperty(exports, "TSNamedTupleMember", {
      enumerable: true,
      get: function() {
        return _index.tsNamedTupleMember;
      }
    });
    Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsNamespaceExportDeclaration;
      }
    });
    Object.defineProperty(exports, "TSNeverKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNeverKeyword;
      }
    });
    Object.defineProperty(exports, "TSNonNullExpression", {
      enumerable: true,
      get: function() {
        return _index.tsNonNullExpression;
      }
    });
    Object.defineProperty(exports, "TSNullKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNullKeyword;
      }
    });
    Object.defineProperty(exports, "TSNumberKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNumberKeyword;
      }
    });
    Object.defineProperty(exports, "TSObjectKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsObjectKeyword;
      }
    });
    Object.defineProperty(exports, "TSOptionalType", {
      enumerable: true,
      get: function() {
        return _index.tsOptionalType;
      }
    });
    Object.defineProperty(exports, "TSParameterProperty", {
      enumerable: true,
      get: function() {
        return _index.tsParameterProperty;
      }
    });
    Object.defineProperty(exports, "TSParenthesizedType", {
      enumerable: true,
      get: function() {
        return _index.tsParenthesizedType;
      }
    });
    Object.defineProperty(exports, "TSPropertySignature", {
      enumerable: true,
      get: function() {
        return _index.tsPropertySignature;
      }
    });
    Object.defineProperty(exports, "TSQualifiedName", {
      enumerable: true,
      get: function() {
        return _index.tsQualifiedName;
      }
    });
    Object.defineProperty(exports, "TSRestType", {
      enumerable: true,
      get: function() {
        return _index.tsRestType;
      }
    });
    Object.defineProperty(exports, "TSSatisfiesExpression", {
      enumerable: true,
      get: function() {
        return _index.tsSatisfiesExpression;
      }
    });
    Object.defineProperty(exports, "TSStringKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsStringKeyword;
      }
    });
    Object.defineProperty(exports, "TSSymbolKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsSymbolKeyword;
      }
    });
    Object.defineProperty(exports, "TSThisType", {
      enumerable: true,
      get: function() {
        return _index.tsThisType;
      }
    });
    Object.defineProperty(exports, "TSTupleType", {
      enumerable: true,
      get: function() {
        return _index.tsTupleType;
      }
    });
    Object.defineProperty(exports, "TSTypeAliasDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAliasDeclaration;
      }
    });
    Object.defineProperty(exports, "TSTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TSTypeAssertion", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAssertion;
      }
    });
    Object.defineProperty(exports, "TSTypeLiteral", {
      enumerable: true,
      get: function() {
        return _index.tsTypeLiteral;
      }
    });
    Object.defineProperty(exports, "TSTypeOperator", {
      enumerable: true,
      get: function() {
        return _index.tsTypeOperator;
      }
    });
    Object.defineProperty(exports, "TSTypeParameter", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameter;
      }
    });
    Object.defineProperty(exports, "TSTypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameterDeclaration;
      }
    });
    Object.defineProperty(exports, "TSTypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameterInstantiation;
      }
    });
    Object.defineProperty(exports, "TSTypePredicate", {
      enumerable: true,
      get: function() {
        return _index.tsTypePredicate;
      }
    });
    Object.defineProperty(exports, "TSTypeQuery", {
      enumerable: true,
      get: function() {
        return _index.tsTypeQuery;
      }
    });
    Object.defineProperty(exports, "TSTypeReference", {
      enumerable: true,
      get: function() {
        return _index.tsTypeReference;
      }
    });
    Object.defineProperty(exports, "TSUndefinedKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsUndefinedKeyword;
      }
    });
    Object.defineProperty(exports, "TSUnionType", {
      enumerable: true,
      get: function() {
        return _index.tsUnionType;
      }
    });
    Object.defineProperty(exports, "TSUnknownKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsUnknownKeyword;
      }
    });
    Object.defineProperty(exports, "TSVoidKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsVoidKeyword;
      }
    });
    Object.defineProperty(exports, "TaggedTemplateExpression", {
      enumerable: true,
      get: function() {
        return _index.taggedTemplateExpression;
      }
    });
    Object.defineProperty(exports, "TemplateElement", {
      enumerable: true,
      get: function() {
        return _index.templateElement;
      }
    });
    Object.defineProperty(exports, "TemplateLiteral", {
      enumerable: true,
      get: function() {
        return _index.templateLiteral;
      }
    });
    Object.defineProperty(exports, "ThisExpression", {
      enumerable: true,
      get: function() {
        return _index.thisExpression;
      }
    });
    Object.defineProperty(exports, "ThisTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.thisTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ThrowStatement", {
      enumerable: true,
      get: function() {
        return _index.throwStatement;
      }
    });
    Object.defineProperty(exports, "TopicReference", {
      enumerable: true,
      get: function() {
        return _index.topicReference;
      }
    });
    Object.defineProperty(exports, "TryStatement", {
      enumerable: true,
      get: function() {
        return _index.tryStatement;
      }
    });
    Object.defineProperty(exports, "TupleExpression", {
      enumerable: true,
      get: function() {
        return _index.tupleExpression;
      }
    });
    Object.defineProperty(exports, "TupleTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.tupleTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TypeAlias", {
      enumerable: true,
      get: function() {
        return _index.typeAlias;
      }
    });
    Object.defineProperty(exports, "TypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.typeAnnotation;
      }
    });
    Object.defineProperty(exports, "TypeCastExpression", {
      enumerable: true,
      get: function() {
        return _index.typeCastExpression;
      }
    });
    Object.defineProperty(exports, "TypeParameter", {
      enumerable: true,
      get: function() {
        return _index.typeParameter;
      }
    });
    Object.defineProperty(exports, "TypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _index.typeParameterDeclaration;
      }
    });
    Object.defineProperty(exports, "TypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _index.typeParameterInstantiation;
      }
    });
    Object.defineProperty(exports, "TypeofTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.typeofTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "UnaryExpression", {
      enumerable: true,
      get: function() {
        return _index.unaryExpression;
      }
    });
    Object.defineProperty(exports, "UnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.unionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "UpdateExpression", {
      enumerable: true,
      get: function() {
        return _index.updateExpression;
      }
    });
    Object.defineProperty(exports, "V8IntrinsicIdentifier", {
      enumerable: true,
      get: function() {
        return _index.v8IntrinsicIdentifier;
      }
    });
    Object.defineProperty(exports, "VariableDeclaration", {
      enumerable: true,
      get: function() {
        return _index.variableDeclaration;
      }
    });
    Object.defineProperty(exports, "VariableDeclarator", {
      enumerable: true,
      get: function() {
        return _index.variableDeclarator;
      }
    });
    Object.defineProperty(exports, "Variance", {
      enumerable: true,
      get: function() {
        return _index.variance;
      }
    });
    Object.defineProperty(exports, "VoidTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.voidTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "WhileStatement", {
      enumerable: true,
      get: function() {
        return _index.whileStatement;
      }
    });
    Object.defineProperty(exports, "WithStatement", {
      enumerable: true,
      get: function() {
        return _index.withStatement;
      }
    });
    Object.defineProperty(exports, "YieldExpression", {
      enumerable: true,
      get: function() {
        return _index.yieldExpression;
      }
    });
    var _index = require_generated2();
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/productions.js
var require_productions = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/builders/productions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildUndefinedNode = buildUndefinedNode;
    var _index = require_generated2();
    function buildUndefinedNode() {
      return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/clone/cloneNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneNode;
    var _index = require_definitions();
    var _index2 = require_generated();
    var has3 = Function.call.bind(Object.prototype.hasOwnProperty);
    function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
      if (obj && typeof obj.type === "string") {
        return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
      }
      return obj;
    }
    function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
      if (Array.isArray(obj)) {
        return obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache));
      }
      return cloneIfNode(obj, deep, withoutLoc, commentsCache);
    }
    function cloneNode(node, deep = true, withoutLoc = false) {
      return cloneNodeInternal(node, deep, withoutLoc, /* @__PURE__ */ new Map());
    }
    function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
      if (!node)
        return node;
      const {
        type: type3
      } = node;
      const newNode = {
        type: node.type
      };
      if ((0, _index2.isIdentifier)(node)) {
        newNode.name = node.name;
        if (has3(node, "optional") && typeof node.optional === "boolean") {
          newNode.optional = node.optional;
        }
        if (has3(node, "typeAnnotation")) {
          newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
        }
      } else if (!has3(_index.NODE_FIELDS, type3)) {
        throw new Error(`Unknown node type: "${type3}"`);
      } else {
        for (const field of Object.keys(_index.NODE_FIELDS[type3])) {
          if (has3(node, field)) {
            if (deep) {
              newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
            } else {
              newNode[field] = node[field];
            }
          }
        }
      }
      if (has3(node, "loc")) {
        if (withoutLoc) {
          newNode.loc = null;
        } else {
          newNode.loc = node.loc;
        }
      }
      if (has3(node, "leadingComments")) {
        newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
      }
      if (has3(node, "innerComments")) {
        newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
      }
      if (has3(node, "trailingComments")) {
        newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
      }
      if (has3(node, "extra")) {
        newNode.extra = Object.assign({}, node.extra);
      }
      return newNode;
    }
    function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
      if (!comments || !deep) {
        return comments;
      }
      return comments.map((comment) => {
        const cache = commentsCache.get(comment);
        if (cache)
          return cache;
        const {
          type: type3,
          value: value2,
          loc
        } = comment;
        const ret = {
          type: type3,
          value: value2,
          loc
        };
        if (withoutLoc) {
          ret.loc = null;
        }
        commentsCache.set(comment, ret);
        return ret;
      });
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/clone/clone.js
var require_clone = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/clone/clone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = clone3;
    var _cloneNode = require_cloneNode();
    function clone3(node) {
      return (0, _cloneNode.default)(node, false);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/clone/cloneDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneDeep;
    var _cloneNode = require_cloneNode();
    function cloneDeep(node) {
      return (0, _cloneNode.default)(node);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneDeepWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneDeepWithoutLoc(node) {
      return (0, _cloneNode.default)(node, true, true);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneWithoutLoc(node) {
      return (0, _cloneNode.default)(node, false, true);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/addComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addComments;
    function addComments(node, type3, comments) {
      if (!comments || !node)
        return node;
      const key = `${type3}Comments`;
      if (node[key]) {
        if (type3 === "leading") {
          node[key] = comments.concat(node[key]);
        } else {
          node[key].push(...comments);
        }
      } else {
        node[key] = comments;
      }
      return node;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/addComment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addComment2;
    var _addComments = require_addComments();
    function addComment2(node, type3, content, line) {
      return (0, _addComments.default)(node, type3, [{
        type: line ? "CommentLine" : "CommentBlock",
        value: content
      }]);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/utils/inherit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inherit;
    function inherit(key, child, parent) {
      if (child && parent) {
        child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
      }
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/inheritInnerComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritInnerComments;
    var _inherit = require_inherit();
    function inheritInnerComments(child, parent) {
      (0, _inherit.default)("innerComments", child, parent);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritLeadingComments;
    var _inherit = require_inherit();
    function inheritLeadingComments(child, parent) {
      (0, _inherit.default)("leadingComments", child, parent);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritTrailingComments;
    var _inherit = require_inherit();
    function inheritTrailingComments(child, parent) {
      (0, _inherit.default)("trailingComments", child, parent);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/inheritsComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritsComments;
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritInnerComments = require_inheritInnerComments();
    function inheritsComments(child, parent) {
      (0, _inheritTrailingComments.default)(child, parent);
      (0, _inheritLeadingComments.default)(child, parent);
      (0, _inheritInnerComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/comments/removeComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeComments;
    var _index = require_constants();
    function removeComments(node) {
      _index.COMMENT_KEYS.forEach((key) => {
        node[key] = null;
      });
      return node;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/constants/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;
    var _index = require_definitions();
    var STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
    exports.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
    var EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
    exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
    var BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
    exports.BINARY_TYPES = BINARY_TYPES;
    var SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
    exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
    var BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
    exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
    var BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
    exports.BLOCK_TYPES = BLOCK_TYPES;
    var STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
    exports.STATEMENT_TYPES = STATEMENT_TYPES;
    var TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
    exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
    var COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
    exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
    var CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
    exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
    var LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
    exports.LOOP_TYPES = LOOP_TYPES;
    var WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
    exports.WHILE_TYPES = WHILE_TYPES;
    var EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
    var FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
    exports.FOR_TYPES = FOR_TYPES;
    var FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
    exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
    var FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
    exports.FUNCTION_TYPES = FUNCTION_TYPES;
    var FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
    exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
    var PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
    exports.PUREISH_TYPES = PUREISH_TYPES;
    var DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
    exports.DECLARATION_TYPES = DECLARATION_TYPES;
    var PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
    exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
    var LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
    exports.LVAL_TYPES = LVAL_TYPES;
    var TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
    exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
    var LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
    exports.LITERAL_TYPES = LITERAL_TYPES;
    var IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
    exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
    var USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
    var METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
    exports.METHOD_TYPES = METHOD_TYPES;
    var OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
    exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
    var PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
    exports.PROPERTY_TYPES = PROPERTY_TYPES;
    var UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
    exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
    var PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
    exports.PATTERN_TYPES = PATTERN_TYPES;
    var CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
    exports.CLASS_TYPES = CLASS_TYPES;
    var IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
    exports.IMPORTOREXPORTDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
    var EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
    var MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
    var ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
    exports.ACCESSOR_TYPES = ACCESSOR_TYPES;
    var PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
    exports.PRIVATE_TYPES = PRIVATE_TYPES;
    var FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
    exports.FLOW_TYPES = FLOW_TYPES;
    var FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
    exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
    var FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
    var FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
    var FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
    exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
    var ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
    exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
    var ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
    exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
    var JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
    exports.JSX_TYPES = JSX_TYPES;
    var MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
    exports.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
    var TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
    exports.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
    var TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
    exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
    var TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
    exports.TSTYPE_TYPES = TSTYPE_TYPES;
    var TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
    exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
    var MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
    exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toBlock;
    var _index = require_generated();
    var _index2 = require_generated2();
    function toBlock(node, parent) {
      if ((0, _index.isBlockStatement)(node)) {
        return node;
      }
      let blockNodes = [];
      if ((0, _index.isEmptyStatement)(node)) {
        blockNodes = [];
      } else {
        if (!(0, _index.isStatement)(node)) {
          if ((0, _index.isFunction)(parent)) {
            node = (0, _index2.returnStatement)(node);
          } else {
            node = (0, _index2.expressionStatement)(node);
          }
        }
        blockNodes = [node];
      }
      return (0, _index2.blockStatement)(blockNodes);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/ensureBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = ensureBlock;
    var _toBlock = require_toBlock();
    function ensureBlock(node, key = "body") {
      const result = (0, _toBlock.default)(node[key], node);
      node[key] = result;
      return result;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toIdentifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib();
    function toIdentifier(input) {
      input = input + "";
      let name = "";
      for (const c of input) {
        name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
      }
      name = name.replace(/^[-0-9]+/, "");
      name = name.replace(/[-\s]+(.)?/g, function(match3, c) {
        return c ? c.toUpperCase() : "";
      });
      if (!(0, _isValidIdentifier.default)(name)) {
        name = `_${name}`;
      }
      return name || "_";
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toBindingIdentifierName;
    var _toIdentifier = require_toIdentifier();
    function toBindingIdentifierName(name) {
      name = (0, _toIdentifier.default)(name);
      if (name === "eval" || name === "arguments")
        name = "_" + name;
      return name;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toComputedKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toComputedKey;
    var _index = require_generated();
    var _index2 = require_generated2();
    function toComputedKey(node, key = node.key || node.property) {
      if (!node.computed && (0, _index.isIdentifier)(key))
        key = (0, _index2.stringLiteral)(key.name);
      return key;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = require_generated();
    var _default = toExpression;
    exports.default = _default;
    function toExpression(node) {
      if ((0, _index.isExpressionStatement)(node)) {
        node = node.expression;
      }
      if ((0, _index.isExpression)(node)) {
        return node;
      }
      if ((0, _index.isClass)(node)) {
        node.type = "ClassExpression";
      } else if ((0, _index.isFunction)(node)) {
        node.type = "FunctionExpression";
      }
      if (!(0, _index.isExpression)(node)) {
        throw new Error(`cannot turn ${node.type} to an expression`);
      }
      return node;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/traverse/traverseFast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = traverseFast;
    var _index = require_definitions();
    function traverseFast(node, enter, opts) {
      if (!node)
        return;
      const keys4 = _index.VISITOR_KEYS[node.type];
      if (!keys4)
        return;
      opts = opts || {};
      enter(node, opts);
      for (const key of keys4) {
        const subNode = node[key];
        if (Array.isArray(subNode)) {
          for (const node2 of subNode) {
            traverseFast(node2, enter, opts);
          }
        } else {
          traverseFast(subNode, enter, opts);
        }
      }
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/removeProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeProperties;
    var _index = require_constants();
    var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    var CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
    function removeProperties(node, opts = {}) {
      const map4 = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      for (const key of map4) {
        if (node[key] != null)
          node[key] = void 0;
      }
      for (const key of Object.keys(node)) {
        if (key[0] === "_" && node[key] != null)
          node[key] = void 0;
      }
      const symbols = Object.getOwnPropertySymbols(node);
      for (const sym of symbols) {
        node[sym] = null;
      }
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removePropertiesDeep;
    var _traverseFast = require_traverseFast();
    var _removeProperties = require_removeProperties();
    function removePropertiesDeep(tree, opts) {
      (0, _traverseFast.default)(tree, _removeProperties.default, opts);
      return tree;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toKeyAlias.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toKeyAlias;
    var _index = require_generated();
    var _cloneNode = require_cloneNode();
    var _removePropertiesDeep = require_removePropertiesDeep();
    function toKeyAlias(node, key = node.key) {
      let alias;
      if (node.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if ((0, _index.isIdentifier)(key)) {
        alias = key.name;
      } else if ((0, _index.isStringLiteral)(key)) {
        alias = JSON.stringify(key.value);
      } else {
        alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
      }
      if (node.computed) {
        alias = `[${alias}]`;
      }
      if (node.static) {
        alias = `static:${alias}`;
      }
      return alias;
    }
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function() {
      if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
      } else {
        return toKeyAlias.uid++;
      }
    };
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getBindingIdentifiers;
    var _index = require_generated();
    function getBindingIdentifiers(node, duplicates, outerOnly) {
      const search = [].concat(node);
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id = search.shift();
        if (!id)
          continue;
        const keys4 = getBindingIdentifiers.keys[id.type];
        if ((0, _index.isIdentifier)(id)) {
          if (duplicates) {
            const _ids = ids[id.name] = ids[id.name] || [];
            _ids.push(id);
          } else {
            ids[id.name] = id;
          }
          continue;
        }
        if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
          if ((0, _index.isDeclaration)(id.declaration)) {
            search.push(id.declaration);
          }
          continue;
        }
        if (outerOnly) {
          if ((0, _index.isFunctionDeclaration)(id)) {
            search.push(id.id);
            continue;
          }
          if ((0, _index.isFunctionExpression)(id)) {
            continue;
          }
        }
        if (keys4) {
          for (let i = 0; i < keys4.length; i++) {
            const key = keys4[i];
            const nodes = id[key];
            if (nodes) {
              Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
            }
          }
        }
      }
      return ids;
    }
    getBindingIdentifiers.keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      DeclareInterface: ["id"],
      DeclareTypeAlias: ["id"],
      DeclareOpaqueType: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ArrowFunctionExpression: ["params"],
      ObjectMethod: ["params"],
      ClassMethod: ["params"],
      ClassPrivateMethod: ["params"],
      ForInStatement: ["left"],
      ForOfStatement: ["left"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = gatherSequenceExpressions;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _index = require_generated();
    var _index2 = require_generated2();
    var _cloneNode = require_cloneNode();
    function gatherSequenceExpressions(nodes, scope, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node of nodes) {
        if (!(0, _index.isEmptyStatement)(node)) {
          ensureLastUndefined = false;
        }
        if ((0, _index.isExpression)(node)) {
          exprs.push(node);
        } else if ((0, _index.isExpressionStatement)(node)) {
          exprs.push(node.expression);
        } else if ((0, _index.isVariableDeclaration)(node)) {
          if (node.kind !== "var")
            return;
          for (const declar of node.declarations) {
            const bindings = (0, _getBindingIdentifiers.default)(declar);
            for (const key of Object.keys(bindings)) {
              declars.push({
                kind: node.kind,
                id: (0, _cloneNode.default)(bindings[key])
              });
            }
            if (declar.init) {
              exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if ((0, _index.isIfStatement)(node)) {
          const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
          const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
          if (!consequent || !alternate)
            return;
          exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _index.isBlockStatement)(node)) {
          const body = gatherSequenceExpressions(node.body, scope, declars);
          if (!body)
            return;
          exprs.push(body);
        } else if ((0, _index.isEmptyStatement)(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) {
        exprs.push(scope.buildUndefinedNode());
      }
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return (0, _index2.sequenceExpression)(exprs);
      }
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toSequenceExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toSequenceExpression;
    var _gatherSequenceExpressions = require_gatherSequenceExpressions();
    function toSequenceExpression(nodes, scope) {
      if (!(nodes != null && nodes.length))
        return;
      const declars = [];
      const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
      if (!result)
        return;
      for (const declar of declars) {
        scope.push(declar);
      }
      return result;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/toStatement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = require_generated();
    var _index2 = require_generated2();
    var _default = toStatement;
    exports.default = _default;
    function toStatement(node, ignore) {
      if ((0, _index.isStatement)(node)) {
        return node;
      }
      let mustHaveId = false;
      let newType;
      if ((0, _index.isClass)(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if ((0, _index.isFunction)(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if ((0, _index.isAssignmentExpression)(node)) {
        return (0, _index2.expressionStatement)(node);
      }
      if (mustHaveId && !node.id) {
        newType = false;
      }
      if (!newType) {
        if (ignore) {
          return false;
        } else {
          throw new Error(`cannot turn ${node.type} to a statement`);
        }
      }
      node.type = newType;
      return node;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/converters/valueToNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _isValidIdentifier = require_isValidIdentifier();
    var _index = require_generated2();
    var _default = valueToNode;
    exports.default = _default;
    var objectToString = Function.call.bind(Object.prototype.toString);
    function isRegExp(value2) {
      return objectToString(value2) === "[object RegExp]";
    }
    function isPlainObject(value2) {
      if (typeof value2 !== "object" || value2 === null || Object.prototype.toString.call(value2) !== "[object Object]") {
        return false;
      }
      const proto = Object.getPrototypeOf(value2);
      return proto === null || Object.getPrototypeOf(proto) === null;
    }
    function valueToNode(value2) {
      if (value2 === void 0) {
        return (0, _index.identifier)("undefined");
      }
      if (value2 === true || value2 === false) {
        return (0, _index.booleanLiteral)(value2);
      }
      if (value2 === null) {
        return (0, _index.nullLiteral)();
      }
      if (typeof value2 === "string") {
        return (0, _index.stringLiteral)(value2);
      }
      if (typeof value2 === "number") {
        let result;
        if (Number.isFinite(value2)) {
          result = (0, _index.numericLiteral)(Math.abs(value2));
        } else {
          let numerator;
          if (Number.isNaN(value2)) {
            numerator = (0, _index.numericLiteral)(0);
          } else {
            numerator = (0, _index.numericLiteral)(1);
          }
          result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
        }
        if (value2 < 0 || Object.is(value2, -0)) {
          result = (0, _index.unaryExpression)("-", result);
        }
        return result;
      }
      if (isRegExp(value2)) {
        const pattern = value2.source;
        const flags = value2.toString().match(/\/([a-z]+|)$/)[1];
        return (0, _index.regExpLiteral)(pattern, flags);
      }
      if (Array.isArray(value2)) {
        return (0, _index.arrayExpression)(value2.map(valueToNode));
      }
      if (isPlainObject(value2)) {
        const props3 = [];
        for (const key of Object.keys(value2)) {
          let nodeKey;
          if ((0, _isValidIdentifier.default)(key)) {
            nodeKey = (0, _index.identifier)(key);
          } else {
            nodeKey = (0, _index.stringLiteral)(key);
          }
          props3.push((0, _index.objectProperty)(nodeKey, valueToNode(value2[key])));
        }
        return (0, _index.objectExpression)(props3);
      }
      throw new Error("don't know how to turn this value into a node");
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = appendToMemberExpression;
    var _index = require_generated2();
    function appendToMemberExpression(member, append3, computed = false) {
      member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
      member.property = append3;
      member.computed = !!computed;
      return member;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/inherits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inherits;
    var _index = require_constants();
    var _inheritsComments = require_inheritsComments();
    function inherits(child, parent) {
      if (!child || !parent)
        return child;
      for (const key of _index.INHERIT_KEYS.optional) {
        if (child[key] == null) {
          child[key] = parent[key];
        }
      }
      for (const key of Object.keys(parent)) {
        if (key[0] === "_" && key !== "__clone") {
          child[key] = parent[key];
        }
      }
      for (const key of _index.INHERIT_KEYS.force) {
        child[key] = parent[key];
      }
      (0, _inheritsComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = prependToMemberExpression;
    var _index = require_generated2();
    var _index2 = require_lib5();
    function prependToMemberExpression(member, prepend3) {
      if ((0, _index2.isSuper)(member.object)) {
        throw new Error("Cannot prepend node to super property access (`super.foo`).");
      }
      member.object = (0, _index.memberExpression)(prepend3, member.object);
      return member;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _default = getOuterBindingIdentifiers;
    exports.default = _default;
    function getOuterBindingIdentifiers(node, duplicates) {
      return (0, _getBindingIdentifiers.default)(node, duplicates, true);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/traverse/traverse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = traverse3;
    var _index = require_definitions();
    function traverse3(node, handlers, state) {
      if (typeof handlers === "function") {
        handlers = {
          enter: handlers
        };
      }
      const {
        enter,
        exit
      } = handlers;
      traverseSimpleImpl(node, enter, exit, state, []);
    }
    function traverseSimpleImpl(node, enter, exit, state, ancestors) {
      const keys4 = _index.VISITOR_KEYS[node.type];
      if (!keys4)
        return;
      if (enter)
        enter(node, ancestors, state);
      for (const key of keys4) {
        const subNode = node[key];
        if (Array.isArray(subNode)) {
          for (let i = 0; i < subNode.length; i++) {
            const child = subNode[i];
            if (!child)
              continue;
            ancestors.push({
              node,
              key,
              index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
          }
        } else if (subNode) {
          ancestors.push({
            node,
            key
          });
          traverseSimpleImpl(subNode, enter, exit, state, ancestors);
          ancestors.pop();
        }
      }
      if (exit)
        exit(node, ancestors, state);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isBinding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBinding;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    function isBinding(node, parent, grandparent) {
      if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
        return false;
      }
      const keys4 = _getBindingIdentifiers.default.keys[parent.type];
      if (keys4) {
        for (let i = 0; i < keys4.length; i++) {
          const key = keys4[i];
          const val = parent[key];
          if (Array.isArray(val)) {
            if (val.indexOf(node) >= 0)
              return true;
          } else {
            if (val === node)
              return true;
          }
        }
      }
      return false;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isLet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLet;
    var _index = require_generated();
    var _index2 = require_constants();
    function isLet(node) {
      return (0, _index.isVariableDeclaration)(node) && (node.kind !== "var" || node[_index2.BLOCK_SCOPED_SYMBOL]);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isBlockScoped.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBlockScoped;
    var _index = require_generated();
    var _isLet = require_isLet();
    function isBlockScoped(node) {
      return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isImmutable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isImmutable;
    var _isType = require_isType();
    var _index = require_generated();
    function isImmutable(node) {
      if ((0, _isType.default)(node.type, "Immutable"))
        return true;
      if ((0, _index.isIdentifier)(node)) {
        if (node.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isNodesEquivalent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNodesEquivalent;
    var _index = require_definitions();
    function isNodesEquivalent(a, b) {
      if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
        return a === b;
      }
      if (a.type !== b.type) {
        return false;
      }
      const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
      const visitorKeys = _index.VISITOR_KEYS[a.type];
      for (const field of fields) {
        const val_a = a[field];
        const val_b = b[field];
        if (typeof val_a !== typeof val_b) {
          return false;
        }
        if (val_a == null && val_b == null) {
          continue;
        } else if (val_a == null || val_b == null) {
          return false;
        }
        if (Array.isArray(val_a)) {
          if (!Array.isArray(val_b)) {
            return false;
          }
          if (val_a.length !== val_b.length) {
            return false;
          }
          for (let i = 0; i < val_a.length; i++) {
            if (!isNodesEquivalent(val_a[i], val_b[i])) {
              return false;
            }
          }
          continue;
        }
        if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
          for (const key of Object.keys(val_a)) {
            if (val_a[key] !== val_b[key]) {
              return false;
            }
          }
          continue;
        }
        if (!isNodesEquivalent(val_a, val_b)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isReferenced.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isReferenced;
    function isReferenced(node, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node) {
            return !!parent.computed;
          }
          return parent.object === node;
        case "JSXMemberExpression":
          return parent.object === node;
        case "VariableDeclarator":
          return parent.init === node;
        case "ArrowFunctionExpression":
          return parent.body === node;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return false;
        case "ObjectProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
        case "ClassAccessorProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
        case "ClassPrivateProperty":
          return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node;
        case "AssignmentExpression":
          return parent.right === node;
        case "AssignmentPattern":
          return parent.right === node;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          if (grandparent != null && grandparent.source) {
            return false;
          }
          return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ImportAttribute":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent.key !== node;
        case "TSEnumMember":
          return parent.id !== node;
        case "TSPropertySignature":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
      }
      return true;
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isScope;
    var _index = require_generated();
    function isScope(node, parent) {
      if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
        return false;
      }
      if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
        return true;
      }
      return (0, _index.isScopable)(node);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isSpecifierDefault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isSpecifierDefault;
    var _index = require_generated();
    function isSpecifierDefault(specifier) {
      return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
      });
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isValidES3Identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValidES3Identifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
    function isValidES3Identifier(name) {
      return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/validators/isVar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isVar;
    var _index = require_generated();
    var _index2 = require_constants();
    function isVar(node) {
      return (0, _index.isVariableDeclaration)(node, {
        kind: "var"
      }) && !node[_index2.BLOCK_SCOPED_SYMBOL];
    }
  }
});

// node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/.pnpm/@babel+types@7.23.0/node_modules/@babel/types/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toSequenceExpression: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
      __internal__deprecationWarning: true
    };
    Object.defineProperty(exports, "__internal__deprecationWarning", {
      enumerable: true,
      get: function() {
        return _deprecationWarning.default;
      }
    });
    Object.defineProperty(exports, "addComment", {
      enumerable: true,
      get: function() {
        return _addComment.default;
      }
    });
    Object.defineProperty(exports, "addComments", {
      enumerable: true,
      get: function() {
        return _addComments.default;
      }
    });
    Object.defineProperty(exports, "appendToMemberExpression", {
      enumerable: true,
      get: function() {
        return _appendToMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "assertNode", {
      enumerable: true,
      get: function() {
        return _assertNode.default;
      }
    });
    Object.defineProperty(exports, "buildMatchMemberExpression", {
      enumerable: true,
      get: function() {
        return _buildMatchMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "clone", {
      enumerable: true,
      get: function() {
        return _clone2.default;
      }
    });
    Object.defineProperty(exports, "cloneDeep", {
      enumerable: true,
      get: function() {
        return _cloneDeep.default;
      }
    });
    Object.defineProperty(exports, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneDeepWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "cloneNode", {
      enumerable: true,
      get: function() {
        return _cloneNode.default;
      }
    });
    Object.defineProperty(exports, "cloneWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "createFlowUnionType", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTSUnionType", {
      enumerable: true,
      get: function() {
        return _createTSUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
      }
    });
    Object.defineProperty(exports, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "ensureBlock", {
      enumerable: true,
      get: function() {
        return _ensureBlock.default;
      }
    });
    Object.defineProperty(exports, "getBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getOuterBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "inheritInnerComments", {
      enumerable: true,
      get: function() {
        return _inheritInnerComments.default;
      }
    });
    Object.defineProperty(exports, "inheritLeadingComments", {
      enumerable: true,
      get: function() {
        return _inheritLeadingComments.default;
      }
    });
    Object.defineProperty(exports, "inheritTrailingComments", {
      enumerable: true,
      get: function() {
        return _inheritTrailingComments.default;
      }
    });
    Object.defineProperty(exports, "inherits", {
      enumerable: true,
      get: function() {
        return _inherits2.default;
      }
    });
    Object.defineProperty(exports, "inheritsComments", {
      enumerable: true,
      get: function() {
        return _inheritsComments.default;
      }
    });
    Object.defineProperty(exports, "is", {
      enumerable: true,
      get: function() {
        return _is.default;
      }
    });
    Object.defineProperty(exports, "isBinding", {
      enumerable: true,
      get: function() {
        return _isBinding.default;
      }
    });
    Object.defineProperty(exports, "isBlockScoped", {
      enumerable: true,
      get: function() {
        return _isBlockScoped.default;
      }
    });
    Object.defineProperty(exports, "isImmutable", {
      enumerable: true,
      get: function() {
        return _isImmutable.default;
      }
    });
    Object.defineProperty(exports, "isLet", {
      enumerable: true,
      get: function() {
        return _isLet.default;
      }
    });
    Object.defineProperty(exports, "isNode", {
      enumerable: true,
      get: function() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports, "isNodesEquivalent", {
      enumerable: true,
      get: function() {
        return _isNodesEquivalent.default;
      }
    });
    Object.defineProperty(exports, "isPlaceholderType", {
      enumerable: true,
      get: function() {
        return _isPlaceholderType.default;
      }
    });
    Object.defineProperty(exports, "isReferenced", {
      enumerable: true,
      get: function() {
        return _isReferenced.default;
      }
    });
    Object.defineProperty(exports, "isScope", {
      enumerable: true,
      get: function() {
        return _isScope.default;
      }
    });
    Object.defineProperty(exports, "isSpecifierDefault", {
      enumerable: true,
      get: function() {
        return _isSpecifierDefault.default;
      }
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function() {
        return _isType.default;
      }
    });
    Object.defineProperty(exports, "isValidES3Identifier", {
      enumerable: true,
      get: function() {
        return _isValidES3Identifier.default;
      }
    });
    Object.defineProperty(exports, "isValidIdentifier", {
      enumerable: true,
      get: function() {
        return _isValidIdentifier.default;
      }
    });
    Object.defineProperty(exports, "isVar", {
      enumerable: true,
      get: function() {
        return _isVar.default;
      }
    });
    Object.defineProperty(exports, "matchesPattern", {
      enumerable: true,
      get: function() {
        return _matchesPattern.default;
      }
    });
    Object.defineProperty(exports, "prependToMemberExpression", {
      enumerable: true,
      get: function() {
        return _prependToMemberExpression.default;
      }
    });
    exports.react = void 0;
    Object.defineProperty(exports, "removeComments", {
      enumerable: true,
      get: function() {
        return _removeComments.default;
      }
    });
    Object.defineProperty(exports, "removeProperties", {
      enumerable: true,
      get: function() {
        return _removeProperties.default;
      }
    });
    Object.defineProperty(exports, "removePropertiesDeep", {
      enumerable: true,
      get: function() {
        return _removePropertiesDeep.default;
      }
    });
    Object.defineProperty(exports, "removeTypeDuplicates", {
      enumerable: true,
      get: function() {
        return _removeTypeDuplicates.default;
      }
    });
    Object.defineProperty(exports, "shallowEqual", {
      enumerable: true,
      get: function() {
        return _shallowEqual.default;
      }
    });
    Object.defineProperty(exports, "toBindingIdentifierName", {
      enumerable: true,
      get: function() {
        return _toBindingIdentifierName.default;
      }
    });
    Object.defineProperty(exports, "toBlock", {
      enumerable: true,
      get: function() {
        return _toBlock.default;
      }
    });
    Object.defineProperty(exports, "toComputedKey", {
      enumerable: true,
      get: function() {
        return _toComputedKey.default;
      }
    });
    Object.defineProperty(exports, "toExpression", {
      enumerable: true,
      get: function() {
        return _toExpression.default;
      }
    });
    Object.defineProperty(exports, "toIdentifier", {
      enumerable: true,
      get: function() {
        return _toIdentifier.default;
      }
    });
    Object.defineProperty(exports, "toKeyAlias", {
      enumerable: true,
      get: function() {
        return _toKeyAlias.default;
      }
    });
    Object.defineProperty(exports, "toSequenceExpression", {
      enumerable: true,
      get: function() {
        return _toSequenceExpression.default;
      }
    });
    Object.defineProperty(exports, "toStatement", {
      enumerable: true,
      get: function() {
        return _toStatement.default;
      }
    });
    Object.defineProperty(exports, "traverse", {
      enumerable: true,
      get: function() {
        return _traverse.default;
      }
    });
    Object.defineProperty(exports, "traverseFast", {
      enumerable: true,
      get: function() {
        return _traverseFast.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "valueToNode", {
      enumerable: true,
      get: function() {
        return _valueToNode.default;
      }
    });
    var _isReactComponent = require_isReactComponent();
    var _isCompatTag = require_isCompatTag();
    var _buildChildren = require_buildChildren();
    var _assertNode = require_assertNode();
    var _index = require_generated3();
    Object.keys(_index).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = require_createFlowUnionType();
    var _createTSUnionType = require_createTSUnionType();
    var _index2 = require_generated2();
    Object.keys(_index2).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index2[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index2[key];
        }
      });
    });
    var _uppercase = require_uppercase();
    Object.keys(_uppercase).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _uppercase[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _uppercase[key];
        }
      });
    });
    var _productions = require_productions();
    Object.keys(_productions).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _productions[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _productions[key];
        }
      });
    });
    var _cloneNode = require_cloneNode();
    var _clone2 = require_clone();
    var _cloneDeep = require_cloneDeep();
    var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
    var _cloneWithoutLoc = require_cloneWithoutLoc();
    var _addComment = require_addComment();
    var _addComments = require_addComments();
    var _inheritInnerComments = require_inheritInnerComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritsComments = require_inheritsComments();
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _removeComments = require_removeComments();
    var _index3 = require_generated4();
    Object.keys(_index3).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index3[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index3[key];
        }
      });
    });
    var _index4 = require_constants();
    Object.keys(_index4).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index4[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index4[key];
        }
      });
    });
    var _ensureBlock = require_ensureBlock();
    var _toBindingIdentifierName = require_toBindingIdentifierName();
    var _toBlock = require_toBlock();
    var _toComputedKey = require_toComputedKey();
    var _toExpression = require_toExpression();
    var _toIdentifier = require_toIdentifier();
    var _toKeyAlias = require_toKeyAlias();
    var _toSequenceExpression = require_toSequenceExpression();
    var _toStatement = require_toStatement();
    var _valueToNode = require_valueToNode();
    var _index5 = require_definitions();
    Object.keys(_index5).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index5[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index5[key];
        }
      });
    });
    var _appendToMemberExpression = require_appendToMemberExpression();
    var _inherits2 = require_inherits();
    var _prependToMemberExpression = require_prependToMemberExpression();
    var _removeProperties = require_removeProperties();
    var _removePropertiesDeep = require_removePropertiesDeep();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
    var _traverse = require_traverse();
    Object.keys(_traverse).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _traverse[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _traverse[key];
        }
      });
    });
    var _traverseFast = require_traverseFast();
    var _shallowEqual = require_shallowEqual();
    var _is = require_is();
    var _isBinding = require_isBinding();
    var _isBlockScoped = require_isBlockScoped();
    var _isImmutable = require_isImmutable();
    var _isLet = require_isLet();
    var _isNode = require_isNode();
    var _isNodesEquivalent = require_isNodesEquivalent();
    var _isPlaceholderType = require_isPlaceholderType();
    var _isReferenced = require_isReferenced();
    var _isScope = require_isScope();
    var _isSpecifierDefault = require_isSpecifierDefault();
    var _isType = require_isType();
    var _isValidES3Identifier = require_isValidES3Identifier();
    var _isValidIdentifier = require_isValidIdentifier();
    var _isVar = require_isVar();
    var _matchesPattern = require_matchesPattern();
    var _validate = require_validate2();
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var _index6 = require_generated();
    Object.keys(_index6).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index6[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index6[key];
        }
      });
    });
    var _deprecationWarning = require_deprecationWarning();
    var react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default
    };
    exports.react = react;
  }
});

// node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/icu.js
var require_icu = __commonJS({
  "node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/icu.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _types = require_lib5();
    var metaOptions = ["id", "comment", "props"];
    var escapedMetaOptionsRe = new RegExp(`^_(${metaOptions.join("|")})$`);
    var ICUMessageFormat = class {
      fromTokens(tokens) {
        return (Array.isArray(tokens) ? tokens : [tokens]).map((token) => this.processToken(token)).filter(Boolean).reduce((props3, message) => ({
          ...message,
          message: props3.message + message.message,
          values: {
            ...props3.values,
            ...message.values
          },
          jsxElements: {
            ...props3.jsxElements,
            ...message.jsxElements
          }
        }), {
          message: "",
          values: {},
          jsxElements: {}
        });
      }
      processToken(token) {
        const jsxElements = {};
        if (token.type === "text") {
          return {
            message: token.value
          };
        } else if (token.type === "arg") {
          if (token.value !== void 0 && (0, _types.isJSXEmptyExpression)(token.value)) {
            return null;
          }
          const values3 = token.value !== void 0 ? {
            [token.name]: token.value
          } : {};
          switch (token.format) {
            case "plural":
            case "select":
            case "selectordinal":
              const formatOptions = Object.keys(token.options).filter((key) => token.options[key] != null).map((key) => {
                let value2 = token.options[key];
                key = key.replace(escapedMetaOptionsRe, "$1");
                if (key === "offset") {
                  return `offset:${value2}`;
                }
                if (typeof value2 !== "string") {
                  const {
                    message,
                    values: childValues,
                    jsxElements: childJsxElements
                  } = this.fromTokens(value2);
                  Object.assign(values3, childValues);
                  Object.assign(jsxElements, childJsxElements);
                  value2 = message;
                }
                return `${key} {${value2}}`;
              }).join(" ");
              return {
                message: `{${token.name}, ${token.format}, ${formatOptions}}`,
                values: values3,
                jsxElements
              };
            default:
              return {
                message: `{${token.name}}`,
                values: values3
              };
          }
        } else if (token.type === "element") {
          let message = "";
          let elementValues = {};
          Object.assign(jsxElements, {
            [token.name]: token.value
          });
          token.children.forEach((child) => {
            const {
              message: childMessage,
              values: childValues,
              jsxElements: childJsxElements
            } = this.fromTokens(child);
            message += childMessage;
            Object.assign(elementValues, childValues);
            Object.assign(jsxElements, childJsxElements);
          });
          return {
            message: token.children.length ? `<${token.name}>${message}</${token.name}>` : `<${token.name}/>`,
            values: elementValues,
            jsxElements
          };
        }
        throw new Error(`Unknown token type ${token.type}`);
      }
    };
    exports.default = ICUMessageFormat;
  }
});

// node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.makeCounter = void 0;
    exports.zip = zip3;
    var R = _interopRequireWildcard((init_es2(), __toCommonJS(es_exports2)));
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function zip3(a, b) {
      return R.range(0, Math.max(a.length, b.length)).map((index) => [a[index], b[index]]);
    }
    var makeCounter = (index = 0) => () => index++;
    exports.makeCounter = makeCounter;
  }
});

// node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MESSAGE = exports.ID = exports.EXTRACT_MARK = exports.CONTEXT = exports.COMMENT = void 0;
    var ID = "id";
    exports.ID = ID;
    var MESSAGE = "message";
    exports.MESSAGE = MESSAGE;
    var COMMENT = "comment";
    exports.COMMENT = COMMENT;
    var EXTRACT_MARK = "i18n";
    exports.EXTRACT_MARK = EXTRACT_MARK;
    var CONTEXT = "context";
    exports.CONTEXT = CONTEXT;
  }
});

// node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/macroJs.js
var require_macroJs = __commonJS({
  "node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/macroJs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var R = _interopRequireWildcard((init_es2(), __toCommonJS(es_exports2)));
    var _types = require_lib5();
    var _icu = _interopRequireDefault(require_icu());
    var _utils = require_utils3();
    var _constants = require_constants2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var keepSpaceRe = /(?:\\(?:\r\n|\r|\n))+\s+/g;
    var keepNewLineRe = /(?:\r\n|\r|\n)+\s+/g;
    function normalizeWhitespace(text) {
      return text.replace(keepSpaceRe, " ").replace(keepNewLineRe, "\n").trim();
    }
    var MacroJs = class {
      constructor({
        types
      }, {
        i18nImportName
      }) {
        // Babel Types
        // Identifier of i18n object
        // Positional expressions counter (e.g. for placeholders `Hello {0}, today is {1}`)
        __publicField(this, "_expressionIndex", (0, _utils.makeCounter)());
        __publicField(this, "replacePathWithMessage", (path3, {
          message,
          values: values3
        }, linguiInstance) => {
          const args = [];
          args.push(isString(message) ? this.types.stringLiteral(message) : message);
          if (Object.keys(values3).length) {
            const valuesObject = Object.keys(values3).map((key) => this.types.objectProperty(this.types.identifier(key), values3[key]));
            args.push(this.types.objectExpression(valuesObject));
          }
          const newNode = this.types.callExpression(this.types.memberExpression(linguiInstance ?? this.types.identifier(this.i18nImportName), this.types.identifier("_")), args);
          newNode.loc = path3.node.loc;
          path3.addComment("leading", _constants.EXTRACT_MARK);
          path3.replaceWith(newNode);
        });
        // Returns a boolean indicating if the replacement requires i18n import
        __publicField(this, "replacePath", (path3) => {
          this._expressionIndex = (0, _utils.makeCounter)();
          if (this.isDefineMessage(path3.node)) {
            this.replaceDefineMessage(path3);
            return true;
          }
          if (this.types.isCallExpression(path3.node) && this.types.isTaggedTemplateExpression(path3.parentPath.node) && this.types.isIdentifier(path3.node.arguments[0]) && this.isIdentifier(path3.node.callee, "t")) {
            const i18nInstance = path3.node.arguments[0];
            const tokens2 = this.tokenizeNode(path3.parentPath.node);
            const messageFormat2 = new _icu.default();
            const {
              message: messageRaw2,
              values: values4
            } = messageFormat2.fromTokens(tokens2);
            const message2 = normalizeWhitespace(messageRaw2);
            this.replacePathWithMessage(path3.parentPath, {
              message: message2,
              values: values4
            }, i18nInstance);
            return false;
          }
          if (this.types.isCallExpression(path3.node) && this.types.isCallExpression(path3.parentPath.node) && this.types.isIdentifier(path3.node.arguments[0]) && this.isIdentifier(path3.node.callee, "t")) {
            const i18nInstance = path3.node.arguments[0];
            this.replaceTAsFunction(path3.parentPath, i18nInstance);
            return false;
          }
          if (this.types.isCallExpression(path3.node) && this.isIdentifier(path3.node.callee, "t")) {
            this.replaceTAsFunction(path3);
            return true;
          }
          const tokens = this.tokenizeNode(path3.node);
          const messageFormat = new _icu.default();
          const {
            message: messageRaw,
            values: values3
          } = messageFormat.fromTokens(tokens);
          const message = normalizeWhitespace(messageRaw);
          this.replacePathWithMessage(path3, {
            message,
            values: values3
          });
          return true;
        });
        /**
         * macro `defineMessage` is called with MessageDescriptor. The only
         * thing that happens is that any macros used in `message` property
         * are replaced with formatted message.
         *
         * import { defineMessage, plural } from '@lingui/macro';
         * const message = defineMessage({
         *   id: "msg.id",
         *   comment: "Description",
         *   message: plural(value, { one: "book", other: "books" })
         * })
         *
         * ↓ ↓ ↓ ↓ ↓ ↓
         *
         * const message = {
         *   id: "msg.id",
         *   comment: "Description",
         *   message: "{value, plural, one {book} other {books}}"
         * }
         *
         */
        __publicField(this, "replaceDefineMessage", (path3) => {
          this._expressionIndex = (0, _utils.makeCounter)();
          let descriptor = this.processDescriptor(path3.node.arguments[0]);
          path3.replaceWith(descriptor);
        });
        /**
         * macro `t` is called with MessageDescriptor, after that
         * we create a new node to append it to i18n._
         */
        __publicField(this, "replaceTAsFunction", (path3, linguiInstance) => {
          let descriptor = this.processDescriptor(path3.node.arguments[0]);
          const newNode = this.types.callExpression(this.types.memberExpression(linguiInstance ?? this.types.identifier(this.i18nImportName), this.types.identifier("_")), [descriptor]);
          path3.replaceWith(newNode);
        });
        /**
         * `processDescriptor` expand macros inside message descriptor.
         * Message descriptor is used in `defineMessage`.
         *
         * {
         *   comment: "Description",
         *   message: plural("value", { one: "book", other: "books" })
         * }
         *
         * ↓ ↓ ↓ ↓ ↓ ↓
         *
         * {
         *   comment: "Description",
         *   id: "{value, plural, one {book} other {books}}"
         * }
         *
         */
        __publicField(this, "processDescriptor", (descriptor_) => {
          const descriptor = descriptor_;
          this.types.addComment(descriptor, "leading", _constants.EXTRACT_MARK);
          const messageIndex = descriptor.properties.findIndex((property) => (0, _types.isObjectProperty)(property) && this.isIdentifier(property.key, _constants.MESSAGE));
          if (messageIndex === -1) {
            return descriptor;
          }
          const node = descriptor.properties[messageIndex];
          const tokens = this.types.isTemplateLiteral(node.value) ? this.tokenizeTemplateLiteral(node.value) : this.tokenizeNode(node.value, true);
          let messageNode = node.value;
          if (tokens != null) {
            const messageFormat = new _icu.default();
            const {
              message: messageRaw,
              values: values3
            } = messageFormat.fromTokens(tokens);
            const message = normalizeWhitespace(messageRaw);
            messageNode = this.types.stringLiteral(message);
            this.addValues(descriptor.properties, values3);
          }
          const hasId = descriptor.properties.findIndex((property) => (0, _types.isObjectProperty)(property) && this.isIdentifier(property.key, _constants.ID)) !== -1;
          descriptor.properties[messageIndex] = this.types.objectProperty(this.types.identifier(hasId ? _constants.MESSAGE : _constants.ID), messageNode);
          if (false) {
            descriptor.properties = descriptor.properties.filter((property) => (0, _types.isObjectProperty)(property) && !this.isIdentifier(property.key, _constants.MESSAGE) && (0, _types.isObjectProperty)(property) && !this.isIdentifier(property.key, _constants.COMMENT));
          }
          return descriptor;
        });
        __publicField(this, "addValues", (obj, values3) => {
          const valuesObject = Object.keys(values3).map((key) => this.types.objectProperty(this.types.identifier(key), values3[key]));
          if (!valuesObject.length)
            return;
          obj.push(this.types.objectProperty(this.types.identifier("values"), this.types.objectExpression(valuesObject)));
        });
        __publicField(this, "tokenizeNode", (node, ignoreExpression = false) => {
          if (this.isI18nMethod(node)) {
            return this.tokenizeTemplateLiteral(node);
          } else if (this.isChoiceMethod(node)) {
            return [this.tokenizeChoiceComponent(node)];
          } else if (!ignoreExpression) {
            return this.tokenizeExpression(node);
          }
        });
        /**
         * `node` is a TemplateLiteral. node.quasi contains
         * text chunks and node.expressions contains expressions.
         * Both arrays must be zipped together to get the final list of tokens.
         */
        __publicField(this, "tokenizeTemplateLiteral", (node) => {
          const tokenize = R.pipe(R.evolve({
            quasis: R.map((text) => {
              const value2 = /\\u[a-fA-F0-9]{4}|\\x[a-fA-F0-9]{2}/g.test(text.value.raw) ? text.value.cooked : text.value.raw;
              if (value2 === "")
                return null;
              return {
                type: "text",
                value: this.clearBackslashes(value2)
              };
            }),
            expressions: R.map((exp) => this.types.isCallExpression(exp) ? this.tokenizeNode(exp) : this.tokenizeExpression(exp))
          }), (exp) => (0, _utils.zip)(exp.quasis, exp.expressions), R.flatten, R.filter(Boolean));
          return tokenize(this.types.isTaggedTemplateExpression(node) ? node.quasi : node);
        });
        __publicField(this, "tokenizeChoiceComponent", (node) => {
          const format = node.callee.name.toLowerCase();
          const token = {
            ...this.tokenizeExpression(node.arguments[0]),
            format,
            options: {
              offset: void 0
            }
          };
          const props3 = node.arguments[1].properties;
          for (const attr of props3) {
            const {
              key,
              value: attrValue
            } = attr;
            const name = this.types.isNumericLiteral(key) ? `=${key.value}` : key.name || key.value;
            if (format !== "select" && name === "offset") {
              token.options.offset = attrValue.value;
            } else {
              let value2;
              if (this.types.isTemplateLiteral(attrValue)) {
                value2 = this.tokenizeTemplateLiteral(attrValue);
              } else if (this.types.isCallExpression(attrValue)) {
                value2 = this.tokenizeNode(attrValue);
              } else {
                value2 = attrValue.value;
              }
              token.options[name] = value2;
            }
          }
          return token;
        });
        __publicField(this, "tokenizeExpression", (node) => {
          if (this.isArg(node) && this.types.isCallExpression(node)) {
            return {
              type: "arg",
              name: node.arguments[0].value,
              value: void 0
            };
          }
          return {
            type: "arg",
            name: this.expressionToArgument(node),
            value: node
          };
        });
        __publicField(this, "expressionToArgument", (exp) => {
          if (this.types.isIdentifier(exp)) {
            return exp.name;
          } else if (this.types.isStringLiteral(exp)) {
            return exp.value;
          } else {
            return String(this._expressionIndex());
          }
        });
        /**
         * Custom matchers
         */
        __publicField(this, "isIdentifier", (node, name) => {
          return this.types.isIdentifier(node, {
            name
          });
        });
        __publicField(this, "isDefineMessage", (node) => {
          return this.types.isCallExpression(node) && this.isIdentifier(node.callee, "defineMessage");
        });
        __publicField(this, "isArg", (node) => {
          return this.types.isCallExpression(node) && this.isIdentifier(node.callee, "arg");
        });
        __publicField(this, "isI18nMethod", (node) => {
          return this.types.isTaggedTemplateExpression(node) && (this.isIdentifier(node.tag, "t") || this.types.isCallExpression(node.tag) && this.isIdentifier(node.tag.callee, "t"));
        });
        __publicField(this, "isChoiceMethod", (node) => {
          return this.types.isCallExpression(node) && (this.isIdentifier(node.callee, "plural") || this.isIdentifier(node.callee, "select") || this.isIdentifier(node.callee, "selectOrdinal"));
        });
        this.types = types;
        this.i18nImportName = i18nImportName;
      }
      /**
       * We clean '//\` ' to just '`'
       */
      clearBackslashes(value2) {
        return value2.replace(/\\`/g, "`");
      }
    };
    exports.default = MacroJs;
    var isString = (s) => typeof s === "string";
  }
});

// node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/macroJsx.js
var require_macroJsx = __commonJS({
  "node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/macroJsx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.normalizeWhitespace = normalizeWhitespace;
    var R = _interopRequireWildcard((init_es2(), __toCommonJS(es_exports2)));
    var _icu = _interopRequireDefault(require_icu());
    var _utils = require_utils3();
    var _constants = require_constants2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var pluralRuleRe = /(_[\d\w]+|zero|one|two|few|many|other)/;
    var jsx2icuExactChoice = (value2) => value2.replace(/_(\d+)/, "=$1").replace(/_(\w+)/, "$1");
    var keepSpaceRe = /\s*(?:\r\n|\r|\n)+\s*/g;
    var stripAroundTagsRe = /(?:([>}])(?:\r\n|\r|\n)+\s*|(?:\r\n|\r|\n)+\s*(?=[<{]))/g;
    function maybeNodeValue(node) {
      if (!node)
        return null;
      if (node.type === "StringLiteral")
        return node.value;
      if (node.type === "JSXAttribute")
        return maybeNodeValue(node.value);
      if (node.type === "JSXExpressionContainer")
        return maybeNodeValue(node.expression);
      if (node.type === "TemplateLiteral" && node.expressions.length === 0)
        return node.quasis[0].value.raw;
      return null;
    }
    function normalizeWhitespace(text) {
      return text.replace(stripAroundTagsRe, "$1").replace(keepSpaceRe, " ").replace(/\\n/g, "\n").replace(/\\s/g, " ").replace(/(\s+})/gm, "}").trim();
    }
    var MacroJSX = class {
      constructor({
        types
      }) {
        __publicField(this, "expressionIndex", (0, _utils.makeCounter)());
        __publicField(this, "elementIndex", (0, _utils.makeCounter)());
        __publicField(this, "safeJsxAttribute", (name, value2) => {
          return this.types.jsxAttribute(this.types.jsxIdentifier(name), this.types.jsxExpressionContainer(this.types.stringLiteral(value2)));
        });
        __publicField(this, "replacePath", (path3) => {
          const tokens = this.tokenizeNode(path3.node);
          const messageFormat = new _icu.default();
          const {
            message: messageRaw,
            values: values3,
            jsxElements
          } = messageFormat.fromTokens(tokens);
          const message = normalizeWhitespace(messageRaw);
          const {
            attributes,
            id,
            comment,
            context
          } = this.stripMacroAttributes(path3.node);
          if (!id && !message) {
            return;
          } else if (id && id !== message) {
            attributes.push(this.types.jsxAttribute(this.types.jsxIdentifier(_constants.ID), this.types.stringLiteral(id)));
            if (true) {
              if (message) {
                attributes.push(this.safeJsxAttribute(_constants.MESSAGE, message));
              }
            }
          } else {
            attributes.push(this.safeJsxAttribute(_constants.ID, message));
          }
          if (true) {
            if (comment) {
              attributes.push(this.types.jsxAttribute(this.types.jsxIdentifier(_constants.COMMENT), this.types.stringLiteral(comment)));
            }
          }
          if (context) {
            attributes.push(this.types.jsxAttribute(this.types.jsxIdentifier(_constants.CONTEXT), this.types.stringLiteral(context)));
          }
          const valuesObject = Object.keys(values3).map((key) => this.types.objectProperty(this.types.identifier(key), values3[key]));
          if (valuesObject.length) {
            attributes.push(this.types.jsxAttribute(this.types.jsxIdentifier("values"), this.types.jsxExpressionContainer(this.types.objectExpression(valuesObject))));
          }
          if (Object.keys(jsxElements).length) {
            attributes.push(this.types.jsxAttribute(this.types.jsxIdentifier("components"), this.types.jsxExpressionContainer(this.types.objectExpression(Object.keys(jsxElements).map((key) => this.types.objectProperty(this.types.identifier(key), jsxElements[key]))))));
          }
          const newNode = this.types.jsxElement(
            this.types.jsxOpeningElement(
              this.types.jsxIdentifier("Trans"),
              attributes,
              /*selfClosing*/
              true
            ),
            /*closingElement*/
            null,
            /*children*/
            [],
            /*selfClosing*/
            true
          );
          newNode.loc = path3.node.loc;
          path3.replaceWith(newNode);
        });
        __publicField(this, "attrName", (names, exclude = false) => {
          const namesRe = new RegExp("^(" + names.join("|") + ")$");
          return (attr) => {
            const name = attr.name.name;
            return exclude ? !namesRe.test(name) : namesRe.test(name);
          };
        });
        __publicField(this, "stripMacroAttributes", (node) => {
          const {
            attributes
          } = node.openingElement;
          const id = attributes.filter(this.attrName([_constants.ID]))[0];
          const message = attributes.filter(this.attrName([_constants.MESSAGE]))[0];
          const comment = attributes.filter(this.attrName([_constants.COMMENT]))[0];
          const context = attributes.filter(this.attrName([_constants.CONTEXT]))[0];
          let reserved = [_constants.ID, _constants.MESSAGE, _constants.COMMENT, _constants.CONTEXT];
          if (this.isI18nComponent(node)) {
          } else if (this.isChoiceComponent(node)) {
            reserved = [...reserved, "_\\w+", "_\\d+", "zero", "one", "two", "few", "many", "other", "value", "offset"];
          }
          return {
            id: maybeNodeValue(id),
            message: maybeNodeValue(message),
            comment: maybeNodeValue(comment),
            context: maybeNodeValue(context),
            attributes: attributes.filter(this.attrName(reserved, true))
          };
        });
        __publicField(this, "tokenizeNode", (node) => {
          if (this.isI18nComponent(node)) {
            return this.tokenizeTrans(node);
          } else if (this.isChoiceComponent(node)) {
            return this.tokenizeChoiceComponent(node);
          } else if (this.types.isJSXElement(node)) {
            return this.tokenizeElement(node);
          } else {
            return this.tokenizeExpression(node);
          }
        });
        __publicField(this, "tokenizeTrans", (node) => {
          return R.flatten(node.children.map((child) => this.tokenizeChildren(child)).filter(Boolean));
        });
        __publicField(this, "tokenizeChildren", (node) => {
          if (this.types.isJSXExpressionContainer(node)) {
            const exp = node.expression;
            if (this.types.isStringLiteral(exp)) {
              return {
                type: "text",
                value: exp.value.replace(/\n/g, "\\n")
              };
            } else if (this.types.isTemplateLiteral(exp)) {
              const tokenize = R.pipe(
                // Don"t output tokens without text.
                R.evolve({
                  quasis: R.map((text) => {
                    const value2 = /\\u[a-fA-F0-9]{4}|\\x[a-fA-F0-9]{2}/g.test(text.value.raw) ? text.value.cooked : text.value.raw;
                    if (value2 === "")
                      return null;
                    return this.tokenizeText(this.clearBackslashes(value2));
                  }),
                  expressions: R.map((exp2) => this.types.isCallExpression(exp2) ? this.tokenizeNode(exp2) : this.tokenizeExpression(exp2))
                }),
                (exp2) => (0, _utils.zip)(exp2.quasis, exp2.expressions),
                R.flatten,
                R.filter(Boolean)
              );
              return tokenize(exp);
            } else if (this.types.isJSXElement(exp)) {
              return this.tokenizeNode(exp);
            } else {
              return this.tokenizeExpression(exp);
            }
          } else if (this.types.isJSXElement(node)) {
            return this.tokenizeNode(node);
          } else if (this.types.isJSXSpreadChild(node)) {
          } else if (this.types.isJSXText(node)) {
            return this.tokenizeText(node.value);
          } else {
          }
        });
        __publicField(this, "tokenizeChoiceComponent", (node) => {
          const element = node.openingElement;
          const format = this.getJsxTagName(node).toLowerCase();
          const props3 = element.attributes.filter(this.attrName([
            _constants.ID,
            _constants.COMMENT,
            _constants.MESSAGE,
            _constants.CONTEXT,
            "key",
            // we remove <Trans /> react props that are not useful for translation
            "render",
            "component",
            "components"
          ], true));
          const token = {
            type: "arg",
            format,
            name: null,
            value: void 0,
            options: {
              offset: void 0
            }
          };
          for (const attr of props3) {
            if (this.types.isJSXSpreadAttribute(attr)) {
              continue;
            }
            if (this.types.isJSXNamespacedName(attr.name)) {
              continue;
            }
            const name = attr.name.name;
            if (name === "value") {
              const exp = this.types.isLiteral(attr.value) ? attr.value : attr.value.expression;
              token.name = this.expressionToArgument(exp);
              token.value = exp;
            } else if (format !== "select" && name === "offset") {
              token.options.offset = this.types.isStringLiteral(attr.value) ? attr.value.value : attr.value.expression.value;
            } else {
              let value2;
              if (this.types.isStringLiteral(attr.value)) {
                value2 = attr.value.extra.raw.replace(/(["'])(.*)\1/, "$2");
              } else {
                value2 = this.tokenizeChildren(attr.value);
              }
              if (pluralRuleRe.test(name)) {
                token.options[jsx2icuExactChoice(name)] = value2;
              } else {
                token.options[name] = value2;
              }
            }
          }
          return token;
        });
        __publicField(this, "tokenizeElement", (node) => {
          const name = this.elementIndex();
          const children = R.flatten(node.children.map((child) => this.tokenizeChildren(child)).filter(Boolean));
          node.children = [];
          node.openingElement.selfClosing = true;
          return {
            type: "element",
            name,
            value: node,
            children
          };
        });
        __publicField(this, "tokenizeExpression", (node) => {
          return {
            type: "arg",
            name: this.expressionToArgument(node),
            value: node
          };
        });
        __publicField(this, "tokenizeText", (value2) => {
          return {
            type: "text",
            value: value2
          };
        });
        /**
         * Custom matchers
         */
        __publicField(this, "isIdentifier", (node, name) => {
          return this.types.isIdentifier(node, {
            name
          });
        });
        __publicField(this, "isI18nComponent", (node, name = "Trans") => {
          return this.types.isJSXElement(node) && this.types.isJSXIdentifier(node.openingElement.name, {
            name
          });
        });
        __publicField(this, "isChoiceComponent", (node) => {
          return this.isI18nComponent(node, "Plural") || this.isI18nComponent(node, "Select") || this.isI18nComponent(node, "SelectOrdinal");
        });
        __publicField(this, "getJsxTagName", (node) => {
          if (this.types.isJSXIdentifier(node.openingElement.name)) {
            return node.openingElement.name.name;
          }
        });
        this.types = types;
      }
      expressionToArgument(exp) {
        return this.types.isIdentifier(exp) ? exp.name : String(this.expressionIndex());
      }
      /**
       * We clean '//\` ' to just '`'
       **/
      clearBackslashes(value2) {
        return value2.replace(/\\`/g, "`");
      }
    };
    exports.default = MacroJSX;
  }
});

// node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/index.js
var require_build6 = __commonJS({
  "node_modules/.pnpm/@lingui+macro@3.17.2_bbsmhjhvsgu55io3oxp256shay/node_modules/@lingui/macro/build/index.js"(exports, module) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _babelPluginMacros = require_dist2();
    var _conf = require_build5();
    var _macroJs = _interopRequireDefault(require_macroJs());
    var _macroJsx = _interopRequireDefault(require_macroJsx());
    var _types = require_lib5();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var config = (0, _conf.getConfig)({
      configPath: process.env.LINGUI_CONFIG
    });
    var getSymbolSource = (name) => {
      if (Array.isArray(config.runtimeConfigModule)) {
        if (name === "i18n") {
          return config.runtimeConfigModule;
        } else {
          return ["@lingui/react", name];
        }
      } else {
        if (config.runtimeConfigModule[name]) {
          return config.runtimeConfigModule[name];
        } else {
          return ["@lingui/react", name];
        }
      }
    };
    var [i18nImportModule, i18nImportName = "i18n"] = getSymbolSource("i18n");
    var [TransImportModule, TransImportName = "Trans"] = getSymbolSource("Trans");
    var jsMacroTags = /* @__PURE__ */ new Set(["defineMessage", "arg", "t", "plural", "select", "selectOrdinal"]);
    var jsxMacroTags = /* @__PURE__ */ new Set(["Trans", "Plural", "Select", "SelectOrdinal"]);
    function macro({
      references,
      state,
      babel
    }) {
      const jsxNodes = [];
      const jsNodes = [];
      let needsI18nImport = false;
      Object.keys(references).forEach((tagName) => {
        const nodes = references[tagName];
        if (jsMacroTags.has(tagName)) {
          nodes.forEach((node) => {
            jsNodes.push(node.parentPath);
          });
        } else if (jsxMacroTags.has(tagName)) {
          nodes.forEach((node) => {
            jsxNodes.push(node.parentPath.parentPath);
          });
        } else {
          throw nodes[0].buildCodeFrameError(`Unknown macro ${tagName}`);
        }
      });
      jsNodes.filter(isRootPath(jsNodes)).forEach((path3) => {
        if (alreadyVisited(path3))
          return;
        const macro2 = new _macroJs.default(babel, {
          i18nImportName
        });
        if (macro2.replacePath(path3))
          needsI18nImport = true;
      });
      jsxNodes.filter(isRootPath(jsxNodes)).forEach((path3) => {
        if (alreadyVisited(path3))
          return;
        const macro2 = new _macroJsx.default(babel);
        macro2.replacePath(path3);
      });
      if (needsI18nImport) {
        addImport(babel, state, i18nImportModule, i18nImportName);
      }
      if (jsxNodes.length) {
        addImport(babel, state, TransImportModule, TransImportName);
      }
      if (process.env.LINGUI_EXTRACT === "1") {
        return {
          keepImports: true
        };
      }
    }
    function addImport(babel, state, module2, importName) {
      const {
        types: t
      } = babel;
      const linguiImport = state.file.path.node.body.find((importNode) => t.isImportDeclaration(importNode) && importNode.source.value === module2 && // https://github.com/lingui/js-lingui/issues/777
      importNode.importKind !== "type");
      const tIdentifier = t.identifier(importName);
      if (linguiImport) {
        if (linguiImport.specifiers.findIndex((specifier) => (0, _types.isImportSpecifier)(specifier) && (0, _types.isIdentifier)(specifier.imported, {
          name: importName
        })) === -1) {
          linguiImport.specifiers.push(t.importSpecifier(tIdentifier, tIdentifier));
        }
      } else {
        state.file.path.node.body.unshift(t.importDeclaration([t.importSpecifier(tIdentifier, tIdentifier)], t.stringLiteral(module2)));
      }
    }
    function isRootPath(allPath) {
      return (node) => function traverse3(path3) {
        if (!path3.parentPath) {
          return true;
        } else {
          return !allPath.includes(path3.parentPath) && traverse3(path3.parentPath);
        }
      }(node);
    }
    var alreadyVisitedCache = /* @__PURE__ */ new WeakSet();
    var alreadyVisited = (path3) => {
      if (alreadyVisitedCache.has(path3)) {
        return true;
      } else {
        alreadyVisitedCache.add(path3);
        return false;
      }
    };
    [...jsMacroTags, ...jsxMacroTags].forEach((name) => {
      Object.defineProperty(module.exports, name, {
        get() {
          throw new Error(`The macro you imported from "@lingui/macro" is being executed outside the context of compilation with babel-plugin-macros. This indicates that you don't have the babel plugin "babel-plugin-macros" configured correctly. Please see the documentation for how to configure babel-plugin-macros properly: https://github.com/kentcdodds/babel-plugin-macros/blob/main/other/docs/user.md`);
        }
      });
    });
    var _default = (0, _babelPluginMacros.createMacro)(macro);
    exports.default = _default;
  }
});
export default require_build6();
/*! Bundled license information:

cosmiconfig/dist/util.js:
  (* istanbul ignore if -- @preserve *)

cosmiconfig/dist/ExplorerBase.js:
  (* istanbul ignore next -- @preserve *)

cosmiconfig/dist/loaders.js:
  (* istanbul ignore next -- @preserve *)

cosmiconfig/dist/Explorer.js:
  (* istanbul ignore if -- @preserve *)

cosmiconfig/dist/ExplorerSync.js:
  (* istanbul ignore if -- @preserve *)

react-is/cjs/react-is.development.js:
  (** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

diff/dist/diff.js:
  (*!
  
   diff v4.0.1
  
  Software License Agreement (BSD License)
  
  Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>
  
  All rights reserved.
  
  Redistribution and use of this software in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:
  
  * Redistributions of source code must retain the above
    copyright notice, this list of conditions and the
    following disclaimer.
  
  * Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the
    following disclaimer in the documentation and/or other
    materials provided with the distribution.
  
  * Neither the name of Kevin Decker nor the names of its
    contributors may be used to endorse or promote products
    derived from this software without specific prior
    written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  @license
  *)
*/
//# sourceMappingURL=@lingui_macro.js.map
