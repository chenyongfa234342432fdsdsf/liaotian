import {
  require_react_dom,
  require_scheduler
} from "./chunk-EWEJRCI4.js";
import {
  require_react
} from "./chunk-VMW3HQP3.js";
import {
  __toESM
} from "./chunk-Y7S7B2N7.js";

// node_modules/.pnpm/react-tracked@1.7.11_2szjah6qrhd6fr2kgr64p4pjgm/node_modules/react-tracked/dist/index.modern.js
var import_react2 = __toESM(require_react());

// node_modules/.pnpm/use-context-selector@1.4.1_2szjah6qrhd6fr2kgr64p4pjgm/node_modules/use-context-selector/dist/index.modern.js
var import_react = __toESM(require_react());
var import_scheduler = __toESM(require_scheduler());
var import_react_dom = __toESM(require_react_dom());
var d = Symbol();
var f = Symbol();
var v = "undefined" == typeof window || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent) ? import_react.useEffect : import_react.useLayoutEffect;
var a = import_scheduler.unstable_runWithPriority ? (e3) => (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_NormalPriority, e3) : (e3) => e3();
function E(r3) {
  const t3 = (0, import_react.createContext)({ [d]: { v: { current: r3 }, n: { current: -1 }, l: /* @__PURE__ */ new Set(), u: (e3) => e3() } });
  var o3;
  return t3[f] = t3.Provider, t3.Provider = (o3 = t3.Provider, ({ value: e3, children: r4 }) => {
    const t4 = (0, import_react.useRef)(e3), c3 = (0, import_react.useRef)(0), [i3, p3] = (0, import_react.useState)(null);
    i3 && (i3(e3), p3(null));
    const f3 = (0, import_react.useRef)();
    if (!f3.current) {
      const e4 = /* @__PURE__ */ new Set(), r5 = (r6, t5) => {
        (0, import_react_dom.unstable_batchedUpdates)(() => {
          c3.current += 1;
          const n3 = { n: c3.current };
          null != t5 && t5.suspense && (n3.n *= -1, n3.p = new Promise((e5) => {
            p3(() => (r7) => {
              n3.v = r7, delete n3.p, e5(r7);
            });
          })), e4.forEach((e5) => e5(n3)), r6();
        });
      };
      f3.current = { [d]: { v: t4, n: c3, l: e4, u: r5 } };
    }
    return v(() => {
      t4.current = e3, c3.current += 1, a(() => {
        f3.current[d].l.forEach((r5) => {
          r5({ n: c3.current, v: e3 });
        });
      });
    }, [e3]), (0, import_react.createElement)(o3, { value: f3.current }, r4);
  }), delete t3.Consumer, t3;
}
function h(e3, n3) {
  const o3 = (0, import_react.useContext)(e3)[d];
  if ("object" == typeof process && true && !o3)
    throw new Error("useContextSelector requires special context");
  const { v: { current: c3 }, n: { current: u3 }, l: s3 } = o3, i3 = n3(c3), [p3, l3] = (0, import_react.useReducer)((e4, r3) => {
    if (!r3)
      return [c3, i3];
    if ("p" in r3)
      throw r3.p;
    if (r3.n === u3)
      return Object.is(e4[1], i3) ? e4 : [c3, i3];
    try {
      if ("v" in r3) {
        if (Object.is(e4[0], r3.v))
          return e4;
        const t3 = n3(r3.v);
        return Object.is(e4[1], t3) ? e4 : [r3.v, t3];
      }
    } catch (e5) {
    }
    return [...e4];
  }, [c3, i3]);
  return Object.is(p3[1], i3) || l3(), v(() => (s3.add(l3), () => {
    s3.delete(l3);
  }), [s3]), p3[1];
}
function b(e3) {
  const t3 = (0, import_react.useContext)(e3)[d];
  if ("object" == typeof process && true && !t3)
    throw new Error("useContextUpdate requires special context");
  const { u: n3 } = t3;
  return n3;
}

// node_modules/.pnpm/proxy-compare@2.4.0/node_modules/proxy-compare/dist/index.modern.js
var e2 = Symbol();
var t2 = Symbol();
var r2 = "a";
var n2 = "w";
var o2 = (e3, t3) => new Proxy(e3, t3);
var s2 = Object.getPrototypeOf;
var c2 = /* @__PURE__ */ new WeakMap();
var l2 = (e3) => e3 && (c2.has(e3) ? c2.get(e3) : s2(e3) === Object.prototype || s2(e3) === Array.prototype);
var f2 = (e3) => "object" == typeof e3 && null !== e3;
var i2 = /* @__PURE__ */ new WeakMap();
var a2 = (e3) => e3[t2] || e3;
var u2 = (c3, f3, p3) => {
  if (!l2(c3))
    return c3;
  const y2 = a2(c3), g2 = ((e3) => Object.isFrozen(e3) || Object.values(Object.getOwnPropertyDescriptors(e3)).some((e4) => !e4.writable))(y2);
  let h2 = p3 && p3.get(y2);
  return h2 && h2[1].f === g2 || (h2 = ((o3, s3) => {
    const c4 = { f: s3 };
    let l3 = false;
    const f4 = (e3, t3) => {
      if (!l3) {
        let s4 = c4[r2].get(o3);
        if (s4 || (s4 = {}, c4[r2].set(o3, s4)), e3 === n2)
          s4[n2] = true;
        else {
          let r3 = s4[e3];
          r3 || (r3 = /* @__PURE__ */ new Set(), s4[e3] = r3), r3.add(t3);
        }
      }
    }, i3 = { get: (e3, n3) => n3 === t2 ? o3 : (f4("k", n3), u2(Reflect.get(e3, n3), c4[r2], c4.c)), has: (t3, n3) => n3 === e2 ? (l3 = true, c4[r2].delete(o3), true) : (f4("h", n3), Reflect.has(t3, n3)), getOwnPropertyDescriptor: (e3, t3) => (f4("o", t3), Reflect.getOwnPropertyDescriptor(e3, t3)), ownKeys: (e3) => (f4(n2), Reflect.ownKeys(e3)) };
    return s3 && (i3.set = i3.deleteProperty = () => false), [i3, c4];
  })(y2, g2), h2[1].p = o2(g2 ? ((e3) => {
    let t3 = i2.get(e3);
    if (!t3) {
      if (Array.isArray(e3))
        t3 = Array.from(e3);
      else {
        const r3 = Object.getOwnPropertyDescriptors(e3);
        Object.values(r3).forEach((e4) => {
          e4.configurable = true;
        }), t3 = Object.create(s2(e3), r3);
      }
      i2.set(e3, t3);
    }
    return t3;
  })(y2) : y2, h2[0]), p3 && p3.set(y2, h2)), h2[1][r2] = f3, h2[1].c = p3, h2[1].p;
};
var p2 = (e3, t3, r3, o3) => {
  if (Object.is(e3, t3))
    return false;
  if (!f2(e3) || !f2(t3))
    return true;
  const s3 = r3.get(a2(e3));
  if (!s3)
    return true;
  if (o3) {
    const r4 = o3.get(e3);
    if (r4 && r4.n === t3)
      return r4.g;
    o3.set(e3, { n: t3, g: false });
  }
  let c3 = null;
  try {
    for (const r4 of s3.h || [])
      if (c3 = Reflect.has(e3, r4) !== Reflect.has(t3, r4), c3)
        return c3;
    if (true === s3[n2]) {
      if (c3 = ((e4, t4) => {
        const r4 = Reflect.ownKeys(e4), n3 = Reflect.ownKeys(t4);
        return r4.length !== n3.length || r4.some((e5, t5) => e5 !== n3[t5]);
      })(e3, t3), c3)
        return c3;
    } else
      for (const r4 of s3.o || [])
        if (c3 = !!Reflect.getOwnPropertyDescriptor(e3, r4) != !!Reflect.getOwnPropertyDescriptor(t3, r4), c3)
          return c3;
    for (const n3 of s3.k || [])
      if (c3 = p2(e3[n3], t3[n3], r3, o3), c3)
        return c3;
    return null === c3 && (c3 = true), c3;
  } finally {
    o3 && o3.set(e3, { n: t3, g: c3 });
  }
};
var y = (t3) => !!l2(t3) && e2 in t3;
var g = (e3) => l2(e3) && e3[t2] || null;
var w = (e3, t3, r3) => {
  const o3 = [], s3 = /* @__PURE__ */ new WeakSet(), c3 = (e4, l3) => {
    if (s3.has(e4))
      return;
    f2(e4) && s3.add(e4);
    const i3 = f2(e4) && t3.get(a2(e4));
    if (i3) {
      var u3, p3;
      if (null == (u3 = i3.h) || u3.forEach((e5) => {
        const t4 = `:has(${String(e5)})`;
        o3.push(l3 ? [...l3, t4] : [t4]);
      }), true === i3[n2]) {
        const e5 = ":ownKeys";
        o3.push(l3 ? [...l3, e5] : [e5]);
      } else {
        var y2;
        null == (y2 = i3.o) || y2.forEach((e5) => {
          const t4 = `:hasOwn(${String(e5)})`;
          o3.push(l3 ? [...l3, t4] : [t4]);
        });
      }
      null == (p3 = i3.k) || p3.forEach((t4) => {
        r3 && !("value" in (Object.getOwnPropertyDescriptor(e4, t4) || {})) || c3(e4[t4], l3 ? [...l3, t4] : [t4]);
      });
    } else
      l3 && o3.push(l3);
  };
  return c3(e3), o3;
};

// node_modules/.pnpm/react-tracked@1.7.11_2szjah6qrhd6fr2kgr64p4pjgm/node_modules/react-tracked/dist/index.modern.js
var useAffectedDebugValue = (state, affected) => {
  const pathList = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(() => {
    pathList.current = w(state, affected);
  });
  (0, import_react2.useDebugValue)(state);
};
var createTrackedSelector = (useSelector) => {
  const useTrackedSelector = () => {
    const [, forceUpdate] = (0, import_react2.useReducer)((c3) => c3 + 1, 0);
    const affected = /* @__PURE__ */ new WeakMap();
    const lastAffected = (0, import_react2.useRef)();
    const prevState = (0, import_react2.useRef)();
    const lastState = (0, import_react2.useRef)();
    (0, import_react2.useEffect)(() => {
      lastAffected.current = affected;
      if (prevState.current !== lastState.current && p2(prevState.current, lastState.current, affected, /* @__PURE__ */ new WeakMap())) {
        prevState.current = lastState.current;
        forceUpdate();
      }
    });
    const selector = (0, import_react2.useCallback)((nextState) => {
      lastState.current = nextState;
      if (prevState.current && prevState.current !== nextState && lastAffected.current && !p2(prevState.current, nextState, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
        return prevState.current;
      }
      prevState.current = nextState;
      return nextState;
    }, []);
    const state = useSelector(selector);
    if (typeof process === "object" && true) {
      useAffectedDebugValue(state, affected);
    }
    const proxyCache = (0, import_react2.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
    return u2(state, affected, proxyCache);
  };
  return useTrackedSelector;
};
var createContainer = (useValue, options) => {
  var _options, _options2;
  if (typeof options === "boolean") {
    console.warn("boolean option is deprecated, please specify { concurrentMode: true }");
    options = {
      concurrentMode: options
    };
  }
  const {
    stateContextName = "StateContainer",
    updateContextName = "UpdateContainer",
    concurrentMode
  } = options || {};
  const StateContext = E((_options = options) == null ? void 0 : _options.defaultState);
  const UpdateContext = (0, import_react2.createContext)((_options2 = options) == null ? void 0 : _options2.defaultUpdate);
  StateContext.displayName = stateContextName;
  UpdateContext.displayName = updateContextName;
  const Provider = (props) => {
    const [state, update] = useValue(props);
    return (0, import_react2.createElement)(UpdateContext.Provider, {
      value: update
    }, (0, import_react2.createElement)(StateContext.Provider, {
      value: state
    }, props.children));
  };
  const useSelector = (selector) => {
    if (typeof process === "object" && true) {
      const selectorOrig = selector;
      selector = (state) => {
        if (state === void 0) {
          throw new Error("Please use <Provider>");
        }
        return selectorOrig(state);
      };
    }
    const selected = h(StateContext, selector);
    (0, import_react2.useDebugValue)(selected);
    return selected;
  };
  const useTrackedState = createTrackedSelector(useSelector);
  const useUpdate = concurrentMode ? () => {
    if (typeof process === "object" && true && (0, import_react2.useContext)(UpdateContext) === void 0) {
      throw new Error("Please use <Provider>");
    }
    const contextUpdate = b(StateContext);
    const update = (0, import_react2.useContext)(UpdateContext);
    return (0, import_react2.useCallback)((...args) => {
      let result;
      contextUpdate(() => {
        result = update(...args);
      });
      return result;
    }, [contextUpdate, update]);
  } : () => {
    if (typeof process === "object" && true && (0, import_react2.useContext)(UpdateContext) === void 0) {
      throw new Error("Please use <Provider>");
    }
    return (0, import_react2.useContext)(UpdateContext);
  };
  const useTracked = () => [useTrackedState(), useUpdate()];
  return {
    Provider,
    useTrackedState,
    useTracked,
    useUpdate,
    useSelector
  };
};
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function memo(Component, propsAreEqual) {
  const WrappedComponent = (0, import_react2.forwardRef)((props, ref) => {
    Object.values(props).forEach(y);
    return (0, import_react2.createElement)(Component, _extends({}, props, {
      ref
    }));
  });
  return (0, import_react2.memo)(WrappedComponent, propsAreEqual);
}
export {
  createContainer,
  createTrackedSelector,
  g as getUntrackedObject,
  memo
};
//# sourceMappingURL=react-tracked.js.map
