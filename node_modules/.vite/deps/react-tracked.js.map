{
  "version": 3,
  "sources": ["../../.pnpm/use-context-selector@1.4.1_2szjah6qrhd6fr2kgr64p4pjgm/node_modules/use-context-selector/src/index.ts", "../../.pnpm/proxy-compare@2.4.0/node_modules/proxy-compare/src/index.ts", "../../.pnpm/react-tracked@1.7.11_2szjah6qrhd6fr2kgr64p4pjgm/node_modules/react-tracked/src/utils.ts", "../../.pnpm/react-tracked@1.7.11_2szjah6qrhd6fr2kgr64p4pjgm/node_modules/react-tracked/src/createTrackedSelector.ts", "../../.pnpm/react-tracked@1.7.11_2szjah6qrhd6fr2kgr64p4pjgm/node_modules/react-tracked/src/createContainer.ts", "../../.pnpm/react-tracked@1.7.11_2szjah6qrhd6fr2kgr64p4pjgm/node_modules/react-tracked/src/memo.ts"],
  "sourcesContent": ["import {\n  ComponentType,\n  Context as ContextOrig,\n  MutableRefObject,\n  Provider,\n  ReactNode,\n  createElement,\n  createContext as createContextOrig,\n  useContext as useContextOrig,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport {\n  unstable_NormalPriority as NormalPriority,\n  unstable_runWithPriority as runWithPriority,\n} from 'scheduler';\n\nimport { batchedUpdates } from './batchedUpdates';\n\nconst CONTEXT_VALUE = Symbol();\nconst ORIGINAL_PROVIDER = Symbol();\n\nconst isSSR = typeof window === 'undefined'\n  || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent);\n\nconst useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect;\n\n// for preact that doesn't have runWithPriority\nconst runWithNormalPriority = runWithPriority\n  ? (thunk: () => void) => runWithPriority(NormalPriority, thunk)\n  : (thunk: () => void) => thunk();\n\ntype Version = number;\ntype Listener<Value> = (\n  action: { n: Version, p?: Promise<Value>, v?: Value }\n) => void\n\ntype ContextValue<Value> = {\n  [CONTEXT_VALUE]: {\n    /* \"v\"alue     */ v: MutableRefObject<Value>;\n    /* versio\"n\"   */ n: MutableRefObject<Version>;\n    /* \"l\"isteners */ l: Set<Listener<Value>>;\n    /* \"u\"pdate    */ u: (thunk: () => void, options?: { suspense: boolean }) => void;\n  };\n};\n\nexport interface Context<Value> {\n  Provider: ComponentType<{ value: Value; children: ReactNode }>;\n  displayName?: string;\n}\n\nconst createProvider = <Value>(\n  ProviderOrig: Provider<ContextValue<Value>>,\n) => {\n  const ContextProvider = ({ value, children }: { value: Value; children: ReactNode }) => {\n    const valueRef = useRef(value);\n    const versionRef = useRef(0);\n    const [resolve, setResolve] = useState<((v: Value) => void) | null>(null);\n    if (resolve) {\n      resolve(value);\n      setResolve(null);\n    }\n    const contextValue = useRef<ContextValue<Value>>();\n    if (!contextValue.current) {\n      const listeners = new Set<Listener<Value>>();\n      const update = (thunk: () => void, options?: { suspense: boolean }) => {\n        batchedUpdates(() => {\n          versionRef.current += 1;\n          const action: Parameters<Listener<Value>>[0] = {\n            n: versionRef.current,\n          };\n          if (options?.suspense) {\n            action.n *= -1; // this is intentional to make it temporary version\n            action.p = new Promise<Value>((r) => {\n              setResolve(() => (v: Value) => {\n                action.v = v;\n                delete action.p;\n                r(v);\n              });\n            });\n          }\n          listeners.forEach((listener) => listener(action));\n          thunk();\n        });\n      };\n      contextValue.current = {\n        [CONTEXT_VALUE]: {\n          /* \"v\"alue     */ v: valueRef,\n          /* versio\"n\"   */ n: versionRef,\n          /* \"l\"isteners */ l: listeners,\n          /* \"u\"pdate    */ u: update,\n        },\n      };\n    }\n    useIsomorphicLayoutEffect(() => {\n      valueRef.current = value;\n      versionRef.current += 1;\n      runWithNormalPriority(() => {\n        (contextValue.current as ContextValue<Value>)[CONTEXT_VALUE].l.forEach((listener) => {\n          listener({ n: versionRef.current, v: value });\n        });\n      });\n    }, [value]);\n    return createElement(ProviderOrig, { value: contextValue.current }, children);\n  };\n  return ContextProvider;\n};\n\nconst identity = <T>(x: T) => x;\n\n/**\n * This creates a special context for `useContextSelector`.\n *\n * @example\n * import { createContext } from 'use-context-selector';\n *\n * const PersonContext = createContext({ firstName: '', familyName: '' });\n */\nexport function createContext<Value>(defaultValue: Value) {\n  const context = createContextOrig<ContextValue<Value>>({\n    [CONTEXT_VALUE]: {\n      /* \"v\"alue     */ v: { current: defaultValue },\n      /* versio\"n\"   */ n: { current: -1 },\n      /* \"l\"isteners */ l: new Set(),\n      /* \"u\"pdate    */ u: (f) => f(),\n    },\n  });\n  (context as unknown as {\n    [ORIGINAL_PROVIDER]: Provider<ContextValue<Value>>;\n  })[ORIGINAL_PROVIDER] = context.Provider;\n  (context as unknown as Context<Value>).Provider = createProvider(context.Provider);\n  delete (context as any).Consumer; // no support for Consumer\n  return context as unknown as Context<Value>;\n}\n\n/**\n * This hook returns context selected value by selector.\n *\n * It will only accept context created by `createContext`.\n * It will trigger re-render if only the selected value is referentially changed.\n *\n * The selector should return referentially equal result for same input for better performance.\n *\n * @example\n * import { useContextSelector } from 'use-context-selector';\n *\n * const firstName = useContextSelector(PersonContext, state => state.firstName);\n */\nexport function useContextSelector<Value, Selected>(\n  context: Context<Value>,\n  selector: (value: Value) => Selected,\n) {\n  const contextValue = useContextOrig(\n    context as unknown as ContextOrig<ContextValue<Value>>,\n  )[CONTEXT_VALUE];\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    if (!contextValue) {\n      throw new Error('useContextSelector requires special context');\n    }\n  }\n  const {\n    /* \"v\"alue     */ v: { current: value },\n    /* versio\"n\"   */ n: { current: version },\n    /* \"l\"isteners */ l: listeners,\n  } = contextValue;\n  const selected = selector(value);\n  const [state, dispatch] = useReducer((\n    prev: readonly [Value, Selected],\n    action?: Parameters<Listener<Value>>[0],\n  ) => {\n    if (!action) {\n      // case for `dispatch()` below\n      return [value, selected] as const;\n    }\n    if ('p' in action) {\n      throw action.p;\n    }\n    if (action.n === version) {\n      if (Object.is(prev[1], selected)) {\n        return prev; // bail out\n      }\n      return [value, selected] as const;\n    }\n    try {\n      if ('v' in action) {\n        if (Object.is(prev[0], action.v)) {\n          return prev; // do not update\n        }\n        const nextSelected = selector(action.v);\n        if (Object.is(prev[1], nextSelected)) {\n          return prev; // do not update\n        }\n        return [action.v, nextSelected] as const;\n      }\n    } catch (e) {\n      // ignored (stale props or some other reason)\n    }\n    return [...prev] as const; // schedule update\n  }, [value, selected] as const);\n  if (!Object.is(state[1], selected)) {\n    // schedule re-render\n    // this is safe because it's self contained\n    dispatch();\n  }\n  useIsomorphicLayoutEffect(() => {\n    listeners.add(dispatch);\n    return () => {\n      listeners.delete(dispatch);\n    };\n  }, [listeners]);\n  return state[1];\n}\n\n/**\n * This hook returns the entire context value.\n * Use this instead of React.useContext for consistent behavior.\n *\n * @example\n * import { useContext } from 'use-context-selector';\n *\n * const person = useContext(PersonContext);\n */\nexport function useContext<Value>(context: Context<Value>) {\n  return useContextSelector(context, identity);\n}\n\n/**\n * This hook returns an update function that accepts a thunk function\n *\n * Use this for a function that will change a value in\n * concurrent rendering in React 18.\n * Otherwise, there's no need to use this hook.\n *\n * @example\n * import { useContextUpdate } from 'use-context-selector';\n *\n * const update = useContextUpdate();\n *\n * // Wrap set state function\n * update(() => setState(...));\n *\n * // Experimental suspense mode\n * update(() => setState(...), { suspense: true });\n */\nexport function useContextUpdate<Value>(context: Context<Value>) {\n  const contextValue = useContextOrig(\n    context as unknown as ContextOrig<ContextValue<Value>>,\n  )[CONTEXT_VALUE];\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    if (!contextValue) {\n      throw new Error('useContextUpdate requires special context');\n    }\n  }\n  const { u: update } = contextValue;\n  return update;\n}\n\n/**\n * This is a Provider component for bridging multiple react roots\n *\n * @example\n * const valueToBridge = useBridgeValue(PersonContext);\n * return (\n *   <Renderer>\n *     <BridgeProvider context={PersonContext} value={valueToBridge}>\n *       {children}\n *     </BridgeProvider>\n *   </Renderer>\n * );\n */\nexport const BridgeProvider = ({ context, value, children }:{\n  context: Context<any>;\n  value: any;\n  children: ReactNode;\n}) => {\n  const { [ORIGINAL_PROVIDER]: ProviderOrig } = context as unknown as {\n    [ORIGINAL_PROVIDER]: Provider<unknown>;\n  };\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    if (!ProviderOrig) {\n      throw new Error('BridgeProvider requires special context');\n    }\n  }\n  return createElement(ProviderOrig, { value }, children);\n};\n\n/**\n * This hook return a value for BridgeProvider\n */\nexport const useBridgeValue = (context: Context<any>) => {\n  const bridgeValue = useContextOrig(context as unknown as ContextOrig<ContextValue<unknown>>);\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    if (!bridgeValue[CONTEXT_VALUE]) {\n      throw new Error('useBridgeValue requires special context');\n    }\n  }\n  return bridgeValue as any;\n};\n", "// symbols\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n\n// properties\nconst AFFECTED_PROPERTY = 'a';\nconst FROZEN_PROPERTY = 'f';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst NEXT_OBJECT_PROPERTY = 'n';\nconst CHANGED_PROPERTY = 'g';\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\n\n// function to create a new bare proxy\nlet newProxy = <T extends object>(\n  target: T,\n  handler: ProxyHandler<T>,\n) => new Proxy(target, handler);\n\n// get object prototype\nconst getProto = Object.getPrototypeOf;\n\nconst objectsToTrack = new WeakMap<object, boolean>();\n\n// check if obj is a plain object or an array\nconst isObjectToTrack = <T>(obj: T): obj is T extends object ? T : never => (\n  obj && (objectsToTrack.has(obj as unknown as object)\n    ? objectsToTrack.get(obj as unknown as object) as boolean\n    : (getProto(obj) === Object.prototype || getProto(obj) === Array.prototype)\n  )\n);\n\n// check if it is object\nconst isObject = (x: unknown): x is object => (\n  typeof x === 'object' && x !== null\n);\n\n// check if frozen\nconst isFrozen = (obj: object) => (\n  Object.isFrozen(obj) || (\n    // Object.isFrozen() doesn't detect non-writable properties\n    // See: https://github.com/dai-shi/proxy-compare/pull/8\n    Object.values(Object.getOwnPropertyDescriptors(obj)).some(\n      (descriptor) => !descriptor.writable,\n    )\n  )\n);\n\n// copy frozen object\nconst unfrozenCache = new WeakMap<object, object>();\nconst unfreeze = <T extends object>(obj: T): T => {\n  let unfrozen = unfrozenCache.get(obj);\n  if (!unfrozen) {\n    if (Array.isArray(obj)) {\n      // Arrays need a special way to copy\n      unfrozen = Array.from(obj);\n    } else {\n      // For non-array objects, we create a new object keeping the prototype\n      // with changing all configurable options (otherwise, proxies will complain)\n      const descriptors = Object.getOwnPropertyDescriptors(obj);\n      Object.values(descriptors).forEach((desc) => { desc.configurable = true; });\n      unfrozen = Object.create(getProto(obj), descriptors);\n    }\n    unfrozenCache.set(obj, unfrozen as object);\n  }\n  return unfrozen as T;\n};\n\ntype HasKeySet = Set<string | symbol>\ntype HasOwnKeySet = Set<string | symbol>\ntype KeysSet = Set<string | symbol>\ntype Used = {\n  [HAS_KEY_PROPERTY]?: HasKeySet;\n  [ALL_OWN_KEYS_PROPERTY]?: true;\n  [HAS_OWN_KEY_PROPERTY]?: HasOwnKeySet;\n  [KEYS_PROPERTY]?: KeysSet;\n};\ntype Affected = WeakMap<object, Used>;\ntype ProxyHandlerState<T extends object> = {\n  readonly [FROZEN_PROPERTY]: boolean;\n  [PROXY_PROPERTY]?: T;\n  [PROXY_CACHE_PROPERTY]?: ProxyCache<object> | undefined;\n  [AFFECTED_PROPERTY]?: Affected;\n}\ntype ProxyCache<T extends object> = WeakMap<\n  object,\n  readonly [ProxyHandler<T>, ProxyHandlerState<T>]\n>;\n\nconst createProxyHandler = <T extends object>(origObj: T, frozen: boolean) => {\n  const state: ProxyHandlerState<T> = {\n    [FROZEN_PROPERTY]: frozen,\n  };\n  let trackObject = false; // for trackMemo\n  const recordUsage = (\n    type:\n      | typeof HAS_KEY_PROPERTY\n      | typeof ALL_OWN_KEYS_PROPERTY\n      | typeof HAS_OWN_KEY_PROPERTY\n      | typeof KEYS_PROPERTY,\n    key?: string | symbol,\n  ) => {\n    if (!trackObject) {\n      let used = (state[AFFECTED_PROPERTY] as Affected).get(origObj);\n      if (!used) {\n        used = {};\n        (state[AFFECTED_PROPERTY] as Affected).set(origObj, used);\n      }\n      if (type === ALL_OWN_KEYS_PROPERTY) {\n        used[ALL_OWN_KEYS_PROPERTY] = true;\n      } else {\n        let set = used[type];\n        if (!set) {\n          set = new Set();\n          used[type] = set;\n        }\n        set.add(key as string | symbol);\n      }\n    }\n  };\n  const recordObjectAsUsed = () => {\n    trackObject = true;\n    (state[AFFECTED_PROPERTY] as Affected).delete(origObj);\n  };\n  const handler: ProxyHandler<T> = {\n    get(target, key) {\n      if (key === GET_ORIGINAL_SYMBOL) {\n        return origObj;\n      }\n      recordUsage(KEYS_PROPERTY, key);\n      return createProxy(\n        Reflect.get(target, key),\n        (state[AFFECTED_PROPERTY] as Affected),\n        state[PROXY_CACHE_PROPERTY],\n      );\n    },\n    has(target, key) {\n      if (key === TRACK_MEMO_SYMBOL) {\n        recordObjectAsUsed();\n        return true;\n      }\n      recordUsage(HAS_KEY_PROPERTY, key);\n      return Reflect.has(target, key);\n    },\n    getOwnPropertyDescriptor(target, key) {\n      recordUsage(HAS_OWN_KEY_PROPERTY, key);\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    },\n    ownKeys(target) {\n      recordUsage(ALL_OWN_KEYS_PROPERTY);\n      return Reflect.ownKeys(target);\n    },\n  };\n  if (frozen) {\n    handler.set = handler.deleteProperty = () => false;\n  }\n  return [handler, state] as const;\n};\n\nconst getOriginalObject = <T extends object>(obj: T) => (\n  // unwrap proxy\n  (obj as { [GET_ORIGINAL_SYMBOL]?: typeof obj })[GET_ORIGINAL_SYMBOL]\n  // otherwise\n  || obj\n);\n\n/**\n * Create a proxy.\n *\n * This function will create a proxy at top level and proxy nested objects as you access them,\n * in order to keep track of which properties were accessed via get/has proxy handlers:\n *\n * NOTE: Printing of WeakMap is hard to inspect and not very readable\n * for this purpose you can use the `affectedToPathList` helper.\n *\n * @param {object} obj - Object that will be wrapped on the proxy.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that will hold the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [proxyCache] -\n * WeakMap that will help keep referential identity for proxies.\n * @returns {Proxy<object>} - Object wrapped in a proxy.\n *\n * @example\n * import { createProxy } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n * const proxy = createProxy(original, affected);\n *\n * proxy.a // Will mark as used and track its value.\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"a\"\n *\n * proxy.d // Will mark \"d\" as accessed to track and proxy itself ({ e: \"3\" }).\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"d\"\n */\nexport const createProxy = <T>(\n  obj: T,\n  affected: WeakMap<object, unknown>,\n  proxyCache?: WeakMap<object, unknown>,\n): T => {\n  if (!isObjectToTrack(obj)) return obj;\n  const target = getOriginalObject(obj);\n  const frozen = isFrozen(target);\n  let handlerAndState = (\n    proxyCache && (proxyCache as ProxyCache<typeof target>).get(target)\n  );\n  if (!handlerAndState || handlerAndState[1][FROZEN_PROPERTY] !== frozen) {\n    handlerAndState = createProxyHandler<typeof target>(target, frozen);\n    handlerAndState[1][PROXY_PROPERTY] = newProxy(\n      frozen ? unfreeze(target) : target,\n      handlerAndState[0],\n    );\n    if (proxyCache) {\n      proxyCache.set(target, handlerAndState);\n    }\n  }\n  handlerAndState[1][AFFECTED_PROPERTY] = affected as Affected;\n  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache as ProxyCache<object> | undefined;\n  return handlerAndState[1][PROXY_PROPERTY] as typeof target;\n};\n\nconst isAllOwnKeysChanged = (prevObj: object, nextObj: object) => {\n  const prevKeys = Reflect.ownKeys(prevObj);\n  const nextKeys = Reflect.ownKeys(nextObj);\n  return prevKeys.length !== nextKeys.length\n    || prevKeys.some((k, i) => k !== nextKeys[i]);\n};\n\ntype ChangedCache = WeakMap<object, {\n  [NEXT_OBJECT_PROPERTY]: object;\n  [CHANGED_PROPERTY]: boolean;\n}>;\n\n/**\n * Compare changes on objects.\n *\n * This will compare the affected properties on tracked objects inside the proxy\n * to check if there were any changes made to it,\n * by default if no property was accessed on the proxy it will attempt to do a\n * reference equality check for the objects provided (Object.is(a, b)). If you access a property\n * on the proxy, then isChanged will only compare the affected properties.\n *\n * @param {object} prevObj - The previous object to compare.\n * @param {object} nextObj - Object to compare with the previous one.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that holds the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [cache] -\n * WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,\n * and to avoid infinite loop with circular structures.\n * @returns {boolean} - Boolean indicating if the affected property on the object has changed.\n *\n * @example\n * import { createProxy, isChanged } from 'proxy-compare';\n *\n * const obj = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(obj, affected);\n *\n * proxy.a\n *\n * isChanged(obj, { a: \"1\" }, affected) // false\n *\n * proxy.a = \"2\"\n *\n * isChanged(obj, { a: \"1\" }, affected) // true\n */\n\nexport const isChanged = (\n  prevObj: unknown,\n  nextObj: unknown,\n  affected: WeakMap<object, unknown>,\n  cache?: WeakMap<object, unknown>,\n): boolean => {\n  if (Object.is(prevObj, nextObj)) {\n    return false;\n  }\n  if (!isObject(prevObj) || !isObject(nextObj)) return true;\n  const used = (affected as Affected).get(getOriginalObject(prevObj));\n  if (!used) return true;\n  if (cache) {\n    const hit = (cache as ChangedCache).get(prevObj);\n    if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {\n      return hit[CHANGED_PROPERTY];\n    }\n    // for object with cycles\n    (cache as ChangedCache).set(prevObj, {\n      [NEXT_OBJECT_PROPERTY]: nextObj,\n      [CHANGED_PROPERTY]: false,\n    });\n  }\n  let changed: boolean | null = null;\n  try {\n    for (const key of used[HAS_KEY_PROPERTY] || []) {\n      changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);\n      if (changed) return changed;\n    }\n    if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n      changed = isAllOwnKeysChanged(prevObj, nextObj);\n      if (changed) return changed;\n    } else {\n      for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {\n        const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);\n        const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);\n        changed = hasPrev !== hasNext;\n        if (changed) return changed;\n      }\n    }\n    for (const key of used[KEYS_PROPERTY] || []) {\n      changed = isChanged(\n        (prevObj as any)[key],\n        (nextObj as any)[key],\n        affected,\n        cache,\n      );\n      if (changed) return changed;\n    }\n    if (changed === null) changed = true;\n    return changed;\n  } finally {\n    if (cache) {\n      cache.set(prevObj, {\n        [NEXT_OBJECT_PROPERTY]: nextObj,\n        [CHANGED_PROPERTY]: changed,\n      });\n    }\n  }\n};\n\n// explicitly track object with memo\nexport const trackMemo = (obj: unknown) => {\n  if (isObjectToTrack(obj)) {\n    return TRACK_MEMO_SYMBOL in obj;\n  }\n  return false;\n};\n\n/**\n * Unwrap proxy to get the original object.\n *\n * Used to retrieve the original object used to create the proxy instance with `createProxy`.\n *\n * @param {Proxy<object>} obj -  The proxy wrapper of the originial object.\n * @returns {object | null} - Return either the unwrapped object if exists.\n *\n * @example\n * import { createProxy, getUntracked } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n * const originalFromProxy = getUntracked(proxy)\n *\n * Object.is(original, originalFromProxy) // true\n * isChanged(original, originalFromProxy, affected) // false\n */\nexport const getUntracked = <T>(obj: T): T | null => {\n  if (isObjectToTrack(obj)) {\n    return (obj as { [GET_ORIGINAL_SYMBOL]?: T })[GET_ORIGINAL_SYMBOL] || null;\n  }\n  return null;\n};\n\n/**\n * Mark object to be tracked.\n *\n * This function marks an object that will be passed into `createProxy`\n * as marked to track or not. By default only Array and Object are marked to track,\n * so this is useful for example to mark a class instance to track or to mark a object\n * to be untracked when creating your proxy.\n *\n * @param obj - Object to mark as tracked or not.\n * @param mark - Boolean indicating whether you want to track this object or not.\n * @returns - No return.\n *\n * @example\n * import { createProxy, markToTrack, isChanged } from 'proxy-compare';\n *\n * const nested = { e: \"3\" }\n *\n * markToTrack(nested, false)\n *\n * const original = { a: \"1\", c: \"2\", d: nested };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n *\n * proxy.d.e\n *\n * isChanged(original, { d: { e: \"3\" } }, affected) // true\n */\nexport const markToTrack = (obj: object, mark = true) => {\n  objectsToTrack.set(obj, mark);\n};\n\n/**\n * Convert `affected` to path list\n *\n * `affected` is a weak map which is not printable.\n * This function is can convert it to printable path list.\n * It's for debugging purpose.\n *\n * @param obj - An object that is used with `createProxy`.\n * @param affected - A weak map that is used with `createProxy`.\n * @param onlyWithValues - An optional boolean to exclude object getters.\n * @returns - An array of paths.\n */\nexport const affectedToPathList = (\n  obj: unknown,\n  affected: WeakMap<object, unknown>,\n  onlyWithValues?: boolean,\n) => {\n  const list: (string | symbol)[][] = [];\n  const seen = new WeakSet();\n  const walk = (x: unknown, path?: (string | symbol)[]) => {\n    if (seen.has(x as object)) {\n      // for object with cycles\n      return;\n    }\n    if (isObject(x)) {\n      seen.add(x);\n    }\n    const used = isObject(x) && (affected as Affected).get(getOriginalObject(x));\n    if (used) {\n      used[HAS_KEY_PROPERTY]?.forEach((key) => {\n        const segment = `:has(${String(key)})`;\n        list.push(path ? [...path, segment] : [segment]);\n      });\n      if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n        const segment = ':ownKeys';\n        list.push(path ? [...path, segment] : [segment]);\n      } else {\n        used[HAS_OWN_KEY_PROPERTY]?.forEach((key) => {\n          const segment = `:hasOwn(${String(key)})`;\n          list.push(path ? [...path, segment] : [segment]);\n        });\n      }\n      used[KEYS_PROPERTY]?.forEach((key) => {\n        if (!onlyWithValues || 'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {\n          walk((x as any)[key], path ? [...path, key] : [key]);\n        }\n      });\n    } else if (path) {\n      list.push(path);\n    }\n  };\n  walk(obj);\n  return list;\n};\n\n/**\n * replace newProxy function.\n *\n * This can be used if you want to use proxy-polyfill.\n * Note that proxy-polyfill can't polyfill everything.\n * Use it at your own risk.\n */\nexport const replaceNewProxy = (fn: typeof newProxy) => {\n  newProxy = fn;\n};\n", "import { useEffect, useRef, useDebugValue } from 'react';\nimport { affectedToPathList } from 'proxy-compare';\n\ntype Obj = Record<string, unknown>;\n\nexport const useAffectedDebugValue = <State>(\n  state: State,\n  affected: WeakMap<Obj, unknown>,\n) => {\n  const pathList = useRef<(string | number | symbol)[][]>();\n  useEffect(() => {\n    pathList.current = affectedToPathList(state, affected);\n  });\n  useDebugValue(state);\n};\n", "import {\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n} from 'react';\nimport { createProxy, isChanged } from 'proxy-compare';\n\nimport { useAffectedDebugValue } from './utils';\n\nexport const createTrackedSelector = <State>(\n  useSelector: <Selected>(selector: (state: State) => Selected) => Selected,\n) => {\n  const useTrackedSelector = () => {\n    const [, forceUpdate] = useReducer((c) => c + 1, 0);\n    const affected = new WeakMap();\n    const lastAffected = useRef<typeof affected>();\n    const prevState = useRef<State>();\n    const lastState = useRef<State>();\n    useEffect(() => {\n      lastAffected.current = affected;\n      if (prevState.current !== lastState.current\n        && isChanged(\n          prevState.current,\n          lastState.current,\n          affected,\n          new WeakMap(),\n        )) {\n        prevState.current = lastState.current;\n        forceUpdate();\n      }\n    });\n    const selector = useCallback((nextState: State) => {\n      lastState.current = nextState;\n      if (prevState.current\n        && prevState.current !== nextState\n        && lastAffected.current\n        && !isChanged(\n          prevState.current,\n          nextState,\n          lastAffected.current,\n          new WeakMap(),\n        )\n      ) {\n        // not changed\n        return prevState.current;\n      }\n      prevState.current = nextState;\n      return nextState;\n    }, []);\n    const state = useSelector(selector);\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useAffectedDebugValue(state, affected);\n    }\n    const proxyCache = useMemo(() => new WeakMap(), []); // per-hook proxyCache\n    return createProxy(state, affected, proxyCache);\n  };\n  return useTrackedSelector;\n};\n", "/* eslint react/destructuring-assignment: off */\n\nimport {\n  ComponentType,\n  Context as ContextOrig,\n  ReactNode,\n  createContext as createContextOrig,\n  createElement,\n  useCallback,\n  useContext as useContextOrig,\n  useDebugValue,\n} from 'react';\n\nimport {\n  Context,\n  createContext,\n  useContextSelector,\n  useContextUpdate,\n} from 'use-context-selector';\n\nimport { createTrackedSelector } from './createTrackedSelector';\n\ntype AnyFunction = (...args: any[]) => any;\ntype Options<State, Update extends AnyFunction> = {\n  defaultState?: State;\n  defaultUpdate?: Update;\n  stateContextName?: string;\n  updateContextName?: string;\n  concurrentMode?: boolean;\n}\n/**\n * [Deprecated] Please use object option\n */\ntype DeprecatedOption = boolean\n\nexport const createContainer = <State, Update extends AnyFunction, Props>(\n  useValue: (props: Props) => readonly [State, Update],\n  options?: Options<State, Update> | DeprecatedOption,\n) => {\n  if (typeof options === 'boolean') {\n    // eslint-disable-next-line no-console\n    console.warn('boolean option is deprecated, please specify { concurrentMode: true }');\n    options = { concurrentMode: options };\n  }\n  const {\n    stateContextName = 'StateContainer',\n    updateContextName = 'UpdateContainer',\n    concurrentMode,\n  } = options || {};\n  const StateContext = createContext<State | undefined>(options?.defaultState);\n  const UpdateContext = createContextOrig<Update | undefined>(options?.defaultUpdate);\n  StateContext.displayName = stateContextName;\n  UpdateContext.displayName = updateContextName;\n\n  const Provider = (props: Props & { children: ReactNode }) => {\n    const [state, update] = useValue(props);\n    return createElement(\n      UpdateContext.Provider,\n      { value: update },\n      createElement(StateContext.Provider as ComponentType<{\n        value: State;\n      }>, { value: state }, props.children),\n    );\n  };\n\n  const useSelector = <Selected>(\n    selector: (state: State) => Selected,\n  ) => {\n    if (\n      typeof process === 'object'\n      && process.env.NODE_ENV !== 'production'\n    ) {\n      const selectorOrig = selector;\n      selector = (state: State) => {\n        if (state === undefined) {\n          throw new Error('Please use <Provider>');\n        }\n        return selectorOrig(state);\n      };\n    }\n    const selected = useContextSelector(StateContext as Context<State>, selector);\n    useDebugValue(selected);\n    return selected;\n  };\n\n  const useTrackedState = createTrackedSelector(useSelector);\n\n  const useUpdate = concurrentMode\n    ? () => {\n      if (\n        typeof process === 'object'\n        && process.env.NODE_ENV !== 'production'\n        && useContextOrig(UpdateContext) === undefined\n      ) {\n        throw new Error('Please use <Provider>');\n      }\n      const contextUpdate = useContextUpdate(StateContext as Context<unknown>);\n      const update = useContextOrig(UpdateContext as ContextOrig<Update>);\n      return useCallback((...args: Parameters<Update>) => {\n        let result: ReturnType<Update> | undefined;\n        contextUpdate(() => {\n          result = update(...args);\n        });\n        return result as ReturnType<Update>;\n      }, [contextUpdate, update]);\n    }\n    // not concurrentMode\n    : () => {\n      if (\n        typeof process === 'object'\n        && process.env.NODE_ENV !== 'production'\n        && useContextOrig(UpdateContext) === undefined\n      ) {\n        throw new Error('Please use <Provider>');\n      }\n      return useContextOrig(UpdateContext as ContextOrig<Update>);\n    };\n\n  const useTracked = () => [useTrackedState(), useUpdate()] as [\n    ReturnType<typeof useTrackedState>,\n    ReturnType<typeof useUpdate>,\n  ];\n\n  return {\n    Provider,\n    useTrackedState,\n    useTracked,\n    useUpdate,\n    useSelector,\n  } as const;\n};\n", "import { createElement, memo as reactMemo, forwardRef } from 'react';\nimport { trackMemo } from 'proxy-compare';\n\nimport type {\n  PropsWithChildren,\n  NamedExoticComponent,\n  ComponentType,\n  ComponentProps,\n  MemoExoticComponent,\n} from 'react';\n\nexport function memo<P extends Record<string, unknown>>(\n  Component: ComponentType<P>,\n  propsAreEqual?: (\n    prevProps: Readonly<PropsWithChildren<P>>,\n    nextProps: Readonly<PropsWithChildren<P>>,\n  ) => boolean,\n): NamedExoticComponent<P>;\n\nexport function memo<T extends ComponentType<any>>(\n  Component: T,\n  propsAreEqual?: (\n    prevProps: Readonly<ComponentProps<T>>,\n    nextProps: Readonly<ComponentProps<T>>,\n  ) => boolean,\n): MemoExoticComponent<T>;\n\nexport function memo(Component: any, propsAreEqual?: any) {\n  const WrappedComponent = forwardRef((props: any, ref: any) => {\n    Object.values(props).forEach(trackMemo);\n    return createElement(Component, { ...props, ref });\n  });\n  return reactMemo(WrappedComponent, propsAreEqual);\n}\n"],
  "mappings": "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",
  "names": ["CONTEXT_VALUE", "Symbol", "ORIGINAL_PROVIDER", "useIsomorphicLayoutEffect", "window", "test", "navigator", "userAgent", "useEffect", "useLayoutEffect", "runWithNormalPriority", "runWithPriority", "thunk", "NormalPriority", "createContext", "defaultValue", "context", "createContextOrig", "CONTEXT_VALUE", "v", "current", "n", "l", "Set", "u", "f", "ProviderOrig", "ORIGINAL_PROVIDER", "Provider", "value", "children", "valueRef", "useRef", "versionRef", "resolve", "setResolve", "useState", "contextValue", "e", "update", "thunk", "options", "batchedUpdates", "action", "suspense", "p", "Promise", "r", "listeners", "forEach", "listener", "useIsomorphicLayoutEffect", "runWithNormalPriority", "createElement", "Consumer", "useContextSelector", "selector", "useContextOrig", "process", "NODE_ENV", "Error", "version", "selected", "state", "dispatch", "useReducer", "prev", "Object", "is", "nextSelected", "add", "delete", "context", "contextValue", "useContextOrig", "CONTEXT_VALUE", "process", "NODE_ENV", "Error", "u", "update", "e", "Symbol", "AFFECTED_PROPERTY", "ALL_OWN_KEYS_PROPERTY", "newProxy", "target", "handler", "Proxy", "getProto", "Object", "getPrototypeOf", "objectsToTrack", "WeakMap", "obj", "has", "get", "prototype", "Array", "isObject", "x", "unfrozenCache", "GET_ORIGINAL_SYMBOL", "createProxy", "affected", "proxyCache", "isObjectToTrack", "getOriginalObject", "frozen", "isFrozen", "values", "getOwnPropertyDescriptors", "some", "descriptor", "writable", "handlerAndState", "origObj", "state", "f", "trackObject", "type", "key", "s", "used", "set", "Set", "add", "recordUsage", "Reflect", "TRACK_MEMO_SYMBOL", "delete", "getOwnPropertyDescriptor", "ownKeys", "deleteProperty", "unfrozen", "isArray", "from", "descriptors", "forEach", "desc", "configurable", "create", "p", "prevObj", "nextObj", "cache", "is", "hit", "n", "g", "changed", "c", "prevKeys", "length", "nextKeys", "k", "i", "isChanged", "trackMemo", "affectedToPathList", "obj", "affected", "onlyWithValues", "list", "seen", "WeakSet", "walk", "x", "path", "has", "isObject", "add", "used", "get", "getOriginalObject", "u", "p", "_used$HAS_KEY_PROPERT", "forEach", "key", "t", "String", "push", "segment", "ALL_OWN_KEYS_PROPERTY", "_used$HAS_OWN_KEY_PRO", "y", "_used$KEYS_PROPERTY", "Object", "getOwnPropertyDescriptor", "useAffectedDebugValue", "state", "affected", "pathList", "useRef", "useEffect", "current", "affectedToPathList", "useDebugValue", "createTrackedSelector", "useSelector", "useTrackedSelector", "forceUpdate", "useReducer", "c", "WeakMap", "lastAffected", "prevState", "lastState", "isChanged", "selector", "useCallback", "nextState", "process", "proxyCache", "useMemo", "createProxy", "createContainer", "useValue", "options", "console", "warn", "concurrentMode", "stateContextName", "updateContextName", "StateContext", "createContext", "defaultState", "UpdateContext", "createContextOrig", "defaultUpdate", "displayName", "Provider", "props", "update", "createElement", "value", "children", "selectorOrig", "undefined", "Error", "selected", "useContextSelector", "useTrackedState", "useUpdate", "useContextOrig", "contextUpdate", "useContextUpdate", "args", "result", "useTracked", "memo", "Component", "propsAreEqual", "WrappedComponent", "forwardRef", "ref", "Object", "values", "forEach", "trackMemo", "reactMemo"]
}
