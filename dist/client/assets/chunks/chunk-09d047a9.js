import{n as ft,j as K,p as C,q as G,r as Fe,t as u,u as h,v as Te,b as g,d as R,w as M,x as A,k as Y,y as Ee,z as se,A as ae,o as p,B as P,C as x,a as dt,l as U,D as He,E as Ie,F as Ae,G as gt,H as ht,I as D,J as pt,K as mt,L as yt,c as bt,M as Be,N as Pt,O as Ne,P as wt,Q as F,R as Rt,S as St,T as ue,g as le,i as J,h as vt}from"./chunk-acb1a683.js";import{_ as Q}from"./chunk-cf010ec4.js";import{i as I,b as _t}from"./chunk-d8234155.js";import"./chunk-e9cd8943.js";function Ct(){ft(),K()}function O(e){return typeof e!="object"||e===null?!1:Object.getPrototypeOf(e)===null?!0:e.constructor.name==="Object"}function Ot(){var r,o,i,a;const e=!!((o=(r=window.__REACT_DEVTOOLS_GLOBAL_HOOK__)==null?void 0:r.renderers)!=null&&o.size),t=!!((a=(i=window.__REACT_DEVTOOLS_GLOBAL_HOOK__)==null?void 0:i.rendererInterfaces)!=null&&a.size),n=!!window.__vite_plugin_react_preamble_installed__;return e||t||n}function je(e,t){const n=Object.keys,r=typeof e;return e&&t&&r==="object"&&r===typeof t?n(e).length===n(t).length&&n(e).every(i=>je(e[i],t[i])):e===t}function $t(e,t){return C(e)&&C(t)&&e.constructor===t.constructor&&je({...e,stack:null},{...t,stack:null})&&t.message===t.message}function V(e){window.location.href=e}function kt(e){return new Promise(t=>setTimeout(t,e))}function xt(e,t){let n=!1;return()=>{n||(n=!0,setTimeout(()=>{n=!1,e()},t))}}function Le(e){window.addEventListener("visibilitychange",()=>{document.visibilityState==="hidden"&&e()})}function Ft(e){window.addEventListener("visibilitychange",()=>{document.visibilityState==="visible"&&e()})}function Tt(e){return!e.startsWith("/")&&!e.startsWith(".")&&!e.startsWith("?")&&e!==""}Ct();function be(e){return"["+e.map(t=>"'"+t+"'").join(", ")+"]"}function X(e,t){const n=Object.getOwnPropertyDescriptor(e,t);return!!n&&!("value"in n)&&!!n.get}function Et(e){return typeof e=="object"&&e!==null&&"then"in e&&G(e.then)}function Ht(e){return[null,void 0].includes(e)?String(e):["boolean","number","string"].includes(typeof e)?JSON.stringify(e):null}function It(e){return e.replace(/[/\-\\^$*+?.()|[\]{}]/g,"\\$&")}async function At(e,t){const r=Fe(e,t).filter(i=>i.fileType===".page.server");return await Promise.all(r.map(async i=>{i.exportNames||(u(i.loadExportNames,t),await i.loadExportNames())})),{hasOnBeforeRenderServerSideOnlyHook:r.some(({exportNames:i})=>(u(i),i.includes("onBeforeRender")))}}function E(e,t,n){const r=Nt(e,t);if(r===null)return null;const{value:o,definedAt:i}=r;return n&&Bt(o,n,t,i),r}function Bt(e,t,n,r){u(e!==null);const o=typeof e;if(o===t)return;const i=Ht(e),a=i!==null?`value ${h.cyan(i)}`:`type ${h.cyan(o)}`,l=`${Te("Config",n,{definedAt:r})} has an invalid ${a}: it should be a ${h.cyan(t)} instead`;g(!1,l)}function Nt(e,t){const n=e.configValues[t];return!n||n.value===null?null:n}const Pe=["urlPathname","urlParsed"],jt=["Page","pageExports","exports"];function We(e){[...jt,...Pe].forEach(n=>{n in e&&(Pe.includes(n)?(u(n.startsWith("url")),R(!1,`pageContext.${n} is already available in the browser when using Client Routing; adding '${n}' to passToClient has no effect`,{onlyOnce:!0})):R(!1,`pageContext.${n} is a built-in that cannot be overriden; adding '${n}' to passToClient has no effect`,{onlyOnce:!0}),delete e[n])})}const Lt="/";function Wt(e,t,n){const{pathnameOriginal:r,searchOriginal:o,hashOriginal:i}=M(e,Lt);e.startsWith("/")&&u(e===`${r}${o||""}${i||""}`,{url:e});const a=r.endsWith("/");let s;return n&&r!=="/"?(a?s=A(r,0,-1):s=r,u(!s.endsWith("/"),{url:e}),u(s!=="")):s=r+(a?"":"/")+"index",u(s),s=s+t,`${s}${o||""}${i||""}`}const Dt=".pageContext.json",Ut=!1;function Vt(e){return Wt(e,Dt,Ut)}function De(e,{hookName:t,hookFilePath:n}){if(e==null)return;u(!t.endsWith(")"));const r=`The ${h.cyan("pageContext")} object provided by the ${t}() hook defined by ${n}`;g(C(e),`${r} should be an object (but it's ${h.cyan(`typeof pageContext === ${JSON.stringify(typeof e)}`)} instead)`),g(!("_objectCreatedByVike"in e),`${r} shouldn't be the whole ${h.cyan("pageContext")} object, see https://vike.dev/pageContext-manipulation#do-not-return-entire-pagecontext`),R(!("_pageId"in e),`${r} sets ${h.cyan("pageContext._pageId")} which means that Vike's routing is overriden. This is an experimental feature: make sure to contact a vike maintainer before using this.`,{onlyOnce:!0}),g(!("is404"in e),`${r} sets ${h.cyan("pageContext.is404")} which is forbidden, use ${h.cyan("throw render()")} instead, see https://vike.dev/render`)}function zt(e,t,n){u(!n.endsWith(" "));const r=[],o=Object.keys(e);for(const i of o)t.includes(i)||r.push(i);g(r.length===0,[n,"returned an object with following unknown keys:",be(r)+".","Only following keys are allowed:",be(t)+"."].join(" "))}function Kt(e,t){if(e==null)return;const n=`The onBeforeRender() hook defined by ${t}`;g(O(e),`${n} should return a plain JavaScript object, ${h.cyan("undefined")}, or ${h.cyan("null")}`),zt(e,["pageContext"],n),e.pageContext&&De(e.pageContext,{hookName:"onBeforeRender",hookFilePath:t})}function Gt(e,t){if(!O(e))return!1;for(const n of Object.keys(e))if(!t.includes(n))return!1;return!0}function Mt(e){return typeof e=="object"&&e!==null&&Object.values(e).every(t=>typeof t=="string")}function Yt(e,t,n=r=>r){if(u(e.length>0),e.length===1)return n(e[0]);const r=e.slice(0,e.length-1),o=e[e.length-1];return r.map(n).join(", ")+` ${t} `+n(o)}Y()&&K();async function qt(e,t){let n;if(e._pageFilesAll.length>0?(u(e._pageConfigs.length===0),n=Jt(e._pageId,e._pageFilesAll)):n=Ee(e,"guard"),!n)return;const r=n.hookFn;let o=e;const i=t(e);i&&(o=i);const a=await se(()=>r(o),"guard",n.hookFilePath);g(a===void 0,`The guard() hook of ${n.hookFilePath} returns a value, but guard() doesn't accept any return value`)}function Jt(e,t){const n=t.find(s=>s.pageId===e&&s.fileType===".page.route");if(!n)return null;const{filePath:r,fileExports:o}=n;u(o);const i=o.guard;if(!i)return null;const a=r;return g(G(i),`guard() defined by ${a} should be a function`),{hookFn:i,hookName:"guard",hookFilePath:a}}function Qt(e){const t=new Error("AbortRender");return p(t,{_pageContextAbort:e,[Ue]:!0}),t}const Ue="_isAbortError";function we(e){return typeof e=="object"&&e!==null&&Ue in e}function Xt(e){return e._urlRewrite||e._urlRedirect||e.abortStatusCode?(u(P(e,"_abortCall","string")),!0):!1}function Zt(e,t,n){var i;if(t)return;const r=(i=n._urlRewrite)!=null?i:n.urlOriginal;u(r);const o=e._pageContextAbort._abortCall;ae(!1,`${h.cyan(o)} intercepted while rendering ${h.cyan(r)}`,{onlyOnce:!1})}function en(e){tn(e);const t={_urlRewrite:null};return e.forEach(n=>{Object.assign(t,n)}),t}function tn(e){const t=[];e.forEach(n=>{const r=n._urlRewrite;{const o=t.indexOf(r);if(o!==-1){const i=[...t.slice(o),r].map(a=>`render('${a}')`).join(" => ");g(!1,`Infinite loop of render() calls: ${i}`)}}t.push(r)})}function nn(e,t){const n=[e>0&&h.cyan("throw render('/some-url')"),t>0&&h.cyan("throw redirect('/some-url')")].filter(Boolean).join(" and ");g(e+t<=7,`Maximum chain length of 7 ${n} exceeded. Did you define an infinite loop of ${n}?`)}const Ve=x("router/getPageContext.ts",{});async function rn(e){const t=dt();We(t),p(t,{isHydration:!0,_hasPageContextFromClient:!1}),p(t,await U(t._pageId,e));{const n={...e,...t};if(await ln(n)){const r=await Ke(n);p(t,r)}}return Ge(t),t}async function on(e){const t=He(e._pageFilesAll,e._pageConfigs);if(!t)throw new Error("No error page defined.");const n={isHydration:!1,_pageId:t};return p(n,await ze({...e,...n},!0)),n}async function sn(e){const t={isHydration:!1,_pageId:e._pageId};return p(t,await ze({...e,...t},!1)),Ge(t),t}async function ze(e,t){let n={};if(p(n,await U(e._pageId,e)),!t&&await an({...e,...n})){const r=await cn(e);if(!r._isError)p(n,r);else{const o=He(e._pageFilesAll,e._pageConfigs);u(o),n={},p(n,{isHydration:!1,_pageId:o}),p(n,await U(n._pageId,e)),u(P(r,"is404","boolean")),u(P(r,"pageProps","object")),u(P(r.pageProps,"is404","boolean")),u(!("serverSideError"in r)),p(n,r)}}else p(n,{_hasPageContextFromServer:!1}),t||await qt({_hasPageContextFromClient:!1,...e,...n},r=>Ie(r,!0));{const r=await Ke({...e,...n});p(n,r)}return n}async function Ke(e){const t=Ee(e,"onBeforeRender");if(!t)return{_hasPageContextFromClient:!1};const n=t.hookFn,r={_hasPageContextFromClient:!0},o=Ie({...e,...r},!0),i=await se(()=>n(o),"onBeforeRender",t.hookFilePath);Kt(i,t.hookFilePath);const a=i==null?void 0:i.pageContext;return p(r,a),r}function Ge(e){e._pageContextInitHasClientData&&(Ve.pageContextInitHasClientData=!0)}async function an(e){return!!Ve.pageContextInitHasClientData||await un(e)}async function un(e){var t,n;if(e._pageConfigs.length>0){const r=Ae(e._pageId,e._pageConfigs),o=(n=(t=E(r,"onBeforeRenderEnv"))==null?void 0:t.value)!=null?n:{};return u(C(o)),!!o.server&&!o.client}else{const{hasOnBeforeRenderServerSideOnlyHook:r}=await At(e._pageFilesAll,e._pageId);return r}}async function ln(e){var t,n;if(e._pageConfigs.length>0){const r=Ae(e._pageId,e._pageConfigs),o=(n=(t=E(r,"onBeforeRenderEnv"))==null?void 0:t.value)!=null?n:{};return u(C(o)),!!o.client&&!o.server}else return!1}async function cn(e){var i;const t=Vt((i=e._urlRewrite)!=null?i:e.urlOriginal),n=await fetch(t);{const a=n.headers.get("content-type"),s="application/json",l=a&&a.includes(s);if(!l&&n.status===404)throw V(e.urlOriginal),dn();g(l,`Wrong Content-Type for ${t}: it should be ${s} but it's ${a} instead. Make sure to properly use pageContext.httpResponse.headers, see https://vike.dev/renderPage`)}const r=await n.text(),o=gt(r);if(u(C(o)),"serverSideError"in o)throw ht("The pageContext object couldn't be fetched from the server as an error occurred on the server-side. Check your server logs.");if(Xt(o))throw Qt(o);return u(P(o,"_pageId","string")),We(o),p(o,{_hasPageContextFromServer:!0}),o}function fn(e){return C(e)&&!!e._alreadyServerSideRouted}function dn(){const e=new Error("Page doesn't exist");return Object.assign(e,{_alreadyServerSideRouted:!0}),e}function Me(e,t=!0){u(e.urlOriginal),"urlPathname"in e&&(u(typeof e.urlPathname=="string"),u(X(e,"urlPathname"))),"urlParsed"in e&&u(X(e,"urlParsed")),"url"in e&&u(X(e,"url")),Object.defineProperty(e,"urlPathname",{get:qe,enumerable:t,configurable:!0}),Object.defineProperty(e,"url",{get:gn,enumerable:!1,configurable:!0}),Object.defineProperty(e,"urlParsed",{get:hn,enumerable:t,configurable:!0})}function Ye(e){var o,i;let t=e._urlHandler;t||(t=a=>a);let n=(i=(o=e._urlRewrite)!=null?o:e.urlLogical)!=null?i:e.urlOriginal;n=t(n);const r=e._baseServer;return u(n&&typeof n=="string"),u(r.startsWith("/")),M(n,r)}function qe(){const{pathname:e}=Ye(this),t=e;return u(t.startsWith("/")),t}function gn(){return R(!1,"`pageContext.url` is outdated. Use `pageContext.urlPathname`, `pageContext.urlParsed`, or `pageContext.urlOriginal` instead. (See https://vike.dev/migration/0.4.23 for more information.)",{onlyOnce:!0,showStackTrace:!0}),qe.call(this)}function hn(){const e=Ye(this),{origin:t,pathname:n,pathnameOriginal:r,search:o,searchAll:i,searchOriginal:a,hash:s,hashOriginal:l}=e,d=Y(),b=c=>{R(d,`pageContext.urlParsed.${c} isn't available on the server-side (HTTP requests don't include the URL hash by design)`,{onlyOnce:!0,showStackTrace:!0})},f={origin:t,pathname:n,pathnameOriginal:r,search:o,searchAll:i,searchOriginal:a,get hash(){return b("hash"),s},get hashOriginal(){return b("hashOriginal"),l},get hashString(){return R(!1,"pageContext.urlParsed.hashString has been renamed to pageContext.urlParsed.hashOriginal",{onlyOnce:!0,showStackTrace:!0}),b("hashString"),l},get searchString(){return R(!1,"pageContext.urlParsed.searchString has been renamed to pageContext.urlParsed.searchOriginal",{onlyOnce:!0,showStackTrace:!0}),a}};return j(f,"hashString"),j(f,"searchString"),d||(j(f,"hash"),j(f,"hashOriginal")),f}function j(e,t){const n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(e,t,{...n,enumerable:!1})}function pn(e){u(typeof e.urlOriginal=="string"),u(typeof e.urlPathname=="string"),u(O(e.urlParsed)),u(e.urlPathname===e.urlParsed.pathname)}function mn(e,t){const r=t.filter(({filesystemRoot:i})=>e.startsWith(i)).sort(D(({filesystemRoot:i})=>i.length))[0];let o;if(r){const{filesystemRoot:i,urlRoot:a}=r,s={pageId:e,filesystemRoot:i,urlRoot:a};u(a.startsWith("/")&&e.startsWith("/")&&i.startsWith("/"),s),u(e.startsWith(i),s),i!=="/"?(u(!i.endsWith("/"),s),o=A(e,i.length,0)):o=e,u(o.startsWith("/"),s),o=a+(a.endsWith("/")?"":"/")+A(o,1,0)}else o=e;return u(o.startsWith("/")),o=o.split("/").filter(i=>i!=="pages"&&i!=="src"&&i!=="index").join("/"),u(!o.includes(".page.")),u(!o.endsWith(".")),o.endsWith("/index")&&(o=A(o,0,-6)),o===""&&(o="/"),u(o.startsWith("/")),u(!o.endsWith("/")||o==="/"),o}async function yn(e,t,n){pn(t);let r=e(t);if(Je(r,`The Route Function ${n}`),r=await r,r===!1)return null;if(r===!0&&(r={}),g(O(r),`The Route Function ${n} should return a boolean or a plain JavaScript object (but it's ${h.cyan(`typeof result === ${JSON.stringify(typeof r)}`)} instead)`),"match"in r){const{match:a}=r;if(g(typeof a=="boolean",`The ${h.cyan("match")} value returned by the Route Function ${n} should be a boolean.`),!a)return null}let o=null;"precedence"in r&&(o=r.precedence,g(typeof o=="number",`The ${h.cyan("precedence")} value returned by the Route Function ${n} should be a number.`)),Qe(r,`The ${h.cyan("routeParams")} object returned by the Route Function ${n} should`);const i=r.routeParams||{};return g(!("pageContext"in r),`Providing ${h.cyan("pageContext")} in Route Functions is prohibited, see https://vike.dev/route-function#cannot-provide-pagecontext`),u(O(i)),Object.keys(r).forEach(a=>{g(a==="match"||a==="routeParams"||a==="precedence",`The Route Function ${n} returned an object with an unknown property ${h.cyan(a)} (the known properties are ${h.cyan("match")}, ${h.cyan("routeParams")}, and ${h.cyan("precedence")})`)}),{precedence:o,routeParams:i}}function Je(e,t){R(!Et(e),`${t} returned a promise, but asynchronous routing is deprecated and will be removed in the next major release, see https://vike.dev/route-function#async`,{onlyOnce:!0})}function Re(){const e=h.cyan("iKnowThePerformanceRisksOfAsyncRouteFunctions");R(!1,`${e} is deprecated and will be removed in the next major release`,{onlyOnce:!0})}function Qe(e,t){u(t.endsWith(" should")),P(e,"routeParams")&&(u(t.endsWith(" should")),g(O(e.routeParams),`${t} be a plain JavaScript object.`),g(Mt(e.routeParams),`${t} only hold string values.`))}async function bn(e,t,n,r){await Promise.all(e.filter(s=>s.fileType===".page.route").map(s=>{var l;return(l=s.loadFile)==null?void 0:l.call(s)}));const{onBeforeRouteHook:o,filesystemRoots:i}=wn(e,t,n);return{pageRoutes:Pn(i,e,t,r),onBeforeRouteHook:o}}function Pn(e,t,n,r){const o=[];let i=[...r];if(n.length>0){u(e===null);const a=!0;n.filter(s=>!s.isErrorPage).forEach(s=>{const l=s.pageId;i=Sn(i,l);let d=null;{const b="route",f=E(s,b);if(f){const c=f.value,y=pt(f.definedAt,b);typeof c=="string"?d={pageId:l,comesFromV1PageConfig:a,routeString:c,routeDefinedAt:y,routeType:"STRING"}:(u(G(c)),E(s,"iKnowThePerformanceRisksOfAsyncRouteFunctions","boolean")&&Re(),d={pageId:l,comesFromV1PageConfig:a,routeFunction:c,routeDefinedAt:y,routeType:"FUNCTION"})}}if(!d){const{routeFilesystem:b}=s;u(b);const{routeString:f,definedBy:c}=b;u(b.routeString.startsWith("/")),d={pageId:l,routeFilesystemDefinedBy:c,comesFromV1PageConfig:a,routeString:f,routeDefinedAt:null,routeType:"FILESYSTEM"}}u(d),o.push(d)})}if(n.length===0){u(e);const a=!1;i.filter(s=>!mt(s)).forEach(s=>{const l=t.find(d=>d.pageId===s&&d.fileType===".page.route");if(!l||!("default"in l.fileExports)){const d=mn(s,e);u(d.startsWith("/")),u(!d.endsWith("/")||d==="/"),o.push({pageId:s,comesFromV1PageConfig:a,routeString:d,routeDefinedAt:null,routeFilesystemDefinedBy:`${s}.page.*`,routeType:"FILESYSTEM"})}else{const{filePath:d,fileExports:b}=l;if(u(b.default),P(b,"default","string")){const f=b.default;g(f.startsWith("/"),`A Route String should start with a leading slash '/' but ${d} has \`export default '${f}'\`. Make sure to \`export default '/${f}'\` instead.`),o.push({pageId:s,comesFromV1PageConfig:a,routeString:f,routeDefinedAt:d,routeType:"STRING"});return}if(P(b,"default","function")){const f=b.default;"iKnowThePerformanceRisksOfAsyncRouteFunctions"in b&&Re(),o.push({pageId:s,comesFromV1PageConfig:a,routeFunction:f,routeDefinedAt:d,routeType:"FUNCTION"});return}g(!1,`The default export of ${d} should be a string or a function.`)}})}return o}function wn(e,t,n){var i;if(t.length>0){const a="onBeforeRoute";if((i=n.configValues[a])!=null&&i.value){const s=n.configValues[a],{value:l}=s,d=yt(s),b=Te("Hook",a,s);return g(G(l),`${b} should be a function.`),{onBeforeRouteHook:{hookFilePath:d,onBeforeRoute:l},filesystemRoots:null}}return{onBeforeRouteHook:null,filesystemRoots:null}}let r=null;const o=[];return e.filter(a=>a.fileType===".page.route"&&a.isDefaultPageFile).forEach(({filePath:a,fileExports:s})=>{if(u(s),"onBeforeRoute"in s){g(P(s,"onBeforeRoute","function"),`\`export { onBeforeRoute }\` of ${a} should be a function.`);const{onBeforeRoute:l}=s;r={hookFilePath:`${a} > \`export { onBeforeRoute }\``,onBeforeRoute:l}}"filesystemRoutingRoot"in s&&(g(P(s,"filesystemRoutingRoot","string"),`\`export { filesystemRoutingRoot }\` of ${a} should be a string.`),g(P(s,"filesystemRoutingRoot","string"),`\`export { filesystemRoutingRoot }\` of ${a} is \`'${s.filesystemRoutingRoot}'\` but it should start with a leading slash \`/\`.`),o.push({filesystemRoot:Rn(a),urlRoot:s.filesystemRoutingRoot}))}),{onBeforeRouteHook:r,filesystemRoots:o}}function Rn(e){u(e.startsWith("/")),u(!e.endsWith("/"));const t=e.split("/"),n=A(t,0,-1).join("/")||"/";return u(n.startsWith("/")),u(!n.endsWith("/")||n==="/"),n}function Sn(e,t){const{length:n}=e;return e=e.filter(r=>r!==t),u(e.length===n-1),e}function Xe(){const e="/";return u(vn(e)),e}function vn(e){return e.startsWith("/")}const Z=x("createPageContext.ts",{});async function Ze(e){Z.pageFilesData||(Z.pageFilesData=await bt(!0));const{pageFilesAll:t,allPageIds:n,pageConfigs:r,pageConfigGlobal:o}=Z.pageFilesData,{pageRoutes:i,onBeforeRouteHook:a}=await bn(t,r,o,n),s=Xe();u(Be(s));const d={urlOriginal:e,_objectCreatedByVike:!0,_urlHandler:null,_urlRewrite:null,_baseServer:s,_isProduction:!0,_pageFilesAll:t,_pageConfigs:r,_pageConfigGlobal:o,_allPageIds:n,_pageRoutes:i,_onBeforeRouteHook:a};return Me(d),d}function _n(e){const t=e.getAttribute("href");return!!(t===null||t===""||Tt(t)||On(e)||$n(t)||!kn(t)||!Pt(t)||!Cn(e))}function Cn(e){if(xn()){const n=e.getAttribute("data-vike-link");return n!==null&&n!=="false"}else return!0}function On(e){const t=e.getAttribute("target"),n=e.getAttribute("rel");return t==="_blank"||t==="_external"||n==="external"||e.hasAttribute("download")}function $n(e){if(e.startsWith("#"))return!0;const t=n=>n.split("#")[0];return!!(e.includes("#")&&t(e)===t(window.location.href))}function kn(e){const t=Xe();u(Be(t));const{hasBaseServer:n}=M(e,t);return n}function xn(){return!!window._disableAutomaticLinkInterception}function Fn(e,t){let n=Tn(e,t);return n==="viewport"&&!e._isProduction&&(ae(!1,"Viewport prefetching is disabled in development",{onlyOnce:!0}),n="hover"),{prefetchStaticAssets:n}}function Tn(e,t){{const n=En(t);if(n!==null)return n}if("prefetchLinks"in e.exports&&g(!1,"`export { prefetchLinks }` is deprecated, use `export { prefetchStaticAssets }` instead."),"prefetchStaticAssets"in e.exports){const{prefetchStaticAssets:n}=e.exports;if(n===!1)return!1;if(n==="hover")return"hover";if(n==="viewport")return"viewport";const r="prefetchStaticAssets value should be false, 'hover', or 'viewport'";g(O(n),r);const o=Object.keys(n);g(o.length===1&&o[0]==="when",r);const{when:i}=n;if(i==="HOVER"||i==="VIEWPORT"){const a=i.toLowerCase();return R(!1,`prefetchStaticAssets value \`{ when: '${i}' }\` is outdated: set prefetchStaticAssets to '${a}' instead`,{onlyOnce:!0}),a}g(!1,r)}return"hover"}function En(e){const t=e.getAttribute("data-prefetch-static-assets"),n=e.getAttribute("data-prefetch");if(t===null&&n===null)return null;const r="The attribute data-prefetch is outdated, use data-prefetch-static-assets instead.";if(t){if(g(n===null,r),t==="hover"||t==="viewport")return t;if(t==="false")return!1;g(!1,`data-prefetch-static-assets has value "${t}" but it should instead be "false", "hover", or "viewport"`)}if(n){if(u(!t),R(!1,r,{onlyOnce:!0}),n==="true")return"viewport";if(n==="false")return"hover";g(!1,`data-prefetch has value "${n}" but it should instead be "true" or "false"`)}u(!1)}const et=new Map;function Hn(e){const t=tt(e);return et.has(t)}function In(e){const t=tt(e);et.set(t,!0)}function tt(e){return M(e,"/").pathname}function B(e){return e.fileType===".css"?[]:e.exportNames?e.exportNames:(u(e.fileExports,e.filePath),Object.keys(e.fileExports))}function An({pageFilesClientSide:e,pageFilesServerSide:t,pageId:n}){return{isHtmlOnly:r(),isClientRouting:i()};function r(){return t.some(s=>s.pageId===n&&s.fileType===".page")?(o(),!1):!(!t.some(s=>s.pageId===n&&s.fileType===".page.server")||e.some(s=>s.pageId===n&&s.fileType===".page.client"&&B(s).includes("render")))}function o(){const a=e.some(s=>B(s).includes("render"));g(a,["No client-side `render()` hook found.","See https://vike.dev/render-modes for more information.",["Loaded client-side page files (none of them `export { render }`):",...e.map((s,l)=>` (${l+1}): ${s.filePath}`)].join(`
`)].join(" "))}function i(){return e.some(s=>B(s).includes("clientRouting"))}}function Bn({pageFilesClientSide:e,pageFilesServerSide:t,isHtmlOnly:n,isClientRouting:r}){let o=[];const i=t.filter(s=>!e.includes(s)),a=[];if(a.push(...e.map(s=>({id:s.filePath,onlyAssets:!1,eagerlyImported:!1}))),a.push(...i.map(s=>({id:s.filePath,onlyAssets:!0,eagerlyImported:!1}))),n)o=e.map(s=>s.filePath);else{const s=Nn(r);a.push({id:s,onlyAssets:!1,eagerlyImported:!1}),o=[s]}return{clientEntries:o,clientDependencies:a}}function Nn(e){return e?"@@vike/dist/esm/client/client-routing-runtime/entry.js":"@@vike/dist/esm/client/server-routing-runtime/entry.js"}function jn(e,t){let n=Ne(e,t);const r=Fe(e,t),{isHtmlOnly:o,isClientRouting:i}=An({pageFilesClientSide:n,pageFilesServerSide:r,pageId:t});o&&(n=n.filter(l=>l.isEnv("CLIENT_ONLY")&&!B(l).includes("render")),n=Wn(n));const{clientEntries:a,clientDependencies:s}=Bn({pageFilesClientSide:n,pageFilesServerSide:r,isHtmlOnly:o,isClientRouting:i});return{isHtmlOnly:o,isClientRouting:i,clientEntries:a,clientDependencies:s,pageFilesClientSide:n,pageFilesServerSide:r}}async function Ln(e,t,{sharedPageFilesAlreadyLoaded:n}){const r=Ne(e,t);await Promise.all(r.map(async o=>{var i;u(o.isEnv("CLIENT_ONLY")||o.isEnv("CLIENT_AND_SERVER")),!(n&&o.isEnv("CLIENT_AND_SERVER"))&&await((i=o.loadExportNames)==null?void 0:i.call(o))}))}function Wn(e){const t=[];for(const n of e)if(t.push(n),B(n).includes("overrideDefaultPages"))break;return t}function Dn(e,t,n){var r,o,i,a;if(e){const s=(o=(r=E(e,"clientRouting","boolean"))==null?void 0:r.value)!=null?o:!1;return{isClientSideRenderable:(a=(i=E(e,"isClientSideRenderable","boolean"))==null?void 0:i.value)!=null?a:!1,isClientRouting:s}}else{const{isHtmlOnly:s,isClientRouting:l}=jn(t,n);return{isClientSideRenderable:!s,isClientRouting:l}}}async function nt(e,t){await Ln(t._pageFilesAll,e,{sharedPageFilesAlreadyLoaded:!1});const n=wt(t._pageConfigs,e),{isClientSideRenderable:r,isClientRouting:o}=Dn(n,t._pageFilesAll,e);return r&&o}const rt="@",te=":";function Un(e,t="Invalid"){let n=`${t} Route String ${k(e)}`;g(e!=="",`${n} (empty string): set it to ${k("/")} instead`),g(["/","*"].includes(e[0]),`${n}: it should start with ${k("/")} or ${k("*")}`),g(!e.includes("**"),`${n}: set it to ${k(e.split("**").join("*"))} instead`)}function ne(e,t){Un(e);const n=ot(e),r=n.map(f=>f.param?"[^/]+":f.glob?f.isLastDir?"|/.*":".*":It(f.static)).map(f=>`(${f})`).join(""),o=new RegExp(`^${r}/?$`),i=t.match(o);if(!i)return null;const a={},[s,...l]=i;let d=0;const b=n.filter(f=>f.glob).length>1;return n.forEach((f,c)=>{let y=l[c];if(f.param&&(a[f.param]=y),f.glob){const $=`*${b?++d:""}`;f.isLastDir&&(y=y.slice(1)),a[$]=y}}),{routeParams:a}}function ot(e){const t=[],n=o=>{const i=t[t.length-1];i!=null&&i.static?i.static+=o:t.push({static:o})},r=e.split("/");return r.forEach((o,i)=>{const a=i===0,s=i===r.length-1;Vn(o)?(R(!o.startsWith(te),`Outdated Route String ${k(e)}, use ${k(e.split(te).join(rt))} instead`,{onlyOnce:!0}),a||n("/"),t.push({param:o.slice(1)})):o==="*"&&s&&e!=="*"&&e!=="/*"?t.push({glob:!0,isLastDir:!0}):(a||n("/"),o.split("*").forEach((l,d)=>{d!==0&&t.push({glob:!0}),l!==""&&n(l)}))}),t}function L(e){const t=ot(e),n=s=>(s==null?void 0:s.split("/").filter(Boolean).length)||0;let r=0;for(const s of t){if(!s.static)break;r+=n(s.static)}const o=t.map(s=>n(s.static)).reduce((s,l)=>s+l,0),i=t.filter(s=>s.param).length,a=t.filter(s=>s.glob).length;return{numberOfStaticPartsBeginning:r,numberOfStaticParts:o,numberOfParams:i,numberOfGlobs:a}}function Vn(e){return e.startsWith(rt)||e.startsWith(te)}function Se(e){const n=ne(e,e);return u(n),Object.keys(n.routeParams).length===0}function k(e){return Y()?`'${e}'`:(e===""&&(e="''"),h.cyan(e))}function zn(e){e.sort(Kn).sort(F(t=>t.routeType==="FUNCTION"&&!!t.precedence&&t.precedence<0)).sort(F(t=>t.routeType==="STRING"&&Se(t.routeString)===!1)).sort(F(t=>t.routeType==="FUNCTION"&&!t.precedence)).sort(F(t=>t.routeType==="STRING"&&Se(t.routeString)===!0)).sort(F(t=>t.routeType==="FILESYSTEM")).sort(F(t=>t.routeType==="FUNCTION"&&!!t.precedence&&t.precedence>0))}function Kn(e,t){var n,r;{const o=(n=e.precedence)!=null?n:0,i=(r=t.precedence)!=null?r:0;if(o!==i)return o>i?-1:1}if(!t.routeString||!e.routeString)return 0;{const i=D(a=>L(a).numberOfStaticPartsBeginning)(e.routeString,t.routeString);if(i!==0)return i}{const i=D(a=>L(a).numberOfStaticParts)(e.routeString,t.routeString);if(i!==0)return i}{const i=Rt(a=>L(a).numberOfGlobs)(e.routeString,t.routeString);if(i!==0)return i}{const i=D(a=>L(a).numberOfParams)(e.routeString,t.routeString);if(i!==0)return i}return 0}async function Gn(e){const t={};if(!e._onBeforeRouteHook)return null;const n=await Mn(e._onBeforeRouteHook,e);return n&&(p(t,n),P(t,"_pageId","string")||P(t,"_pageId","null"))?(P(t,"routeParams")?u(P(t,"routeParams","object")):p(t,{routeParams:{}}),p(t,{_routingProvidedByOnBeforeRouteHook:!0,_debugRouteMatches:"CUSTOM_ROUTING"}),t):(p(t,{_routingProvidedByOnBeforeRouteHook:!1}),t)}async function Mn(e,t){let n=e.onBeforeRoute(t);Je(n,`The onBeforeRoute() hook ${e.hookFilePath}`),n=await n;const r=`The onBeforeRoute() hook defined by ${e.hookFilePath}`;if(g(n==null||Gt(n,["pageContext"])&&P(n,"pageContext"),`${r} should return ${h.cyan("null")}, ${h.cyan("undefined")}, or a plain JavaScript object ${h.cyan("{ pageContext: { /* ... */ } }")}`),n==null)return null;if(g(P(n,"pageContext","object"),`${r} returned ${h.cyan("{ pageContext }")} but pageContext should be a plain JavaScript object.`),P(n.pageContext,"_pageId")&&!P(n.pageContext,"_pageId","null")){const a=`${r} returned ${h.cyan("{ pageContext: { _pageId } }")} but ${h.cyan("_pageId")} should be`;g(P(n.pageContext,"_pageId","string"),`${a} a string or null`),g(t._allPageIds.includes(n.pageContext._pageId),`${a} ${Yt(t._allPageIds.map(s=>h.cyan(s)),"or")}`)}P(n.pageContext,"routeParams")&&Qe(n.pageContext,`${r} returned ${h.cyan("{ pageContext: { routeParams } }")} but routeParams should`);const o=a=>`${r} returned ${h.cyan(`{ pageContext: { ${a} } }`)} which is deprecated. Return ${h.cyan("{ pageContext: { urlLogical } }")} instead.`;P(n.pageContext,"url")&&(R(!1,o("url"),{onlyOnce:!0}),n.pageContext.urlLogical=n.pageContext.url,delete n.pageContext.url),P(n.pageContext,"urlOriginal")&&(R(!1,o("urlOriginal"),{onlyOnce:!0}),n.pageContext.urlLogical=n.pageContext.urlOriginal,delete n.pageContext.urlOriginal),P(n.pageContext,"urlLogical")&&St(n.pageContext.urlLogical,`${r} returned ${h.cyan("{ pageContext: { urlLogical } }")} but ${h.cyan("urlLogical")}`),De(n.pageContext,{hookFilePath:e.hookFilePath,hookName:"onBeforeRoute"});const i={};return p(i,n.pageContext),i}var W;function ve(...e){var t;W||(W=(t=globalThis.__brillout_debug_createDebugger)==null?void 0:t.call(globalThis,"vike:routing")),W&&W(...e)}Y()&&K();async function it(e){ve("Pages routes:",e._pageRoutes),Me(e);const t={},n=await Gn(e);if(n){if(n._routingProvidedByOnBeforeRouteHook)return u(n._pageId),n;p(t,n)}const r={};p(r,e),p(r,n);const o=r._allPageIds;u(o.length>=0),g(r._pageFilesAll.length>0||r._pageConfigs.length>0,"No *.page.js file found. You must create at least one *.page.js file."),g(o.length>0,"You must create at least one *.page.js file that isn't _default.page.*");const{urlPathname:i}=r;u(i.startsWith("/"));const a=[];await Promise.all(r._pageRoutes.map(async l=>{const{pageId:d,routeType:b}=l;if(l.routeType==="FILESYSTEM"){const{routeString:f}=l,c=ne(f,i);if(c){const{routeParams:y}=c;a.push({pageId:d,routeParams:y,routeString:f,routeType:b})}return}if(l.routeType==="STRING"){const{routeString:f}=l,c=ne(f,i);if(c){const{routeParams:y}=c;u(b==="STRING"),a.push({pageId:d,routeString:f,routeParams:y,routeType:b})}return}if(l.routeType==="FUNCTION"){const{routeFunction:f,routeDefinedAt:c}=l,y=await yn(f,r,c);if(y){const{routeParams:$,precedence:N}=y;a.push({pageId:d,precedence:N,routeParams:$,routeType:b})}return}u(!1)})),zn(a);const s=a[0];if(ve(`Route matches for URL ${h.cyan(i)} (in precedence order):`,a),p(t,{_debugRouteMatches:a}),!s)return p(t,{_pageId:null,routeParams:{}}),t;{const{routeParams:l}=s;u(O(l)),p(t,{_pageId:s.pageId,routeParams:s.routeParams})}return t}K();const _e=x("prefetch.ts",{linkPrefetchHandlerAdded:new Map});async function Yn(e,t){try{await U(e,t)}catch(n){if(ue(n))ie(n,!0);else throw n}}function qn(e){In(e.urlPathname),[...document.getElementsByTagName("A")].forEach(n=>{if(_e.linkPrefetchHandlerAdded.has(n))return;_e.linkPrefetchHandlerAdded.set(n,!0);const r=n.getAttribute("href");if(_n(n)||(u(r),Hn(r)))return;const{prefetchStaticAssets:o}=Fn(e,n);if(o&&(o==="hover"&&(n.addEventListener("mouseover",()=>{ee(r)}),n.addEventListener("touchstart",()=>{ee(r)},{passive:!0})),o==="viewport")){const i=new IntersectionObserver(a=>{a.forEach(s=>{s.isIntersecting&&(ee(r),i.disconnect())})});i.observe(n)}})}async function ee(e){const t=await Ze(e);let n;try{n=await it(t)}catch{return}n!=null&&n._pageId&&await nt(n._pageId,t)&&await Yn(n._pageId,t)}const re=x("history.ts",{});function Jn(){let e=window.history.state;e||(e={});let t=!1;"timestamp"in e||(t=!0,e.timestamp=de()),"scrollPosition"in e||(t=!0,e.scrollPosition=fe()),"triggedBy"in e||(e.triggedBy="browser"),st(e),t&&ge(e)}function ce(){const e=window.history.state||{};return st(e),e}function fe(){return{x:window.scrollX,y:window.scrollY}}function de(){return new Date().getTime()}function Ce(){const e=fe(),t=ce();ge({...t,scrollPosition:e})}function Qn(e,t){if(t)ge(ce(),e);else{const n=de();Xn({timestamp:n,scrollPosition:null,triggedBy:"vike"},e)}}function st(e){if(u(C(e)),"timestamp"in e){const{timestamp:t}=e;u(typeof t=="number")}if("scrollPosition"in e){const{scrollPosition:t}=e;t!==null&&u(P(t,"x","number")&&P(t,"y","number"))}}function ge(e,t){window.history.replaceState(e,"",t!=null?t:null)}function Xn(e,t){at(e,"",t)}function yr(){var e;re.pushStateOriginal=(e=re.pushStateOriginal)!=null?e:window.history.pushState,window.history.pushState=(t={},...n)=>{g(t==null||C(t),"history.pushState(state) argument state must be an object");const r={scrollPosition:fe(),timestamp:de(),...t,triggedBy:"user"};return at(r,...n)}}function at(...e){re.pushStateOriginal.apply(history,e)}function ut(e){if(e==="preserve-scroll")return;let t;if(e==="scroll-to-top-or-hash"){const n=er();if(n&&n!=="top"){const r=document.getElementById(n)||document.getElementsByName(n)[0];if(r){r.scrollIntoView();return}}t={x:0,y:0}}else u("x"in e&&"y"in e),t=e;Zn(t)}function Zn(e){const t=()=>window.scrollTo(e.x,e.y),n=()=>window.scrollX===e.x&&window.scrollY===e.y;n()||(t(),!n()&&requestAnimationFrame(()=>{t(),!n()&&setTimeout(async()=>{if(t(),n())return;const r=new Date().getTime();for(;;)if(await kt(10),t(),n()||new Date().getTime()-r>100)return},0)}))}function er(){let{hash:e}=window.location;return e===""?null:(u(e.startsWith("#")),e=e.slice(1),e)}function br(){window.addEventListener("scroll",xt(Ce,Math.ceil(1e3/3)),{passive:!0}),Le(Ce)}const T=x("onBrowserHistoryNavigation.ts",{previousState:z()});function Pr(){window.addEventListener("popstate",()=>{const e=z(),t=e.historyState.scrollPosition||"scroll-to-top-or-hash",n=e.historyState.triggedBy==="user",r=e.urlWithoutHash===T.previousState.urlWithoutHash,o=!e.historyState.timestamp||!T.previousState.historyState.timestamp?null:e.historyState.timestamp<T.previousState.historyState.timestamp;T.previousState=e,r&&!n?window.history.state===null?(Jn(),T.previousState=z()):ut(t):oe({scrollTarget:t,isBackwardNavigation:o,isUserLandPushStateNavigation:n})})}function z(){return{urlWithoutHash:le({withoutHash:!0}),historyState:ce()}}function tr(){T.previousState=z()}const lt=x("scrollRestoration.ts",{});function wr(){Oe(),Le(Oe),Ft(()=>lt.initialRenderIsDone&&he())}function nr(){lt.initialRenderIsDone=!0}function he(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual")}function Oe(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="auto")}const w=x("renderPageClientSide.ts",{renderCounter:0});async function oe(e){var me,ye;const{scrollTarget:t,urlOriginal:n=le(),overwriteLastHistoryEntry:r=!1,isBackwardNavigation:o,pageContextsFromRewrite:i=[],redirectCount:a=0,isUserLandPushStateNavigation:s,isClientSideNavigation:l=!0}=e,{abortRender:d,setHydrationCanBeAborted:b,isFirstRender:f}=ir();if(u(l===!f),nn(i.length,a),w.clientRoutingIsDisabled){V(n);return}const c=await Ze(n);if(d())return;p(c,{isBackwardNavigation:o,isClientSideNavigation:l});{const m=en(i);p(c,m)}let y={};const $=m=>{u(m),u(!("err"in y)),u(!("errorWhileRendering"in c)),y.err=m,c.errorWhileRendering=m};if(!f){try{y={pageContextFromRoute:await it(c)}}catch(m){$(m)}if(d())return;if(y.pageContextFromRoute){const{pageContextFromRoute:m}=y;p(c,m);let S;if(!m._pageId)S=!1;else if(S=await nt(m._pageId,c),d())return;if(!S){V(n);return}const _=m._pageId&&((me=w.previousPageContext)==null?void 0:me._pageId)&&m._pageId===w.previousPageContext._pageId;if(s&&_)return}}const N=!f;if(N&&!w.isTransitioning&&(await((ye=w.onPageTransitionStart)==null?void 0:ye.call(w,c)),w.isTransitioning=!0,d()))return;if(f){u(!y.pageContextFromRoute),u(!y.err);try{y.pageContextFromHooks=await rn(c)}catch(m){$(m)}if(d())return}else if(!y.err){const{pageContextFromRoute:m}=y;u(m),u(m._pageId),u(P(m,"_pageId","string")),p(c,m);try{y.pageContextFromHooks=await sn(c)}catch(S){$(S)}if(d())return}if("err"in y){const{err:m}=y;if(we(m)||console.error(m),$e(m,c,f))return;if(we(m)){const S=m;Zt(m,c._isProduction,c);const _=S._pageContextAbort;if(_._urlRewrite){await oe({...e,scrollTarget:"scroll-to-top-or-hash",pageContextsFromRewrite:[...i,_]});return}if(_._urlRedirect){const q=_._urlRedirect.url;if(q.startsWith("http")){window.location.href=q;return}else await oe({...e,scrollTarget:"scroll-to-top-or-hash",urlOriginal:q,overwriteLastHistoryEntry:!1,isBackwardNavigation:!1,redirectCount:a+1});return}u(_.abortStatusCode),p(c,_),_.abortStatusCode===404&&p(c,{is404:!0})}else p(c,{is404:!1});try{y.pageContextFromHooks=await on(c)}catch(S){if($e(S,c,f)||(f||setTimeout(()=>{window.location.pathname=n},0),$t(m,S)))return;throw S}if(d())return}const{pageContextFromHooks:pe}=y;if(u(pe),p(c,pe),J(c,"onPageTransitionStart"),w.onPageTransitionStart=c.exports.onPageTransitionStart,c.exports.hydrationCanBeAborted?b():R(!Ot(),"You seem to be using React; we recommend setting hydrationCanBeAborted to true, see https://vike.dev/clientRouting",{onlyOnce:!0}),!d()&&!(w.renderPromise&&(await w.renderPromise,u(w.renderPromise===void 0),d()))){if(rr(n,r),w.previousPageContext=c,u(w.renderPromise===void 0),w.renderPromise=(async()=>{await vt(c,!0),qn(c),w.renderPromise=void 0})(),await w.renderPromise,u(w.renderPromise===void 0),f){J(c,"onHydrationEnd");const{onHydrationEnd:m}=c.exports;if(m){const S=c.exportsAll.onHydrationEnd[0].exportSource;if(u(S),await se(()=>m(c),"onHydrationEnd",S),d(!0))return}}if(!d(!0)){if(N){if(c.exports.onPageTransitionEnd&&(J(c,"onPageTransitionEnd"),await c.exports.onPageTransitionEnd(c),d(!0)))return;w.isTransitioning=void 0}ut(t),he(),nr()}}}function rr(e,t){le()!==e&&(he(),Qn(e,t),tr())}function $e(e,t,n){return!!(fn(e)||or(e,t,n))}function or(e,t,n){if(!ue(e))return!1;if(n)throw ie(e,!1),e;return ie(e,!0),V(t.urlOriginal),!0}function ie(e,t){u(ue(e)),w.clientRoutingIsDisabled=!0,t&&console.log(e),ae(!1,["Failed to fetch static asset.","This usually happens when a new frontend is deployed.","Falling back to Server Routing.","(The next page navigation will use Server Routing instead of Client Routing.)"].filter(Boolean).join(" "),{onlyOnce:!0})}function ir(){const e=++w.renderCounter;u(e>=1);let t=!1;return{abortRender:o=>!o&&e===1&&!t?!1:e!==w.renderCounter,setHydrationCanBeAborted:()=>{t=!0},isFirstRender:e===1}}function Rr(){return w.renderCounter}const sr=(e,t)=>{const n=e[t];return n?typeof n=="function"?n():Promise.resolve(n):new Promise((r,o)=>{(typeof queueMicrotask=="function"?queueMicrotask:setTimeout)(o.bind(null,new Error("Unknown variable dynamic import: "+t)))})};var v=(e=>(e["zh-CN"]="zh-CN",e["zh-HK"]="zh-HK",e["en-US"]="en-US",e))(v||{}),ct=(e=>(e["zh-CN"]="zh-CN",e["zh-HK"]="zh-HK",e["en-US"]="en-US",e["zh-cn"]="zh-CN",e["zh-hk"]="zh-HK",e["en-us"]="en-US",e))(ct||{});const H=Object.values(v),Sr={"en-US":"English","zh-CN":"简体中文","zh-HK":"繁體中文"},vr=H.map(e=>`/${e}`);function _r(){let e={};return H.forEach(t=>{e[t]={}}),e}const ar=(e,t)=>"other",ur=(e,t)=>{const n=String(e).split("."),r=!n[1],o=Number(n[0])==e,i=o&&n[0].slice(-1),a=o&&n[0].slice(-2);return t?i==1&&a!=11?"one":i==2&&a!=12?"two":i==3&&a!=13?"few":"other":e==1&&r?"one":"other"},ke=ar;v["en-US"];I.loadLocaleData({[v["en-US"]]:{plurals:ur},[v["zh-CN"]]:{plurals:ke},[v["zh-HK"]]:{plurals:ke}});const xe={};async function lr(e){const t=xe[e];if(t){I.load(e,t),I.activate(e);return}const{messages:n}=await sr(Object.assign({"../locales/en-US/messages.ts":()=>Q(()=>import("./chunk-26cbb25d.js"),[]),"../locales/zh-CN/messages.ts":()=>Q(()=>import("./chunk-c885d520.js"),[]),"../locales/zh-HK/messages.ts":()=>Q(()=>import("./chunk-1461d201.js"),[])}),`../locales/${e}/messages.ts`);xe[e]=n,I.load(e,n),I.activate(e)}v["en-US"];function cr(e){let t=[];return e.forEach(n=>{const r=t.length-1;H.includes(t[r])&&H.includes(n)?t.splice(r,r,n):t.push(n)}),t}function Cr(e){const t=cr(e.split("/"));let n,r;const o=t[1];return H.includes(o)?(n=o,r=`/${t.slice(2).join("/")}`):(n=null,r=e),{locale:n,urlWithoutLocale:r}}function Or(e){{const{setLocale:t}=_t.getState();t(e),lr(e)}}const $r=e=>{if(!e)return;if(/^http/.test(e))return e.charAt(0)==="/"?e:`/${e}`;let t=e;return H.forEach(n=>{if(e.includes(n)){const r=e[0]==="/"?RegExp(`^/${n}`,"i"):RegExp(`^${n}`,"i");t=e.replace(r,"")}}),t.charAt(0)==="/"?t:`/${t}`};function fr(e){return(e||"").toLowerCase().includes("zh-cn")}function dr(e){return(e||"").includes("zh-")?fr(e)?v["zh-CN"]:v["zh-HK"]:v["en-US"]}function kr(e,t){if(e){const r=ct[e];if(r)return r}return dr(t)}export{Sr as I,oe as a,wr as b,br as c,Or as d,Cr as e,v as f,Rr as g,_r as h,Jn as i,kr as j,lr as k,vr as l,yr as m,Pr as o,$r as r,_n as s};
