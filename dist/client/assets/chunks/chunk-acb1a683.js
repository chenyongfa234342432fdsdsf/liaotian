function H(){return typeof window<"u"&&typeof window.scrollY=="number"}function be(){return!(typeof process>"u"||!process.cwd||!process.versions||typeof process.versions.node>"u"||!process.release||process.release.name!=="node")}function B(e,t){let n;{var r=Error.stackTraceLimit;Error.stackTraceLimit=1/0,n=new Error(e),Error.stackTraceLimit=r}return be()&&(n.stack=$e(n.stack,t)),n}function $e(e,t){if(!e)return e;const n=Te(e);let r=0;return n.filter(s=>s.includes(" (internal/")||s.includes(" (node:internal")?!1:r<t&&Re(s)?(r++,!1):!0).join(`
`)}function Re(e){return e.startsWith("    at ")}function Te(e){return e.split(/\r?\n/)}function k(e,t){const n=globalThis.__vike=globalThis.__vike||{};return n[e]=n[e]||t}function v(e){return typeof e=="object"&&e!==null}function M(e){return Array.from(new Set(e))}const S=k("assertPackageInstances.ts",{instances:[],alreadyLogged:new Set}),oe="The client runtime of Server Routing as well as the client runtime of Client Routing are both being loaded. Make sure they aren't loaded both at the same time for a given page. See https://vike.dev/client-runtimes-conflict",J="Two vike client runtime instances are being loaded. Make sure your client-side bundles don't include vike twice. (In order to reduce the size of your client-side JavaScript bundles.)";function Y(){{const e=M(S.instances);ke(e.length<=1,`Both vike@${e[0]} and vike@${e[1]} loaded. Only one version should be loaded.`)}S.checkSingleInstance&&S.instances.length>1&&I(!1,J,{onlyOnce:!0,showStackTrace:!0})}function Mt(e){I(S.isClientRouting!==!0,oe,{onlyOnce:!0,showStackTrace:!0}),I(S.isClientRouting===void 0,J,{onlyOnce:!0,showStackTrace:!0}),S.isClientRouting=!1,e&&(S.checkSingleInstance=!0),Y()}function Jt(e){I(S.isClientRouting!==!1,oe,{onlyOnce:!0,showStackTrace:!0}),I(S.isClientRouting===void 0,J,{onlyOnce:!0,showStackTrace:!0}),S.isClientRouting=!0,e&&(S.checkSingleInstance=!0),Y()}function Pe(e){S.instances.push(e),Y()}function ke(e,t){if(e)return;const n=`[vike][Wrong Usage] ${t}`;throw new Error(n)}function I(e,t,{onlyOnce:n,showStackTrace:r}){if(e)return;const i=`[vike][Warning] ${t}`;if(n){const{alreadyLogged:s}=S,l=n===!0?i:n;if(s.has(l))return;s.add(l)}console.warn(r?new Error(i):i)}const Ie="0.4.147",T={projectName:"Vike",projectVersion:Ie,npmPackageName:"vike",githubRepository:"https://github.com/vikejs/vike"};Pe(T.projectVersion);const ae=new Proxy(e=>e,{get:()=>ae}),w=ae,y=k("utils/assert.ts",{alreadyLogged:new Set,logger(e,t){t==="info"?console.log(e):console.warn(e)},showStackTraceList:new WeakSet}),Oe=`[${T.npmPackageName}]`,_e=`[${T.npmPackageName}@${T.projectVersion}]`,q=2;function o(e,t){var l;if(e)return;const n=(()=>{if(!t)return null;const a=typeof t=="string"?t:JSON.stringify(t);return w.dim(`Debug info (for ${T.projectName} maintainers; you can ignore this): ${a}`)})(),r=`${T.githubRepository}/issues/new`;let i=[`You stumbled upon a bug in ${T.projectName}'s source code.`,`Go to ${w.blue(r)} and copy-paste this error; a maintainer will fix the bug (usually under 24 hours).`,n].filter(Boolean).join(" ");i=_(i),i=W(i,"Bug"),i=j(i,!0);const s=B(i,q);throw(l=y.onBeforeLog)==null||l.call(y),s}function p(e,t,{showStackTrace:n}={}){var i;if(e)return;t=_(t),t=W(t,"Wrong Usage"),t=j(t);const r=B(t,q);throw n&&y.showStackTraceList.add(r),(i=y.onBeforeLog)==null||i.call(y),r}function je(e){return e=_(e),e=W(e,"Error"),e=j(e),B(e,q)}function O(e,t,{onlyOnce:n,showStackTrace:r}){var i;if(!e){if(t=_(t),t=W(t,"Warning"),t=j(t),n){const{alreadyLogged:s}=y,l=n===!0?t:n;if(s.has(l))return;s.add(l)}if((i=y.onBeforeLog)==null||i.call(y),r){const s=new Error(t);y.showStackTraceList.add(s),y.logger(s,"warn")}else y.logger(t,"warn")}}function Yt(e,t,{onlyOnce:n}){var r;if(!e){if(t=_(t),t=j(t),n){const{alreadyLogged:i}=y,s=t;if(i.has(s))return;i.add(s)}(r=y.onBeforeLog)==null||r.call(y),y.logger(t,"info")}}function W(e,t){let n=`[${t}]`;const r=t==="Warning"?"yellow":"red";return n=w.bold(w[r](n)),`${n}${e}`}function _(e){return e.startsWith("[")?e:` ${e}`}function j(e,t=!1){return`${t?_e:Oe}${e}`}function xe(){o(H())}const C=k("utils/assertRouterType.ts",{});function qt(){le(Ce()),C.isClientRouting=!0}function Ce(){return C.isClientRouting!==!1}function Xt(){le(C.isClientRouting!==!0),C.isClientRouting=!1}function le(e){p(H(),`${w.cyan("import { something } from 'vike/client/router'")} is forbidden on the server-side`,{showStackTrace:!0}),O(e,"You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.",{showStackTrace:!0,onlyOnce:!0})}function Le(){xe()}function Z(e){const t=e/1e3;if(t<120){const n=ee(t);return`${n} second${te(n)}`}{const n=t/60,r=ee(n);return`${r} minute${te(r)}`}}function ee(e){let t=e.toFixed(1);return t.endsWith(".0")&&(t=t.slice(0,-2)),t}function te(e){return e==="1"?"":"s"}const Fe=k("utils/executeHook.ts",{userHookErrors:new Map});function We(e,t,n){const{timeoutErr:r,timeoutWarn:i}=Ae(t);let s,l;const a=new Promise((f,h)=>{s=g=>{c(),f(g)},l=g=>{c(),h(g)}}),c=()=>{clearTimeout(u),clearTimeout(d)},u=setTimeout(()=>{O(!1,`The ${t}() hook defined by ${n} is taking more than ${Z(i)}`,{onlyOnce:!1})},i),d=setTimeout(()=>{const f=je(`Hook timeout: the ${t}() hook defined by ${n} didn't finish after ${Z(r)}`);l(f)},r);return(async()=>{try{const f=await e();s(f)}catch(f){v(f)&&Fe.userHookErrors.set(f,{hookName:t,hookFilePath:n}),l(f)}})(),a}function Ae(e){return e==="onBeforeRoute"?{timeoutErr:5*1e3,timeoutWarn:1*1e3}:e==="onBeforePrerender"?{timeoutErr:10*60*1e3,timeoutWarn:30*1e3}:{timeoutErr:40*1e3,timeoutWarn:4*1e3}}function L(e,t,n){return typeof e=="string"?ne(e.split(""),t,n).join(""):ne(e,t,n)}function ne(e,t,n){const r=[];let i=t>=0?t:e.length+t;o(i>=0&&i<=e.length);let s=n>=0?n:e.length+n;for(o(s>=0&&s<=e.length);!(i===s||(i===e.length&&(i=0),i===s));){const l=e[i];o(l!==void 0),r.push(l),i++}return r}const ce=["http://","https://","tauri://"];function ue(e){return ce.some(t=>e.startsWith(t))||e.startsWith("/")||e.startsWith(".")||e.startsWith("?")||e.startsWith("#")||e===""}function Kt(e,t){o(t.includes(" but ")),p(typeof e=="string",`${t} should be a string`),!ue(e)&&(!e.startsWith("/")&&!e.includes(":")?p(!1,`${t} is ${w.cyan(e)} and it should be /${w.cyan(e)} instead (URL pathnames should start with a leading slash)`):p(!1,`${t} isn't a valid URL`))}function Ve(e,t){o(ue(e)),o(t.startsWith("/"));const[n,...r]=e.split("#");o(n!==void 0);const i=["",...r].join("#")||null;o(i===null||i.startsWith("#"));const s=i===null?"":z(i.slice(1)),[l,...a]=n.split("?");o(l!==void 0);const c=["",...a].join("?")||null;o(c===null||c.startsWith("?"));const u={},d={};Array.from(new URLSearchParams(c||"")).forEach(([b,Q])=>{u[b]=Q,d[b]=[...d.hasOwnProperty(b)?d[b]:[],Q]});const{origin:f,pathname:h}=ze(l,t);o(f===null||f===z(f)),o(h.startsWith("/")),o(f===null||e.startsWith(f));const g=l.slice((f||"").length);Be(e,f,g,c,i);let{pathname:E,hasBaseServer:$}=Ge(h,t);return E=De(E),o(E.startsWith("/")),{origin:f,pathname:E,pathnameOriginal:g,hasBaseServer:$,search:u,searchAll:d,searchOriginal:c,hash:s,hashOriginal:i}}function z(e){try{return decodeURIComponent(e)}catch{}try{return decodeURI(e)}catch{}return e}function De(e){return e=e.split("/").map(t=>z(t).split("/").join("%2F")).join("/"),e=e.replace(/\s/g,""),e}function ze(e,t){var n;{const{origin:r,pathname:i}=D(e);if(r)return{origin:r,pathname:i};o(i===e)}if(e.startsWith("/"))return{origin:null,pathname:e};{let r=typeof window<"u"&&((n=window==null?void 0:window.document)==null?void 0:n.baseURI);r&&(r=D(r).pathname);const s=Ne(e,r||t);return D(s)}}function D(e){if(ce.some(t=>e.startsWith(t))){const[t,n,r,...i]=e.split("/"),s=[t,n,r].join("/"),l=["",...i].join("/")||"/";return{origin:s,pathname:l}}else return{pathname:e,origin:null}}function Ne(e,t){const n=t.split("/"),r=e.split("/");let i=t.endsWith("/");e.startsWith(".")&&n.pop();for(const l in r){const a=r[l];a==""&&l==="0"||a!="."&&(a==".."?n.pop():(i=!1,n.push(a)))}let s=n.join("/");return i&&!s.endsWith("/")&&(s+="/"),s.startsWith("/")||(s="/"+s),s}function Ue(e){o(e.startsWith("/")),o(!e.includes("?")),o(!e.includes("#"))}function Ge(e,t){Ue(e),o(He(t));let n=e;if(o(n.startsWith("/")),o(t.startsWith("/")),t==="/")return{pathname:e,hasBaseServer:!0};let r=t;return t.endsWith("/")&&n===L(t,0,-1)&&(r=L(t,0,-1),o(n===r)),n.startsWith(r)?(o(n.startsWith("/")||n.startsWith("http")),o(n.startsWith(r)),n=n.slice(r.length),n.startsWith("/")||(n="/"+n),o(n.startsWith("/")),{pathname:n,hasBaseServer:!0}):{pathname:e,hasBaseServer:!1}}function He(e){return e.startsWith("/")}function Be(e,t,n,r,i){const s=Me(t,n,r,i);o(e===s)}function Me(e,t,n,r){return`${e||""}${t}${n||""}${r||""}`}function Qt(e){const t=window.location.href,{searchOriginal:n,hashOriginal:r,pathname:i}=Ve(t,"/");let s;return e!=null&&e.withoutHash?s=`${i}${n||""}`:s=`${i}${n||""}${r||""}`,o(s.startsWith("/")),s}function A(e){return e instanceof Function||typeof e=="function"}function m(e,t,n="unknown"){if(!v(e))return!1;if(!(t in e))return n==="undefined";if(n==="unknown")return!0;const r=e[t];return n==="array"?Array.isArray(r):n==="object"?v(r):n==="string[]"?Array.isArray(r)&&r.every(i=>typeof i=="string"):n==="function"?A(r):Array.isArray(n)?typeof r=="string"&&n.includes(r):n==="null"?r===null:n==="undefined"?r===void 0:n==="true"?r===!0:n==="false"?r===!1:typeof r===n}function X(e,t){t&&Object.defineProperties(e,Object.getOwnPropertyDescriptors(t))}Le();const Je=[{is:e=>e===void 0,match:e=>e==="!undefined",serialize:()=>"!undefined",deserialize:()=>{}},{is:e=>e===1/0,match:e=>e==="!Infinity",serialize:()=>"!Infinity",deserialize:()=>1/0},{is:e=>e===-1/0,match:e=>e==="!-Infinity",serialize:()=>"!-Infinity",deserialize:()=>-1/0},{is:e=>typeof e=="number"&&isNaN(e),match:e=>e==="!NaN",serialize:()=>"!NaN",deserialize:()=>NaN},{is:e=>e instanceof Date,match:e=>e.startsWith("!Date:"),serialize:e=>"!Date:"+e.toISOString(),deserialize:e=>new Date(e.slice(6))},{is:e=>typeof e=="bigint",match:e=>e.startsWith("!BigInt:"),serialize:e=>"!BigInt:"+e.toString(),deserialize:e=>{if(typeof BigInt>"u")throw new Error("Your JavaScript environement does not support BigInt. Consider adding a polyfill.");return BigInt(e.slice(8))}},{is:e=>e instanceof RegExp,match:e=>e.startsWith("!RegExp:"),serialize:e=>"!RegExp:"+e.toString(),deserialize:e=>{e=e.slice(8);const t=e.match(/\/(.*)\/(.*)?/),n=t[1],r=t[2];return new RegExp(n,r)}},{is:e=>e instanceof Map,match:e=>e.startsWith("!Map:"),serialize:(e,t)=>"!Map:"+t(Array.from(e.entries())),deserialize:(e,t)=>new Map(t(e.slice(5)))},{is:e=>e instanceof Set,match:e=>e.startsWith("!Set:"),serialize:(e,t)=>"!Set:"+t(Array.from(e.values())),deserialize:(e,t)=>new Set(t(e.slice(5)))},{is:e=>typeof e=="string"&&e.startsWith("!"),match:e=>e.startsWith("!"),serialize:e=>"!"+e,deserialize:e=>e.slice(1)}];function K(e){const t=JSON.parse(e);return fe(t)}function fe(e){return typeof e=="string"?Ye(e):(typeof e=="object"&&e!==null&&Object.entries(e).forEach(([t,n])=>{e[t]=fe(n)}),e)}function Ye(e){for(const{match:t,deserialize:n}of Je)if(t(e))return n(e,K);return e}function Zt(){const e="vike_pageContext",t=document.getElementById(e);p(t,`The element #${e} (which vike automatically injects into the HTML) is missing from the DOM. This may happen if your HTML is malformed. Make sure your HTML isn't malformed, and make sure you don't remove #${e} from the HTML nor from the DOM.`);const n=t.textContent;o(n);const r=K(n);return o(m(r,"_pageId","string")),X(r,{_hasPageContextFromServer:!0}),r}function en(e){return(t,n)=>{const r=e(t),i=e(n);return r===i?0:r>i?-1:1}}function tn(e){return(t,n)=>{const r=e(t),i=e(n);return r===i?0:r<i?-1:1}}function qe(e){return(t,n)=>{const r=e(t),i=e(n);if(o([!0,!1,null].includes(r)),o([!0,!1,null].includes(i)),r===i)return 0;if(r===!0||i===!1)return-1;if(i===!0||r===!1)return 1;o(!1)}}function Xe(e){return qe(t=>{const n=e(t);return n===null?null:!n})}function Ke(e,t){return e.toLowerCase()<t.toLowerCase()?-1:e.toLowerCase()>t.toLowerCase()?1:0}const Qe=e=>e!=null;function de(e){const t=n=>`Not a posix path: ${n}`;o(e!==null,t("null")),o(typeof e=="string",t(`typeof path === ${JSON.stringify(typeof e)}`)),o(e!=="",t("(empty string)")),o(e),o(!e.includes("\\"),t(e))}function P(e){de(e)}function Ze(e,t){return ge(e,t,!0)}function nn(e,t){return ge(e,t,!1)}function ge(e,t,n){const r=n?"CLIENT_ONLY":"SERVER_ONLY",i=e.filter(g=>g.isRelevant(t)&&g.fileType!==".page.route").sort(et(n,t)),s=g=>{const E=i.filter(b=>b.pageId===t&&b.isEnv(g?"CLIENT_AND_SERVER":r));p(E.length<=1,`Merge the following files into a single file: ${E.map(b=>b.filePath).join(" ")}`);const $=E[0];return o($===void 0||!$.isDefaultPageFile),$},l=s(!1),a=s(!0),c=g=>i.filter(E=>E.isRendererPageFile&&E.isEnv(g?"CLIENT_AND_SERVER":r))[0],u=c(!1),d=c(!0),f=i.filter(g=>g.isDefaultPageFile&&!g.isRendererPageFile&&(g.isEnv(r)||g.isEnv("CLIENT_AND_SERVER")));return[l,a,...f,u,d].filter(Qe)}function et(e,t){const n=e?"CLIENT_ONLY":"SERVER_ONLY",r=-1,i=1,s=0;return(l,a)=>{if(!l.isDefaultPageFile&&a.isDefaultPageFile)return r;if(!a.isDefaultPageFile&&l.isDefaultPageFile)return i;{const c=l.isRendererPageFile,u=a.isRendererPageFile;if(!c&&u)return r;if(!u&&c)return i;o(c===u)}{const c=re(t,l.filePath),u=re(t,a.filePath);if(c<u)return r;if(u<c)return i;o(c===u)}{if(l.isEnv(n)&&a.isEnv("CLIENT_AND_SERVER"))return r;if(a.isEnv(n)&&l.isEnv("CLIENT_AND_SERVER"))return i}return s}}function re(e,t){P(e),P(t);let n=0;for(;n<e.length&&n<t.length&&e[n]===t[n];n++);const r=e.slice(n),i=t.slice(n),s=r.split("/").length,l=i.split("/").length;return s+l}function rn(e,t){if(t.length>0){const r=t.filter(i=>i.isErrorPage);return r.length===0?null:(p(r.length===1,"Only one error page can be defined"),r[0].pageId)}const n=M(e.map(({pageId:r})=>r).filter(r=>V(r)));if(p(n.length<=1,`Only one _error.page.js is allowed, but found several: ${n.join(" ")}`),n.length>0){const r=n[0];return o(r),r}return null}function V(e,t){return o(!e.includes("\\")),e.includes("/_error")}function tt(e,t){if(t.length>0){const n=t.find(r=>r.pageId===e);return o(n),!!n.isErrorPage}else return V(e)}function N(e,t){if(!(t in e.exports))return null;const n=e.exports[t],r=e.exportsAll[t][0];if(o(r.exportValue===n),n===null)return null;const i=r.filePath;return o(i),o(!i.endsWith(" ")),nt(n,{hookName:t,hookFilePath:i}),{hookFn:n,hookName:t,hookFilePath:i}}function sn(e,t){N(e,t)}function nt(e,{hookName:t,hookFilePath:n}){o(t&&n),o(!t.endsWith(")")),p(A(e),`Hook ${t}() defined by ${n} should be a function`)}function rt(e){const t=Object.entries(e);for(const n in e)delete e[n];t.sort(([n],[r])=>Ke(n,r)).forEach(([n,r])=>{e[n]=r})}function it(e){st(e),ot(e)}function st(e){tt(e._pageId,e._pageConfigs)&&o(m(e,"is404","boolean"))}function ot(e){if(e.is404===void 0||e.is404===null)return;const t=e.pageProps||{};if(!v(t)){O(!1,"pageContext.pageProps should be an object",{showStackTrace:!0,onlyOnce:!0});return}t.is404=t.is404||e.is404,e.pageProps=t}const at="not-serializable",F=k("getPageContextProxyForUser.ts",{});function lt(e){return o([!0,!1].includes(e._hasPageContextFromServer)),o([!0,!1].includes(e._hasPageContextFromClient)),new Proxy(e,{get(t,n){const r=e[n],i=JSON.stringify(n);return p(r!==at,`pageContext[${i}] couldn't be serialized and, therefore, is missing on the client-side. Check the server logs for more information.`),ct(e,n),r}})}function ct(e,t){if(F.prev===t||F.prev==="__v_raw"||(dt(t),t in e)||ft(t))return;const n=JSON.stringify(t);e._hasPageContextFromServer&&!e._hasPageContextFromClient&&p(!1,`pageContext[${n}] isn't available on the client-side because ${n} is missing in passToClient, see https://vike.dev/passToClient`)}const ut=["then","toJSON"];function ft(e){return!!(ut.includes(e)||typeof e=="symbol"||typeof e!="string"||e.startsWith("__v_"))}function dt(e){F.prev=e,window.setTimeout(()=>{F.prev=void 0},0)}function gt(e,t){if(t){const i=e;o([!0,!1].includes(i.isHydration)),o([!0,!1,null].includes(i.isBackwardNavigation))}else{const i=e;o(i.isHydration===!0),o(i.isBackwardNavigation===null)}o("config"in e),o("configEntries"in e),o("exports"in e),o("exportsAll"in e),o("pageExports"in e),o(v(e.pageExports));const n=e.exports.Page;X(e,{Page:n}),ht(e),rt(e);const r=lt(e);return it(e),r}function ht(e){Object.entries(e).forEach(([t,n])=>{delete e[t],e[t]=n})}const pt=["js","ts","cjs","cts","mjs","mts","jsx","tsx","cjsx","ctsx","mjsx","mtsx"],he=["vue","svelte","marko","md","mdx"],mt=[...pt,...he];function pe(e){const t=mt.some(n=>e.endsWith("."+n));return o(!yt(e)||t),t}function yt(e){return/\.(c|m)?(j|t)sx?$/.test(e)}function Et(e){return he.some(t=>e.endsWith("."+t))}const wt=["clientRouting"];function St(e){wt.forEach(t=>{if(o(e.fileExports),!(t in e.fileExports))return;const n=`The value of \`${t}\` is only allowed to be \`true\`.`;p(e.fileExports[t]!==!1,`${e.filePath} has \`export { ${t} }\` with the value \`false\` which is prohibited: remove \`export { ${t} }\` instead. (${n})`),p(e.fileExports[t]===!0,`${e.filePath} has \`export { ${t} }\` with a forbidden value. ${n}`)})}const me=["render","clientRouting","prerender","doNotPrerender"];function vt(e,t){p(!me.includes(e),`${t} has \`export default { ${e} }\` which is prohibited, use \`export { ${e} }\` instead.`)}function bt(e,t){if(!e)return null;let[n,...r]=e;if(!n||r.length===0&&["*","default",t].includes(n))return null;o(n!=="*");let i="",s="";return n==="default"?i="export default":(i="export",r=[n,...r]),r.forEach(a=>{i=`${i} { ${a}`,s=` }${s}`}),i+s}function ye(e,t,{definedAt:n}){const r=$t(n,t),i=r==="internally"?r:`at ${r}`;let s=`${t}${e==="Hook"?"()":""}`;return`${e} ${w.cyan(s)} defined ${i}`}function $t(e,t){if("isComputed"in e)return"internally";let n;return"files"in e?n=e.files:n=[e],o(n.length>=1),n.map(i=>{const{filePathToShowToUser:s,fileExportPathToShowToUser:l}=i;let a=s;const c=bt(l,t);return c&&(a=`${a} > ${w.cyan(c)}`),a}).join(" / ")}function on(e,t){const n=t.find(r=>r.pageId===e);return o(t.length>0),o(n),n}function Ee({definedAt:e}){if("isComputed"in e||"files"in e)return null;const{filePathToShowToUser:t}=e;return o(t),t}function an({definedAt:e}){const t=Ee({definedAt:e});return o(t),t}function Rt(e,t){const n={},r={},i={};e.forEach(a=>{Tt(a).forEach(({exportName:u,exportValue:d,isFromDefaultExport:f})=>{var h;o(u!=="default"),i[u]=(h=i[u])!=null?h:[],i[u].push({exportValue:d,exportSource:`${a.filePath} > ${f?`\`export default { ${u} }\``:`\`export { ${u} }\``}`,filePath:a.filePath,_filePath:a.filePath,_fileType:a.fileType,_isFromDefaultExport:f})})}),t&&Object.entries(t.configValues).forEach(([a,c])=>{var g,E,$;const{value:u}=c,d=Ee(c),f=ye("Config",a,c);r[a]=(g=r[a])!=null?g:u,n[a]=(E=n[a])!=null?E:[],o(n[a].length===0),n[a].push({configValue:u,configDefinedAt:f,configDefinedByFile:d});const h=a;i[h]=($=i[h])!=null?$:[],i[h].push({exportValue:u,exportSource:f,filePath:d,_filePath:d,_fileType:null,_isFromDefaultExport:null})});const s=Pt(),l={};return Object.entries(i).forEach(([a,c])=>{c.forEach(({exportValue:u,_fileType:d,_isFromDefaultExport:f})=>{var h;l[a]=(h=l[a])!=null?h:u,d===".page"&&!f&&(a in s||(s[a]=u))})}),o(!("default"in l)),o(!("default"in i)),{config:r,configEntries:n,exports:l,exportsAll:i,pageExports:s}}function Tt(e){const{filePath:t,fileExports:n}=e;o(n),o(pe(t));const r=[];return Object.entries(n).sort(Xe(([i])=>i==="default")).forEach(([i,s])=>{let l=i==="default";if(l)if(Et(t))i="Page";else{p(v(s),`The ${w.cyan("export default")} of ${t} should be an object.`),Object.entries(s).forEach(([a,c])=>{vt(a,t),r.push({exportName:a,exportValue:c,isFromDefaultExport:l})});return}r.push({exportName:i,exportValue:s,isFromDefaultExport:l})}),r.forEach(({exportName:i,isFromDefaultExport:s})=>{o(!(s&&me.includes(i)))}),r}function Pt(){return new Proxy({},{get(...e){return H()||O(!1,"`pageContext.pageExports` is outdated. Use `pageContext.exports` instead, see https://vike.dev/exports",{onlyOnce:!0,showStackTrace:!0}),Reflect.get(...e)}})}function kt(e){const t=".page.",n=L(e.split(t),0,-1).join(t);return o(!n.includes("\\")),n}const It=[".page",".page.server",".page.route",".page.client",".css"];function Ot(e){if(de(e),e.endsWith(".css"))return".css";o(pe(e),e);const n=e.split("/").slice(-1)[0].split("."),r=n.slice(-3)[0],i=n.slice(-2)[0];if(i==="page")return".page";if(o(r==="page",e),i==="server")return".page.server";if(i==="client")return".page.client";if(i==="route")return".page.route";o(!1,e)}function we(e){const t=s=>i.pageId===s||i.isDefaultPageFile&&(ie(i.filePath)||_t(s,i.filePath)),n=Ot(e),i={filePath:e,fileType:n,isEnv:s=>{if(o(n!==".page.route"),s==="CLIENT_ONLY")return n===".page.client"||n===".css";if(s==="SERVER_ONLY")return n===".page.server";if(s==="CLIENT_AND_SERVER")return n===".page";o(!1)},isRelevant:t,isDefaultPageFile:U(e),isRendererPageFile:n!==".css"&&U(e)&&ie(e),isErrorPageFile:V(e),pageId:kt(e)};return i}function U(e){return P(e),V(e)?!1:e.includes("/_default")}function ie(e){return P(e),e.includes("/renderer/")}function _t(e,t){P(e),P(t),o(!e.endsWith("/")),o(!t.endsWith("/")),o(U(t));const n=L(t.split("/"),0,-1).filter(r=>r!=="_default").join("/");return e.startsWith(n)}function jt(e){o(Array.isArray(e)),e.forEach(t=>{o(v(t)),o(m(t,"pageId","string")),o(m(t,"routeFilesystem")),o(m(t,"configValuesSerialized")),o(m(t,"configValuesImported"))})}function xt(e){o(m(e,"configValuesImported"))}const Ct=["$$registrations","_rerender_only"],Lt=[".md",".mdx"];function Ft(e,t,n){Wt(e,t,n)}function Wt(e,t,n){const i=Object.keys(e).filter(l=>!Ct.includes(l)),s=i.filter(l=>l!=="default"&&l!==n);if(s.length===0){if(i.length===1)return;{o(i.length===0);let l=`${t} doesn't export any value, but it should have a ${w.cyan("export default")}`;n&&(l+=` or ${w.cyan(`export { ${n} }`)}`),p(!1,l)}}else if(n){if(Lt.some(l=>t.endsWith(l)))return;s.forEach(l=>{O(!1,`${t} should have only a single export: move ${w.cyan(`export { ${l} }`)} to +config.h.js or its own +${s}.js`,{onlyOnce:!0})})}else{const l=s.join(", ");p(!1,`${t} replace ${w.cyan(`export { ${l} }`)} with ${w.cyan(`export default { ${l} }`)}`)}}function G(e){const t={},n=(r,i,s,l)=>{t[r]={value:i,definedAt:{filePathToShowToUser:s,fileExportPathToShowToUser:[r,"default"].includes(l)?[]:[l]}},At(i,r,s)};return e.forEach(r=>{if(r.isValueFile){const{exportValues:i,importPath:s,configName:l}=r;l!=="client"&&Ft(i,s,l),Object.entries(i).forEach(([a,c])=>{const u=a!=="default",d=u?a:r.configName;u&&d in t||n(d,c,s,a)})}else{const{configName:i,importPath:s,exportValue:l,exportName:a}=r;n(i,l,s,a)}}),t}function At(e,t,n){o(!n.includes("+config."))}function Se(e){const t={};return Object.entries(e).forEach(([n,r])=>{const{valueSerialized:i,definedAt:s}=r;o(i),o(!t[n]),t[n]={value:K(i),definedAt:s}}),t}function Vt(e,t){const n=e.map(i=>{const s={};{const{configValuesSerialized:d}=i,f=Se(d);Object.assign(s,f)}{const{configValuesImported:d}=i,f=G(d);Object.assign(s,f)}const{pageId:l,isErrorPage:a,routeFilesystem:c,loadConfigValuesAll:u}=i;return Dt(s),{pageId:l,isErrorPage:a,routeFilesystem:c,configValues:s,loadConfigValuesAll:u}}),r={configValues:{}};{const i=G(t.configValuesImported);Object.assign(r.configValues,i)}return{pageConfigs:n,pageConfigGlobal:r}}function Dt(e){const t="route",n=e[t];if(!n)return;const{value:r}=n,i=typeof r,s=ye("Config",t,n);p(i==="string"||A(r),`${s} has an invalid type '${i}': it should be a string or a function instead, see https://vike.dev/route`)}function zt(e){o(m(e,"isGeneratedFile")),o(e.isGeneratedFile!==!1,"vike was re-installed(/re-built). Restart your app."),o(e.isGeneratedFile===!0,`\`isGeneratedFile === ${e.isGeneratedFile}\``),o(m(e,"pageFilesLazy","object")),o(m(e,"pageFilesEager","object")),o(m(e,"pageFilesExportNamesLazy","object")),o(m(e,"pageFilesExportNamesEager","object")),o(m(e.pageFilesLazy,".page")),o(m(e.pageFilesLazy,".page.client")||m(e.pageFilesLazy,".page.server")),o(m(e,"pageFilesList","string[]")),o(m(e,"pageConfigsSerialized")),o(m(e,"pageConfigGlobalSerialized"));const{pageConfigsSerialized:t,pageConfigGlobalSerialized:n}=e;jt(t),xt(n);const{pageConfigs:r,pageConfigGlobal:i}=Vt(t,n),s={};x(e.pageFilesLazy).forEach(({filePath:a,pageFile:c,globValue:u})=>{var f;c=s[a]=(f=s[a])!=null?f:c;const d=u;se(d),c.loadFile=async()=>{"fileExports"in c||(c.fileExports=await d(),St(c))}}),x(e.pageFilesExportNamesLazy).forEach(({filePath:a,pageFile:c,globValue:u})=>{var f;c=s[a]=(f=s[a])!=null?f:c;const d=u;se(d),c.loadExportNames=async()=>{if(!("exportNames"in c)){const h=await d();p("exportNames"in h,"You seem to be using Vite 2 but the latest vike versions only work with Vite 3"),o(m(h,"exportNames","string[]"),c.filePath),c.exportNames=h.exportNames}}}),x(e.pageFilesEager).forEach(({filePath:a,pageFile:c,globValue:u})=>{var f;c=s[a]=(f=s[a])!=null?f:c;const d=u;o(v(d)),c.fileExports=d}),x(e.pageFilesExportNamesEager).forEach(({filePath:a,pageFile:c,globValue:u})=>{var f;c=s[a]=(f=s[a])!=null?f:c;const d=u;o(v(d)),o(m(d,"exportNames","string[]"),c.filePath),c.exportNames=d.exportNames}),e.pageFilesList.forEach(a=>{var c;s[a]=(c=s[a])!=null?c:we(a)});const l=Object.values(s);return l.forEach(({filePath:a})=>{o(!a.includes("\\"))}),{pageFiles:l,pageConfigs:r,pageConfigGlobal:i}}function x(e){const t=[];return Object.entries(e).forEach(([n,r])=>{o(It.includes(n)),o(v(r)),Object.entries(r).forEach(([i,s])=>{const l=we(i);o(l.fileType===n),t.push({filePath:i,pageFile:l,globValue:s})})}),t}function se(e){o(A(e))}const R=k("setPageFiles.ts",{});function ln(e){const{pageFiles:t,pageConfigs:n,pageConfigGlobal:r}=zt(e);R.pageFilesAll=t,R.pageConfigs=n,R.pageConfigGlobal=r}async function cn(e,t){e?(o(!R.pageFilesGetter),o(t===void 0)):(o(R.pageFilesGetter),o(typeof t=="boolean"),(!R.pageFilesAll||!t)&&await R.pageFilesGetter());const{pageFilesAll:n,pageConfigs:r,pageConfigGlobal:i}=R;o(n&&r&&i);const s=Nt(n,r);return{pageFilesAll:n,allPageIds:s,pageConfigs:r,pageConfigGlobal:i}}function Nt(e,t){const n=e.filter(({isDefaultPageFile:s})=>!s).map(({pageId:s})=>s),r=M(n),i=t.map(s=>s.pageId);return[...r,...i]}function Ut(e,t){var i;const n=e.filter(s=>s.pageId===t);return o(n.length<=1),(i=n[0])!=null?i:null}async function Gt(e,t){if("isAllLoaded"in e&&!t)return e;const n=await e.loadConfigValuesAll();{const{configValuesImported:r}=n,i=G(r);Object.assign(e.configValues,i)}{const{configValuesSerialized:r}=n,i=Se(r);Object.assign(e.configValues,i)}return X(e,{isAllLoaded:!0}),e}const ve="__whileFetchingAssets";async function un(e,t){const n=Ze(t._pageFilesAll,e),r=Ut(t._pageConfigs,e);let i;const s=!1;try{i=(await Promise.all([r&&Gt(r,s),...n.map(g=>{var E;return(E=g.loadFile)==null?void 0:E.call(g)})]))[0]}catch(h){throw Ht(h)&&Object.assign(h,{[ve]:!0}),h}const{config:l,configEntries:a,exports:c,exportsAll:u,pageExports:d}=Rt(n,i);return{config:l,configEntries:a,exports:c,exportsAll:u,pageExports:d,_pageFilesLoaded:n}}function fn(e){return e?e[ve]===!0:!1}function Ht(e){return e instanceof Error?["Failed to fetch dynamically imported module","error loading dynamically imported module","Importing a module script failed","error resolving module specifier","failed to resolve module"].some(n=>e.message.toLowerCase().includes(n.toLowerCase())):!1}async function dn(e,t){const n=gt(e,t);let r=null,i;r=N(e,"render"),i="render";{const a=N(e,"onRenderClient");a&&(r=a,i="onRenderClient")}if(!r){const a=Bt(e);if(o(a),e._pageConfigs.length>0)p(!1,`No onRenderClient() hook defined for URL '${a}', but it's needed, see https://vike.dev/onRenderClient`);else{const c=e._pageFilesLoaded.filter(d=>d.fileType===".page.client");let u;c.length===0?u="No file `*.page.client.*` found for URL "+a:u="One of the following files should export a render() hook: "+c.map(d=>d.filePath).join(" "),p(!1,u)}}o(r);const s=r.hookFn;o(i);const l=await We(()=>s(n),i,r.hookFilePath);p(l===void 0,`The ${i}() hook defined by ${r.hookFilePath} isn't allowed to return a value`)}function Bt(e){var n;let t;try{t=(n=e.urlPathname)!=null?n:e.urlOriginal}catch{}return t=t!=null?t:window.location.href,t}export{Yt as A,m as B,k as C,rn as D,gt as E,on as F,K as G,je as H,en as I,$t as J,V as K,an as L,He as M,ue as N,Ze as O,Ut as P,qe as Q,tn as R,Kt as S,fn as T,Jt as U,Zt as a,p as b,cn as c,O as d,Xt as e,Mt as f,Qt as g,dn as h,sn as i,qt as j,H as k,un as l,Ce as m,xe as n,X as o,v as p,A as q,nn as r,ln as s,o as t,w as u,ye as v,Ve as w,L as x,N as y,We as z};
